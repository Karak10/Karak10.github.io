<!DOCTYPE HTML>
<html lang="en-US">
<head>
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
<title> Page twenty-three of my notes </title>
<meta charset="UTF-8"> 
<link href="../CSS-JavaScript-External-Files/HTMLnotes.css" rel="stylesheet">
<Style>
    .left {
        text-align: left;
        margin-left: 10px;
    }
    
    .code10 {
    white-space: pre-wrap;
    background-color: lightgreen;
    
    }
    
    p {
    text-align:center;
    }
    h1 {
    text-align:center;
    }
    h2 {
    text-align:center;
    }
    h3 {
    text-align:center;
    }
    .c {
    background-color:lightgreen;
    }
    hr {
    width:100%;
    height:15px;
    background-color:black;
    color:black;
    border: black solid;
    }
    body {
    background-color:rgb(165, 235, 235);
    }
    span {
    background-color:lightgreen;
    }
    
    a:link {
    color: black;
    text-shadow: 1px 0px 1px black;
    
    }
    
    a:visited {
    color: black;
    text-shadow: 1px 0px 1px rgb(22, 22, 22);
    }
    
    a:hover {
    text-decoration: underline;
    color: red;
    text-shadow: 1px 0px 1px black;
    }

    .pink {
        background-color: lightcoral;
        font-weight: bold;
    }

    iframe {
        width: 600px;
        height: 350px;
        border: 3px solid black;
        margin: 20px auto 20px auto;
        display: block;
    }
    
   .list_container{
       width: 50vw;
       max-width: 600px;
       background-color: white;
       border: 3px solid black;
       border-radius: 20px;
       margin: 20px auto 20px auto;
       padding: 20px;
       font-weight: bold;
   }
    
   .list_container li{
       margin-top: 15px;

   }

   .gray{
       background-color: lightgray;
   }

    </style> 
</head>
<body>

<hr>

    <header> 
    <h1> Page eleven of my JavaScript notes </h1>
    </header>
    
<article id="start-of-page"> 
  
<div id="homepages">

    <h3>Home Pages:</h3>
   

</div>

<nav data-notes="JavaScript" data-page="11">

</nav>

    <h3> Informations included in this page:</h3>
    <p><a href="../JavaScript-Notes/Notes23.html#one">Introduction to Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#two">Canvas Basics</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#three">Introduction to Canvas Paths</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#four">Bezier Curves in Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#five">Canvas Arcs</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#six">Canvas Text</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#seven">Linear Gradients in Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eight">Canvas Transforms</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#nine">Stroke properties</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#ten">Canvas globalAlpha property</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eleven">Using images</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twelve">Animating the Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#thirteen">Using event listeners with Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#fourteen">Creating gravity effect on Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#fifteen">Collision Detection</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#sixteen">Circular Movement</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#seventeen">How to obtain and manipulate pixels data</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eighteen">How to make Sine Waves</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#nineteen">Controlled Randomness with Perlin Noise</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twenty">How to create fireworks</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentyone">How to make a light saber</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentytwo">Torn-Like Particle Tunnels</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentythree">Shadow Properties</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentyfour">Galactic Light Trails</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentyfive">How to create a text wrapper in Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentysix">Creating my first Canvas game</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentyseven">Pixels rain</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twentyeight">Pixels that move when hovered over</a></p>

</article>

 <script src="../CSS-JavaScript-External-Files/nav.js"></script>

<hr>

<article id="one">

    <header>
        <h1>Introduction to Canvas</h1>
    </header>

<p>Back to drawing again, this takes me back to the times I was learning how to 
    draw <Span>SVG</Span>, hopefully some of the stuff I learned back then will 
make the learning process of the <Span>canvas</Span> easier for me, since even though 
the are different they still have some similarities too. So what exactly is the <Span>canvas</Span>?
And how is that different from <Span>SVG</Span>?</p>

<p><Span>&lt;canvas></Span> is an <span>HTML</span> element which can be used 
to draw <Span>graphics</Span> via <Span>scripting</Span> (usually <Span>JavaScript</Span>). This 
can, for instance, be used to draw <Span>graphs</Span>, <Span>combined photos</Span>, 
or create <Span>animations</Span>, <Span>games</Span> and more.</p>

<p>The main difference between <Span>canvas</Span> and <Span>SVG</Span> is that 
<Span>canvas</Span> is drawn <Span>progammatically</Span> and the <Span>drawing</Span>
is done with <Span>pixels</Span>, while <Span>SVG</Span> is drawn by 
<Span>elements</Span> which are a part of the page's <Span>DOM</Span> and the 
<Span>drawing</Span> is done by <Span>vectors</Span>. I have listed 
more about <Span>canvas</Span> and <Span>SVG</Span> <a href="../HTML-Notes/Notes5.html#twelve">here</a>
but these I believe are the most important differences. </p>

<p>So now, let's try and create our very first <Span>canvas</Span> element:</p>

<p class="left">HTML Code:</p>

<p class="left"><span class="code10">&lt;canvas id="first-canvas">&lt;/canvas></span></p>

<p class="left">CSS Code:</p>

<p class="left"><span class="code10">#first-canvas{
    display: block;
    margin: 20px auto 20px auto;
    border: 2px solid black;
}</span></p>

<p class="left">Outcome:</p>

<style>
    #first-canvas{
        display: block;
        margin: 20px auto 20px auto;
        border: 2px solid black;
    }
</style>

<canvas id="first-canvas"></canvas>

<p>So as you can see, the <Span>canvas</Span> is an <Span>inline-block</Span> element
and by default it's <Span>background</Span> is <Span>invisible</Span>, it also has a 
<Span>default size</Span>, which I think is <span>300px width</span> and <Span>150px height</Span>.</p>

</article>

<hr>

<article id="two">

    <header>
        <h1>Canvas Basics</h1>
    </header>

<p>Let's learn how to draw some basic shapes now, drawing is 
done <Span>progammatically</Span>, so we will have to do it 
through <Span>JavaScript</Span> of course, to draw stuff you 
first need to access the <Span>context</Span> of the <Span>canvas</Span>
which you can do by using <Span>getContext()</Span> method, this method 
can take a <Span>parameter</Span>, all I know at the moment is that we should 
write <Span>getContext('2d')</Span>, because we will be drawing in <Span>2d</Span>
I guess, later we may learn about <span>3d</span> too.</p>

<p>The <Span>getContext('2d') method</Span>
will return the <Span>CanvasRenderingContext2D</Span> object, which contains information 
about the <Span>canvas</Span>, if you access it's <Span>prototype</Span> using <Span>__proto__</Span>
there you will find all the different <Span>methods</Span> that you can use to 
<Span>draw</Span> the <Span>canvas</Span>, so if you ever forget a <Span>method</Span>
that's where you can find a reference of all the <Span>methods</Span> that exist, through it's 
<Span>prototype</Span> you can access it's <Span>constructor</Span> and the <Span>Object Prototype</Span>, 
and that's basically how <Span>CanvasRenderingContext2D</Span> is chained in the 
<Span>prototype tree</Span>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#first-canvas');
let c = canvas.getContext('2d');
console.log(c);</span></p>

<p class="left">Outcome:</p>

<style>
    img{
        display: block;
        border: 2px solid black;
        margin: 20px auto 20px auto;
        border-radius: 20px;
    }
</style>
<img src="../images/ζ1.PNG">

</p>

<script>
    if(true){
       let canvas = document.querySelector('#first-canvas');
       let c = canvas.getContext('2d');
       console.log(c);
    }
</script>

<p>So, let's start by drawing a simple <Span>rectangle</Span>, to do so we will need to use 
the <span>fillRect(x, y, width, height)</span> method, like in the example below:</p>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;canvas id="second-canvas" class="canvas">&lt;/canvas></Span></p>

<p class="left">CSS Code:</p>

<p class="left"><Span class="code10">.canvas{
    display: block;
    margin: 20px auto 20px auto;
    width: 500px;
    height: 200px;
    border: 2px solid black;
    background-color: white;
}</Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas =  document.querySelector('#second-canvas');
let c = canvas.getContext('2d');

c.fillRect(100, 20, 100, 100);</Span></p>

<p class="left">Outcome:</p>

<style>
    .canvas{
        display: block;
        margin: 20px auto 20px auto;
        width: 500px;
        height: 200px;
        background-color: white;
        border: 2px solid black;
    }
</style>

<canvas id="second-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas =  document.querySelector('#second-canvas');
        let c = canvas.getContext('2d');

        c.fillRect(100, 20, 100, 100);
    }
</script>

<p>So, the <Span>y</Span> is the <Span>top</Span> of the <Span>rectangle</Span>
and not the <Span>bottom</Span> as you may expected, imagine the <Span>rectangle</Span> was 
a <Span>paper</Span>, put your finger on the <Span>top left corner</Span> of the <Span>rectangle</Span> and 
move it <Span>100 px</Span> to the <Span>right</Span> and <Span>20px down</Span>, that's what we basically did.</p>

<p>So, how do you <Span>color</Span> those <Span>rectangles</Span>? If you take a 
look at <Span>CanvasRenderingContext2D object</Span> in the picture above, there 
is a <span>property</span> called <span>fillStyle</span>, by default it's set to 
<Span>#000000</Span>, which is <Span>black</Span>, when using a <Span>method</Span> such 
as <Span>fillRect()</Span>, the <Span>shape</Span> looks at <Span>fillStyle</Span> property 
and <Span>colors</Span> the <Span>shape</Span> based on the <Span>value</Span> of the 
<span>property</span>, so to <Span>color</Span> your <Span>rectangles</Span> simple 
<span>change</span> the <Span>value</Span> of this <Span>property</Span> to the 
wanted <Span>color</Span>, like in the example below:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#third-canvas');
let c = canvas.getContext('2d');

c.fillStyle = "red";
c.fillRect(20, 20, 50, 50);
c.fillStyle = "green";
c.fillRect(200, 20, 50, 50);
c.fillStyle = "blue";
c.fillRect(100, 80, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="third-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#third-canvas');
        let c = canvas.getContext('2d');
        
        c.fillStyle = "red";
        c.fillRect(20, 20, 50, 50);
        c.fillStyle = "green";
        c.fillRect(200, 20, 50, 50);
        c.fillStyle = "blue";
        c.fillRect(100, 80, 50, 50);
       
    }
</script>

<p>How do we style the <Span>stroke</Span> of those <Span>rectangles</Span> now? Just like 
<Span>fillStyle</Span>, if you take a look in the <span>CanvasRenderingContext2D</span> there is a 
<Span>property</Span> called <Span>strokeStyle</Span> which by default is set to <Span>black</Span>, 
the <Span>value</Span> of this <Span>property</Span> is used to set the <Span>color</Span> of the 
<Span>stroke</Span>, however, the <Span>rectangles</Span> above don't have a <span>stroke</span>, 
so how do we add them one? You could use <Span>strokeRect</Span> to create a <Span>rectangle</Span>
with only <Span>stroke</Span> and then <Span>position it</Span> where your <span>rectangle</Span>
is.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#fourth-canvas');
let c = canvas.getContext('2d');

c.strokeStyle = "red";
c.fillRect(20, 20, 50, 50);
c.strokeRect(20, 20, 50, 50);
c.fillRect(200, 20, 50, 50);
c.strokeRect(200, 20, 50, 50);
c.fillRect(100, 80, 50, 50);
c.strokeRect(100, 80, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="fourth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#fourth-canvas');
        let c = canvas.getContext('2d');
        
        c.strokeStyle = "red";
        c.fillRect(20, 20, 50, 50);
        c.strokeRect(20, 20, 50, 50);
        c.fillRect(200, 20, 50, 50);
        c.strokeRect(200, 20, 50, 50);
        c.fillRect(100, 80, 50, 50);
        c.strokeRect(100, 80, 50, 50);
       
    }
</script>

<p>Alright, great, but how do you change the <Span>width</Span> of the 
<Span>stroke</Span>? You can do so with the <Span>lineWidth</Span> property, just 
like <Span>fillStyle</Span> and <Span>stokeStyle</Span>, this <span>property</span> can be 
found inside the <Span>CanvasRenderingContext2D</Span> and by default it's 
<span>value</span> is <Span>1</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#fifth-canvas');
let c = canvas.getContext('2d');

c.strokeStyle = "red";
c.lineWidth = "10";
c.fillRect(100, 20, 100, 100);
c.strokeRect(100, 20, 100, 100);</Span></p>

<p class="left">Outcome:</p>

<canvas id="fifth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#fifth-canvas');
        let c = canvas.getContext('2d');
        
        c.strokeStyle = "red";
        c.lineWidth = "10";
        c.fillRect(100, 20, 100, 100);
        c.strokeRect(100, 20, 100, 100);
       
    }
</script>

<p>So now, what if you wanted to create many <Span>rectangles</Span> and 
wanted to have a <Span>stroke</Span> for all of them? Would you need to 
make all <Span>rectangles</Span> and <span>strokes</span> differently? That would take 
a lot of space and time, so you could instead create a <Span>function</Span>
that creates <Span>rectangles with stroke</Span> without needing to place
the <Span>stroke</Span> and <Span>rectangle</Span> differently:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#sixth-canvas');
let c = canvas.getContext('2d');

function createRect(x, y, w, h, fs, ss, lw){
    c.fillStyle = fs;
    c.strokeStyle = ss;
    c.lineWidth = lw;
    c.fillRect(x, y, w, h);
    c.strokeRect(x, y, w, h);    
}

createRect(20, 40, 50, 50);
createRect(100, 20, 50, 50, 'yellow', undefined,5);
createRect(180, 40, 50, 50, 'blue', 'red', 3);</Span></p>

<p class="left">Outcome:</p>

<canvas id="sixth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#sixth-canvas');
        let c = canvas.getContext('2d');
        
        function createRect(x, y, w, h, fs, ss, lw){
            c.fillStyle = fs;
            c.strokeStyle = ss;
            c.lineWidth = lw;
            c.fillRect(x, y, w, h);
            c.strokeRect(x, y, w, h);    
        }
        
        createRect(20, 40, 50, 50);
        createRect(100, 20, 50, 50, 'yellow', undefined,5);
        createRect(180, 40, 50, 50, 'blue', 'red', 3);
       
    }
</script>

<p>Before I finish with this section, I want to also talk about <span>clearRect(x, y, w, h)</span>
method, which <span>clears</Span> a <Span>specified rectangular area</Span>, making it 
<Span>fully transparent</Span>, like this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#eighth-canvas');
let c = canvas.getContext('2d');

c.fillRect(20, 20, 100, 100);
c.clearRect(40, 40, 60, 60);</Span></p>

<p class="left">Outcome:</p>

<canvas id="eighth-canvas" class="canvas"></canvas>

<script>
   if(true){
       let canvas = document.querySelector('#eighth-canvas');
       let c = canvas.getContext('2d');

       c.fillRect(20, 20, 100, 100);
       c.clearRect(40, 40, 60, 60);
   }
</script>

<p>So what did we learn in this section? Here is a list of 
    all the <span>properties</span> and <span>methods</span> we 
    went over, as well as a quick description of what each does:

    <div class="list_container">
        <ul>
            <li><span>canvas.getContext('2d')</span> - returns the CanvasRenderingContext2D object, should be accessed in order to use any of the following methods/properties</li>
            <li><span>fillRect(x, y, w, h)</span> - creates a rectangle</li>
            <li><span>strokeRect(x, y, w, h)</span> - creates a stroke of a rectangle, without a fill</li>
            <li><Span>clearRect(x, y, w, h)</Span> - clears the specified rectangular area making it fully transparent</li>
            <li><span>fillStyle = string</span> - sets the color that should be used when creating shapes</li>
            <li><span>strokeStyle = string</span> - sets the color that should be used when creating strokes</li>
            <li><span>lineWidth = number</span> - sets the width that should be used when creating strokes</li>
       </ul>
    </div>
</p>
</article>

<hr>

<article id="three">

    <header>
        <h1>Introduction to Canvas Paths</h1>
    </header>

    <p>Alright, so we now know how to make <Span>rectangles</Span>, we are not going 
    to make minecraft though, so we need something more than just <Span>rectangles</Span>.
    Let's talk about <Span>paths</Span> now, they are pretty similar to <Span>SVG paths</Span>,
what exactly is a <span>path</span> though?</p>

<P>You can think of a <Span>path</Span> as a <Span>set of instructions</Span> used 
to move a <Span>virtual pen</Span> around to form <Span>lines</Span> and 
<Span>curves</Span>, in this section, I will go over some basic <Span>path commands</Span>, I 
will get in more details about <Span>curves</Span>, <Span>arcs</Span> and more in later sections.</P>

<p>To <Span>begin a path</Span> you shoud use the <Span>beginPath()</Span> method, after 
that to start <Span>drawing your path</Span> you can use <Span>moveTo(x, y)</Span> to <Span>pick up</Span>
your <Span>virtual pen</Span> and <Span>move it</Span> around, <Span>without drawing</Span>, and then you can use 
<Span>lineTo(x, y)</Span> to create a <Span>line</Span> from the position your 
<Span>virtual pen</Span> was moved to, to the specified <Span>coordinates</Span>, lastly, you can 
use the <Span>closePath()</Span> method to create a <Span>line</Span> back to the 
<Span>start of the path</Span> and <Span>close the shape</Span>. This by it 
self will not have any visible effect on the <Span>canvas</Span> however, and that's because the <Span>path</Span> 
still has no <Span>stroke</Span> or <Span>fill</Span>, you can add a <Span>stroke</Span>
using the <Span>stroke()</Span> method, and you can add a <Span>fill</Span> using the <Span>fill()</Span> method.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#seventh-canvas');
let c = canvas.getContext('2d');

c.beginPath();
c.moveTo(10, 10);
c.lineTo(100, 10);
c.lineTo(100, 100);
c.closePath();
c.strokeStyle = 'red';
c.lineWidth = 3;
c.stroke();
c.fillStyle = 'yellow';
c.fill();</Span></p>

<p class="left">Outcome:</p>

<canvas id="seventh-canvas" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#seventh-canvas');
        let c = canvas.getContext('2d');

        c.beginPath();
        c.moveTo(10, 10);
        c.lineTo(100, 10);
        c.lineTo(100, 100);
        c.closePath();
        c.strokeStyle = 'red';
        c.lineWidth = 3;
        c.stroke();
        c.fillStyle = 'yellow';
        c.fill();
    }
</Script>

<p>So what did we lern in this section? Here is a list of all the <Span>methods</Span> we went over, 
as well as a quick description of what each does:</p>

<div class="list_container">
    <li><Span>beginPath()</Span> - creates a new path, once created, future drawing commands 
    can be directed into the path and used to build the path up</li>
    <li><Span>stroke()</Span> - draws the shape by stroking the path's outline</li>
    <li><Span>fill()</Span> - draws a solid shape by filling the path's content area</li>
    <li><Span>moveTo(x, y)</Span> - moves the virtual pen to the coordinates specified by x and y</li>
    <li><Span>lineTo(x, y)</Span> - draws a line from current drawing position to the position specified by x and y</li>
    <li><Span>closePath()</Span> - adds a straight line to the path, going to the start of the current sub-path</li>
</div>

<p>Here is a really cool video that explains the methods I just talked about in only two minute:</p>
<iframe src="https://www.youtube.com/embed/VNejl6cMH-s" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="four">

    <header>
        <h1>Bezier Curves in Canvas</h1>
    </header>

    <p>The next type of <Span>paths</span> I want to talk about are <Span>Bezier curves</span>, there are 
    actually <Span>2 methods</Span> I want to talk about, and these are <Span>quadraticCurveTo(cp1x, cp1y, x, y)</Span>
and <Span>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</Span> methods.</p>

<p>The difference between these two can best be described using the following image:</p>

<img src="../images/ζ2.PNG">

<p>As you can see, to draw <Span>curves</Span> you are using <Span>control points</Span>, 
<span>bezier curves</span> use <Span>two control points</Span> while <Span>quadratic curves</Span> 
only use <Span>one control point</Span>.</p>

<p>Here is a <Span>quadratic curve</Span> for example, I have set a <Span>background</Span> and 
drew the <Span>control point</Span> too so that it is easier to see what exactly happens with the code, 
in order to get confortable with using <Span>control points</Span> you should play around with 
it:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-one');
let c = canvas.getContext('2d');

c.beginPath();
c.strokeStyle = "black";
c.moveTo(80, 60);
c.quadraticCurveTo(120, 100, 160, 60)
c.lineWidth = 3;
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-one" class="canvas"></canvas>

<style>
  .canvas{
      height: 250px;
  }
</style>
<Script>
    function background(x){
        x.fillStyle = "rgba(6, 190, 46, 0.100)"
        for(let i=0; i<=40; i++){
        x.fillRect(0, i * 20, 500, 1);
        x.fillRect(i * 20, 0, 1, 200);
        x.fillStyle = "rgba(6, 190, 46, 0.579)"
        if(i > 1){
        x.fillRect(i * 10, 10, 1, 200);
        } 
        x.fillRect(0, i * 10, 500, 1);
        x.lineWidth = 1;
        x.font = "8px Arial"
        if(i == 1){
            x.strokeText(i * 10, 1.5, i * 10 - 1);
         } else if(i > 1 && i <= 4){
        x.strokeText(i * 20, i * 20 - 15, 8);
        x.strokeText(i * 10, 1.5, i * 10 - 1);
        } else {
            x.strokeText(i * 20, i * 20 - 16, 8)
            x.strokeText(i * 10, 1.5, i * 10 - 1);
        }

        }
    }

    if(true){
        let canvas = document.querySelector('#canvas-one');
        let c = canvas.getContext('2d');
        
        background(c);

        c.beginPath();
        c.lineWidth = 1;
        c.strokeStyle = "gray";
        c.moveTo(80, 60);
        c.lineTo(120, 100);
        c.lineTo(160, 60);
        c.stroke();

        c.beginPath();
        c.fillStyle = "red";
        c.arc(120, 100, 2, 0, 2*Math.PI);
        c.fill();

        c.beginPath();
        c.strokeStyle = "black";
        c.moveTo(80, 60);
        c.quadraticCurveTo(120, 100, 160, 60)
        c.lineWidth = 3;
        c.stroke();

    }
</Script>

<p>Now let's try to create a <Span>bezier curve</Span>, which uses 
    <Span>two control points</span>:

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-2');
let c = canvas.getContext('2d');

c.beginPath();
c.moveTo(70, 80);
c.bezierCurveTo(90, 30, 150, 120, 180, 80);
c.lineWidth = 2;
c.strokeStyle="black";
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-2"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-2');
        let c = canvas.getContext('2d');

        background(c);

        c.beginPath();
        c.moveTo(70, 80)
        c.lineTo(90, 30);
        c.moveTo(180, 80);
        c.lineTo(150, 120);
        c.strokeStyle = "gray";
        c.stroke();

        c.beginPath();
        c.fillStyle = "red";
        c.arc(90, 30, 2, 0, 2*Math.PI);
        c.arc(150, 120, 2, 0, 2*Math.PI);
        c.fill();

        c.beginPath();
        c.moveTo(70, 80);
        c.bezierCurveTo(90, 30, 150, 120, 180, 80);
        c.lineWidth = 2;
        c.strokeStyle="black";
        c.stroke();
    }
</Script>

<p>Here is a helpful video that explains curves pretty well:</p>

<iframe src="https://www.youtube.com/embed/uQbqB8J7Ua0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="five">

    <header>
        <h1>Canvas Arcs</h1>
    </header>

    <p>Let's now learn about <Span>Arcs</Span>, to create <Span>arcs</Span> you should use 
    the <Span>arc(x, y, r, sAngle, eAngle, counterclockwise)</Span> method, as you can see it has quite 
a few <Span>parameters</Span> it can take, but I'm gonna explain what each does as well as I can.</p>

<p>The <Span>x</Span> and <Span>y</Span> should be used to place the <Span>arc</Span>
on the <Span>canvas</Span>, the <Span>r</Span> is the <Span>radius</Span> of 
the <Span>arc</Span>, the <Span>sAngle</Span> and <Span>eAngle</Span> parameters take 
<Span>radians</Span> and define the <Span>starting angle</Span> and <Span>ending angle</Span> of 
the <Span>arc</Span> and lastly the <Span>counterclockwise</Span> is <Span>optional</Span> and takes a 
<Span>boolean value</Span>, by default it is <Span>fault</Span> which means 
the <Span>arc</Span> is drawn <Span>clockwise</Span>, if changed to <Span>ture</Span> 
the it is drawn <Span>counter-clockwise</Span>. </p>

<p>In order to easier be able to work with <Span>arcs</Span>, we will convert 
<Span>degrees</Span> to <Span>radians</Span> by doing <Span>degrees * Math.PI / 180</Span>, 
here is an example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-3');
let c = canvas.getContext('2d');

let Sangle = 90 * Math.PI / 180;
let Eangle = 180 * Math.PI / 180;

c.fillStyle = "green"
c.strokeStyle = "black";

c.beginPath();
c.arc(70, 90, 30, Sangle, Eangle, false);
c.lineTo(70, 90);
c.closePath();
c.stroke();
c.fill();

Sangle = -90 * Math.PI / 180;
Eangle = 180 * Math.PI / 180;

c.beginPath();
c.arc(155, 90, 30, Sangle, Eangle, false);
c.lineTo(155, 90);
c.closePath();
c.stroke();
c.fill();
  
Sangle = 90 * Math.PI / 180;
Eangle = 180 * Math.PI / 180;

c.beginPath();
c.arc(240, 90, 30, Sangle, Eangle, true);
c.lineTo(240, 90);
c.closePath();
c.stroke();
c.fill();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-3" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-3');
        let c = canvas.getContext('2d');

        background(c);

        let Sangle = 90 * Math.PI / 180;
        let Eangle = 180 * Math.PI / 180;

        c.beginPath()
        c.strokeStyle = "red";
        c.arc(70, 90, 30, 0, 2 * Math.PI, false);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(70, 90, 30, Sangle, Eangle, false);
        c.lineTo(70, 90);
        c.closePath();
        c.stroke();
        c.fill();

        Sangle = -90 * Math.PI / 180;
        Eangle = 180 * Math.PI / 180;

        c.beginPath();
        c.strokeStyle = "red";
        c.arc(155, 90, 30, 0, 2 * Math.PI, false);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(155, 90, 30, Sangle, Eangle, false);
        c.lineTo(155, 90);
        c.closePath();
        c.stroke();
        c.fill();

        
        Sangle = 90 * Math.PI / 180;
        Eangle = 180 * Math.PI / 180;

        c.beginPath();
        c.strokeStyle = "red";
        c.arc(240, 90, 30, 0, 2 * Math.PI, true);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(240, 90, 30, Sangle, Eangle, true);
        c.lineTo(240, 90);
        c.closePath();
        c.stroke();
        c.fill();

    }
</Script>

<p>I have done some extra decoration so tht it's easier to understand what's happening, so, let's look at the 
    <Span>first arc</Span>, it is drawn <Span>clockwise</Span>, the <span>arcs</span>
    are drawn from the <Span>x axis</Span> of the <Span>right side</span> of the <Span>circle</Span>, since it's <Span>end angle</Span> is 
    <Span>180</Span> the <Span>arc</Span> was drawn all the way to the <San>left side</San> forming <Span>half a circle</Span>, 
    however, since the <Span>start angle</Span> is <Span>90</Span>, the <Span>90 first degrees</Span> were 
    <Span>cleared</Span>, leaving us with <Span>1/4 of the circle</Span>.
</p>

<p>The <Span>second arc</Span> is the same, except that the <Span>star degree</Span> is 
<Span>-90</Span> instead of <span>90</span>. Lastly, the <Span>third arc</Span> is drawn <Span>counter-clockwise</Span>, it's 
<Span>end degree</Span> is <Span>180</Span> which is why the <Span>top half</Span> of the  
<span>arc</span> is drawn and the <Span>start degree</Span> is <Span>90</Span>, the <Span>start degree</Span> 
is formed <Span>clockwise</Span> no matter what, so that's why the <Span>1/4</Span> of the <Span>right down side</Span> of the <Span>circle</Span> 
is drawn.</Span></p>

<p>Alright, so <Span>arc()</Span> method is pretty cool when you want to make 
<Span>circles</Span> and stuff, let's now talk about <Span>arcTo(x1, y1, x2, y2, r)</Span> method
which is kind like <Span>curves</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-4');
let c = canvas.getContext('2d');

c.beginPath();
c.strokeStyle = "black";
c.lineWidth = "2";
c.moveTo(100, 90);
c.arcTo(155, 50, 200, 90, 40);
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-4" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-4');
        let c = canvas.getContext('2d');

        background(c);
 
        c.beginPath();
        c.strokeStyle = "red";
        c.moveTo(100, 90);
        c.lineTo(155, 50);
        c.lineTo(200, 90);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "blue";
        c.arc(152, 102, 40, 0, 2 * Math.PI, false);
        c.font = "10px Arial";
        c.strokeText("40r", 147, 104);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.lineWidth = "2";
        c.moveTo(100, 90);
        c.arcTo(155, 50, 200, 90, 40);
        c.stroke();
    }
</Script>

<p>So, I did some extra decoration as you can see to help you understand what kind of happens 
    behind the scenes in order to form the <Span>arc</Span>, this is a little complicated the truth is, 
    however, I have just the perfect video right here to help you understand how this method works:
</p>

<iframe src="https://www.youtube.com/embed/VkS7B9IvGy8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="six">

    <header>
        <h1>Canvas Text</h1>
    </header>

<p>Let's now learn how to draw <Span>text</Span> on the 
<Span>canvas</Span>, the <Span>most important methods</Span> you need 
to know are the following: <Span>font</Span>, <Span>fillText(text, x, y)</Span>
and <span>strokeText(text, x, y)</span>.</p>

<div class="list_container">
    <ul>
        <li><Span>font</Span> - defines the font properties for the text, must like in CSS</li>
        <li><span>fillText(text, x, y)</span> - draws filled text on the canvas</li>
        <li><span>strokeText(text, x, y)</span> - draws text on the canvas without fill</li>
    </ul>
</div>

<p class = "left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-5');
let c = canvas.getContext('2d');

<Span class="gray">// type, size, font-family
// type: norma, italic, bold</span>
c.font = "normal 24px Arial";
c.fillStyle = "blue";

c.fillText("Hello World!", 80, 60);
c.strokeText("Hello World!", 80, 60);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-5" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-5');
        let c = canvas.getContext('2d');

        background(c);
        
        // type, size, font-family
        // type: norma, italic, bold
        c.font = "normal 24px Arial";
        c.fillStyle = "blue";

        c.fillText("Hello World!", 80, 60);
        c.strokeText("Hello World!", 80, 60);

    }
</script>

<p>Let's learn some more <Span>methods</Span> now, to 
<Span>align</Span> text you will need to use <Span>textAlign</Span>
and <Span>textBaseline</Span> properties:</p>

<p>Let's first learn the different <Span>textAlign</Span> values 
you can use to <Span>align</Span> text <Span>horizontally</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-6');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";

c.textAlign = "start";
c.fillText('textAlign=start', 140, 40);
c.textAlign = "end";
c.fillText('textAlign=end', 140, 60);
c.textAlign = "left";
c.fillText('textAlign=left', 140, 80);
c.textAlign = "center";
c.fillText('textAlign=center', 140, 100);
c.textAlign = "right";
c.fillText('textAlign=right', 140, 120);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-6" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-6');
        let c = canvas.getContext('2d');

        background(c);
        
        c.fillStyle = "red";
        c.fillRect(140, 30, 1, 90);

        c.fillStyle = "black";
        c.font = "normal 15px Arial";
        
        c.textAlign = "start";
        c.fillText('textAlign=start', 140, 40);
        c.textAlign = "end";
        c.fillText('textAlign=end', 140, 60);
        c.textAlign = "left";
        c.fillText('textAlign=left', 140, 80);
        c.textAlign = "center";
        c.fillText('textAlign=center', 140, 100);
        c.textAlign = "right";
        c.fillText('textAlign=right', 140, 120);

    }
</Script>

<p>Now let's learn the different <Span>textBaseline</Span> values you can use 
to <Span>align</Span> text <Span>vertically</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-7');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";
c.textAlign = "start";

c.textBaseline = "top";
c.fillText('Top', 30, 70);
c.textBaseline = "bottom";
c.fillText('Bottom', 60, 70);
c.textBaseline = "middle";
c.fillText('Middle', 110, 70);
c.textBaseline = "alphabetic";
c.fillText('Alphabetic', 157, 70);
c.textBaseline = "hanging";
c.fillText('Hanging', 230, 70);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-7" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-7');
        let c = canvas.getContext('2d');

        background(c);

        c.fillStyle = "red";
        c.fillRect(30, 70, 258, 1);

        c.fillStyle = "black";
        c.font = "normal 15px Arial";
        c.textAlign = "start";

        c.textBaseline = "top";
        c.fillText('Top', 30, 70);
        c.textBaseline = "bottom";
        c.fillText('Bottom', 60, 70);
        c.textBaseline = "middle";
        c.fillText('Middle', 110, 70);
        c.textBaseline = "alphabetic";
        c.fillText('Alphabetic', 157, 70);
        c.textBaseline = "hanging";
        c.fillText('Hanging', 230, 70);

    }
</script>

<p>Next let's talk about <Span>direction</Span> property, this one is 
still <Span>experimental</Span>, and is not supported by <Span>Firefox</Span> and 
<Span>Internet Explorer</Span>, this <Span>property</Span> allows us to specify the 
<Span>direction</Span> to draw the <Span>text</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-8');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";

c.direction = "ltr";
c.fillText("left to right!", 100, 40);
c.direction = "rtl";
c.fillText("right to left!", 100, 60);
c.direction = "inherit";
c.fillText("inherit from canvas!", 100, 80)</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-8" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-8');
        let c = canvas.getContext('2d');

        background(c);
        
        c.fillStyle = "black";
        c.font = "normal 15px Arial";
 
        c.direction = "ltr";
        c.fillText("left to right!", 100, 40);
        c.direction = "rtl";
        c.fillText("right to left!", 100, 60);
        c.direction = "inherit";
        c.fillText("inherit from canvas!", 100, 80)

    }
</Script>

<P>Lastly, let's talk about how we can <Span>measure</Span> the 
<Span>text</Span> to get it's <Span>width</Span> or 
<Span>height</Span> using <Span>measureText(text)</Span> method:</P>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-9');
let c = canvas.getContext('2d');

let txt = "Hello World"

console.log(c.measureText(txt));

c.font = "normal 30px Arial";
c.fillStyle = "red";

c.fillText(txt, 90, 90)

console.log(c.measureText(txt));</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-9" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-9');
        let c = canvas.getContext('2d');

        background(c);

        let txt = "Hello World"

        console.log(c.measureText(txt));

        c.font = "normal 30px Arial";
        c.fillStyle = "red";

        c.fillText(txt, 90, 90)

        console.log(c.measureText(txt));
    }
</script>

<p>Here are the logs, as you can see, the <Span>width</Span> changed after I set 
the <Span>font</Span>:</p>
<img src="../images/χ1.JPG">


<p>Let's now make a little project for practice:</p>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;canvas id="canvas-10" class="canvas">&lt;/canvas>

&lt;p style="
width: 500px; 
text-align: left; 
margin: auto;
">
&lt;input type="text" id="inputc" value="Insert text">
&lt;/p></Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-10');
let c = canvas.getContext('2d');
let input = document.querySelector('#inputc');

let txt = "Insert text";
c.font = "normal 15px Arial";
c.fillStyle = "black";
c.fillText(txt, 20, 50);
let width = c.measureText(txt).width;
let txt2 = `Text Width: ${width}px`
c.fillText(txt2, 20, 100);
let width2 = c.measureText(txt2).width;

input.addEventListener('input', (e) => {
    c.clearRect(20, 37, width, 18);
    c.clearRect(20, 87, width2, 18);
    txt = input.value;
    width = c.measureText(txt).width;
    c.fillText(txt, 20, 50);
    txt2 = `Text Width: ${width}px`
    c.fillText(txt2, 20, 100);
    width2 = c.measureText(txt2).width;
});</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-10" class="canvas"></canvas>

<p style="
width: 500px; 
text-align: left; 
margin: auto;
">
<input type="text" id="inputc" value="Insert text">
</p>

<p>Here is a video that helped me a lot, watch it if you want and subscribe to 
    the guy, his tutorials have helped me countless of times:</p>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-10');
        let c = canvas.getContext('2d');
        let input = document.querySelector('#inputc');

        let txt = "Insert text";
        c.font = "normal 15px Arial";
        c.fillStyle = "black";
        c.fillText(txt, 20, 50);
        let width = c.measureText(txt).width;
        let txt2 = `Text Width: ${width}px`
        c.fillText(txt2, 20, 100);
        let width2 = c.measureText(txt2).width;

        input.addEventListener('input', (e) => {
            c.clearRect(20, 37, width, 18);
            c.clearRect(20, 87, width2, 18);
            txt = input.value;
            width = c.measureText(txt).width;
            c.fillText(txt, 20, 50);
            txt2 = `Text Width: ${width}px`
            c.fillText(txt2, 20, 100);
            width2 = c.measureText(txt2).width;
        });
       
    }
</script>


<iframe src="https://www.youtube.com/embed/qMPifeAMo7k" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="seven">
    <header>
        <h1>Linear Gradients in Canvas</h1>
    </header>

    <p>The <Span>createLinearGradient()</Span> method creates a <Span>linear gradient object</Span>. This 
    <Span>gradient</Span> can later be used to <Span>fillStyle</Span> and <Span>strokeStyle</Span> properties.</p>

    <p>The <Span>createLinearGradient(x0, y0, x1, y1)</Span> method takes <Span>four parameters</Span>, which define the 
    <Span>start point</Span> and <span>end point</span> of the <span>gradient</span>, inside the 
<Span>gradient object</Span> that is returned by the <Span>createLinearGradient()</Span> method 
there is a <Span>method</Span>:</p>

    <canvas id="canvas-01" height="1"></canvas>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-01');
let c = canvas.getContext("2d");

let gradient = c.createLinearGradient(10, 10, 10, 190);

console.log(gradient);</span></p>

<p class="left">Outcome:</p>

    <script>
        if(true){
            let canvas = document.querySelector('#canvas-01');
            let c = canvas.getContext("2d");

            let gradient = c.createLinearGradient(10, 10, 10, 190);

            console.log(gradient);
        }
    </script>

    <img src="../images/χ4.JPG">

    <p>To add <Span>colors</Span> to the <Span>linear gradient</Span> you will need to use the <span>addColoStop()</span> methods 
    which takes <span>two parameters</span>, the <Span>first parameter</Span> defines the 
<Span>position</Span> and the <span>second parameter</span> the <span>color</span>. The <span>first parameter</span> should 
take a value between <Span>0</Span> and <Span>1</Span>, where <Span>0.5</Span> represents <Span>50%</Span> and <Span>1</Span> 
represents <Span>100%</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById("canvas-02");
let c = canvas.getContext('2d');

let gradient = c.createLinearGradient(50,50,50,100);
gradient.addColorStop(0, 'red')
gradient.addColorStop(0.5, 'blue');
gradient.addColorStop(1, 'green');

c.fillStyle = gradient;
c.fillRect(50, 50, 100, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-02"></canvas>

<script>
    if(true){
        let canvas = document.getElementById("canvas-02");
        let c = canvas.getContext('2d');

        let gradient = c.createLinearGradient(50,50,50,100);
        gradient.addColorStop(0, 'red')
        gradient.addColorStop(0.5, 'blue');
        gradient.addColorStop(1, 'green');

        background(c);

        c.fillStyle = gradient;
        c.fillRect(50, 50, 100, 50);


    }
</script>

<p>The <Span>createLinearGradient()</Span> creates the <Span>direction</Span> and <Span>size</Span> of 
the <Span>gradient</Span>, if we were to change the <span>end point</span> to <Span>150, 100</Span> then 
the <span>direction</span> of the <Span>gradient</Span> would be from the <Span>top left</Span> of the 
<Span>rectangle</Span> towards the <Span>bottom right</Span> side of the <Span>rectangle</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10"> let canvas = document.getElementById("canvas-03");
let c = canvas.getContext('2d');

let gradient = c.createLinearGradient(50,50,150,100);
gradient.addColorStop(0, 'red')
gradient.addColorStop(0.33, 'red');
gradient.addColorStop(0.34, 'blue');
gradient.addColorStop(0.70, 'blue');
gradient.addColorStop(0.701, 'green');
gradient.addColorStop(1, 'green');

c.fillStyle = gradient;
c.fillRect(50, 50, 100, 50);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-03"></canvas>

<script>
    if(true){
        let canvas = document.getElementById("canvas-03");
        let c = canvas.getContext('2d');

        let gradient = c.createLinearGradient(50,50,150,100);
        gradient.addColorStop(0, 'red')
        gradient.addColorStop(0.33, 'red');
        gradient.addColorStop(0.34, 'blue');
        gradient.addColorStop(0.70, 'blue');
        gradient.addColorStop(0.701, 'green');
        gradient.addColorStop(1, 'green');

        background(c);

        c.fillStyle = gradient;
        c.fillRect(50, 50, 100, 50);


    }
</script>

<iframe src="https://www.youtube.com/embed/RlilYyjLF78" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="eight">
    <header>
        <h1>Canvas Transforms</h1>
    </header>

    <p>So, using <Span>CSS</Span> we can set the <Span>width</Span> and 
    <Span>height</Span> of the <Span>viewport</Span>, and using <Span>width</Span> and 
<Span>height</Span> attributes, either by hand either through <span>JavaScript</span> we can 
define the <Span>pixels</Span> inside the <Span>viewport</Span>. In this 
section we will learn more ways to <Span>customize</Span> the <Span>canvas grid</Span>. With <Span>transformations</Span> 
you can <Span>translate</Span> the <Span>0, 0</Span> point to a different position, 
<Span>rotate</Span> the grid and even <Span>scale</Span> it.</p>

<h2><u>Translating:</u></h2>

<p>The first of the <span>transformation methods</span> we will look at 
is <Span>translate()</Span>. This <span>method</span> is used to <Span>move</Span> the 
<Span>canvas and it's origin</Span> to a different point in the <Span>grid.</Span></p>

<p>The <Span>translate(x, y)</Span> methods <Span>moves the canvas and it's origin</Span> 
on the <Span>grid</Span>. The <Span>first parameter</Span> indicates the 
<Span>horizontal distance to move</Span>, and the <Span>second parameter</Span> indicates 
how far to <Span>move the grid vertically</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-05');
let c = canvas.getContext('2d');

background(c);

c.translate(100, 100);

c.fillStyle = "red";

c.beginPath();
c.arc(0, 0, 3, 0, 2 * Math.PI, false);
c.moveTo(20, 20);
c.arc(20, 20, 3, 0, 2 * Math.PI, false);
c.stroke();
c.fill()</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-05"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-05');
        let c = canvas.getContext('2d');

        background(c);

        c.translate(100, 100);
        
        c.fillStyle = "red";

        c.beginPath();
        c.arc(0, 0, 3, 0, 2 * Math.PI, false);
        c.moveTo(20, 20);
        c.arc(20, 20, 3, 0, 2 * Math.PI, false);
        c.stroke();
        c.fill()

    }
</script>

<h2><u>Rotating:</u></h2>
<p>The second <Span>transformation method</Span> I wanna talk about is 
<Span>rotate()</Span>. We use it to <Span>rotate</Span> the <Span>canvas</Span>
around the current <Span>origin</Span>.</p>

<p>The <Span>rotate(angle)</Span> method <Span>rotates</Span> the canvas <Span>clockwise</Span> 
around the <Span>current origin</Span> by the <Span>angle number of radians</Span>.</p>

<img src="../images/μ2.png">

<p>The <Span>rotation center point</Span> is always the <Span>canvas origin</Span>. To 
<span>change the center point</span>, we will need to <Span>move the canvas</Span> by 
using the <Span>translate()</Span> method.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById("canvas-06");
let c = canvas.getContext('2d');

c.translate(0, 0);
background(c);

c.fillStyle = 'red';
c.font = 'normal 15px Arial';

c.translate(100, 50);
c.rotate(135 * Math.PI / 180);

c.fillText('Hello World!', 0, 0);
c.fillRect(0, 10, 85, 5);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-06"></canvas>

<Script>
    if(true){
        let canvas = document.getElementById("canvas-06");
        let c = canvas.getContext('2d');

        c.translate(0, 0);
        background(c);

        c.fillStyle = 'red';
        c.font = 'normal 15px Arial';

        c.translate(100, 50);
        c.rotate(135 * Math.PI / 180);

        c.fillText('Hello World!', 0, 0);
        c.fillRect(0, 10, 85, 5);

    }
</Script>

<h2><u>Scaling:</u></h2>

<p>The next <Span>transformation method</Span> is <span>scaling</span>. We use this to <Span>increase</Span> or <Span>decrease</Span>
the <Span>units</Span> in our <span>canvas grid</span>. This can 
be used to draw <Span>scaled down</Span> or <span>enlarged</span> shapes and bitmaps.</p>

<p>The <span>scale(x, y)</span> method <Span>scales</Span> the <Span>canvas units</Span> by 
<Span>x horizontally</Span> and by <Span>y vertically</Span>. Both parameters are real numbers. 
Values that are <Span>smaller than 1.0</Span> will <Span>reduce the unit size</Span> and 
values <Span>above 1.0</Span> will <Span>increase the unit size</Span>. Values of <Span>1.0</Span> will 
<Span>leave the units the same size</Span>.</p>

<p>Using <span>negative numbers</span> will <Span>flip the shape</Span> and 
do <span>axis mirroring</span>, here are some example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-07');
let c = canvas.getContext('2d');

background(c);

c.save();
   c.scale(2, 2);
   c.fillRect(10, 10, 25, 25);
c.restore();

c.font = 'normal 20px Arial';
c.fillStyle = 'black';

c.save();
   c.translate(200, 50);
   c.scale(-1, 1);
   c.fillText('Hello World!', 0, 0);
c.restore();

c.save();
   c.translate(200, 100);
   c.scale(-1, 1);
   c.fillText('Hello People!', 0, 0)
c.restore();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-07"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-07');
        let c = canvas.getContext('2d');

        background(c);

        c.save();
           c.scale(2, 2);
           c.fillRect(10, 10, 25, 25);
        c.restore();

        c.font = 'normal 20px Arial';
        c.fillStyle = 'black';
        
        c.save();
           c.translate(200, 50);
           c.scale(-1, 1);
           c.fillText('Hello World!', 0, 0);
        c.restore();

        c.save();
           c.translate(200, 100);
           c.scale(-1, 1);
           c.fillText('Hello People!', 0, 0)
        c.restore();
    }
</script>

<p>So, you are probably wondering now what does <Span>save()</Span> and <Span>restore()</Span> do, and that's what 
I'm gonna talk about next.</p>

<h2><u>Saving and restoring state:</u></h2>

<p><Span>Canvas states</Span> are <span>stored</span> on a <Span>stack</Span>. Every time the <Span>save()</Span> method is called, 
the <span>current drawing state</span> is <Span>pushed onto the stack</Span>. A <Span>drawing state</Span> consists of:</p>

<div class="list_container">
    <ul>
        <li>The transformations that have been applied (i.e. translate, rotate 
            and scale)
        </li>
        <li>The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, 
            lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, globalCompositeOperation, font, textAlign, textBaseline, direction, 
            imageSmoothingEnabled.
        </li>
        <li>The current clipping path.</li>
    </ul>
</div>

<p>I still haven't talked about some of the stuff listed in the list, I will try and 
write about these later on my notes.
</p>

<p>You can call the <span>save()</span> method as many times as you like, Each time the <Span>restore()</Span>
method is called, the <Span>last saved state</Span> is <Span>popped off</Span> the 
<Span>stack</Span> and <Span>all saved settings are restored</Span>.</p>
    <iframe src="https://www.youtube.com/embed/5vxygxshTQ4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="nine">
    <header>
        <h1>Stroke properties</h1>
    </header>

    <p>In this section I want to talk some more about 
        <Span>strokes</Span>, there are a few <Span>properties</Span>
        out there that can be used to <span>decorate strokes</span>, 
        here is a list of all the properties I will explain in the
        section:
    </p>

    <div class="list_container">
        <dl>
            <dt><span>strokeStyle = 'color'</span></dt>
            <dd>strokeStyle property sets the color of the line. <br><br>
            </dd>
            <dt><span>lineWidth = number</span></dt>
            <dd>lineWidth property sets the width of the line. <br><br></dd>
            <dt><Span>lineCap = 'style'</Span></dt>
            <dd>linecap property is used to get or set the line cap style. 
                There are three cap styles, butt, round and square.
                <ul>
                    <li>butt: Default. A flat edge is put perpendicular to each 
                        end of the line with no cap added.
                    </li>
                    <li>round: A semicircle or rounded end cap is added to each end of the line.</li>
                    <li>square: A square end cap is added to each end of the line.</li>
                </ul>
            </dd>
            <dt><Span>lineJoin = 'type'</Span></dt>
            <dd>lineJoin property is used to get or set the type of corner that 
                is created when two lines join. There are three values, bevel, round and square.
                <ul>
                    <li>bevel: A filled triangle connects the two lines that are joined, creating a 
                        beveled corner.
                    </li>
                    <li>round: Lines join with a rounded corner.</li>
                    <li>miter: Default, lines join with a smoothly mitered corner.</li>
                </ul>
            </dd>
            <dt><span>setLineDash([array])</span></dt>
            <dd>The setLineDash() method sets the line dash pattern used when stroking lines, It uses an 
                array of values the specify alternating lengths of lines and gaps which describe the pattern.
            </dd>
            <dt><span>lineDashOffset = value</span></dt>
            <dd>lineDashOffset property sets the line dash offset. It's value 
                should be a float specifying the amount of the line dash offset. The default 
                value is 0.0 <br><br>
            </dd>
            <dt><Span>miterLimit = number</Span></dt>
            <dd>The miterLimit property sets or returns the maximum 
                miter length.
            </dd>
        </dl>
    </div>

    <p>So, I have already told about <span>lineWidth</span> and 
    <span>lineStyle</span> before, and there really isn't much about them anyway, 
couldn't be any simplier, so let's skip those two and get started with the 
<Span>lineCap</Span> property first, lets take a loo kat the different 
kind of <Span>line cap styles</Span> we can use:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-08');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';

c.lineCap = 'butt';

    c.beginPath();
    c.moveTo(50, 120);
    c.lineTo(50, 30);
    c.stroke();

c.lineCap = 'round';

    c.beginPath();
    c.moveTo(120, 120);
    c.lineTo(120, 30);
    c.stroke();

c.lineCap = 'square';

    c.beginPath();
    c.moveTo(190, 120);
    c.lineTo(190, 30);
    c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-08" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-08');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        
        c.lineCap = 'butt';

            c.beginPath();
            c.moveTo(50, 120);
            c.lineTo(50, 30);
            c.stroke();

        c.lineCap = 'round';

            c.beginPath();
            c.moveTo(120, 120);
            c.lineTo(120, 30);
            c.stroke();
        
        c.lineCap = 'square';

            c.beginPath();
            c.moveTo(190, 120);
            c.lineTo(190, 30);
            c.stroke();
    }
</script>

<p>The reason I had to create different <Span>paths</Span> is because only 
one <Span>style</Span> can be applied to the <Span>final shape</Span> made by the 
<Span>path</Span>, I could not create the <Span>three lines</Span> in <Span>one path</Span> 
and change the <Span>lineCap</Span> property for each, because only the <Span>final value</Span> 
I wrote would be used for the <span>path</span>.</p>

<p>Let's now check <Span>lineJoin</Span> property and the different <Span>types</Span> 
that can be used:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-09');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';

c.lineJoin = 'bevel';

    c.beginPath();
    c.moveTo(40, 120);
    c.lineTo(80, 120);
    c.lineTo(80, 30);
    c.lineTo(60, 50);
    c.stroke();

c.lineJoin = 'round';

    c.beginPath();
    c.moveTo(120, 120);
    c.lineTo(160, 120);
    c.lineTo(160, 30);
    c.lineTo(140, 50);
    c.stroke();

c.lineJoin = 'miter';

    c.beginPath();
    c.moveTo(200, 120);
    c.lineTo(240, 120);
    c.lineTo(240, 30);
    c.lineTo(220, 50);
    c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-09" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-09');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        
        c.lineJoin = 'bevel';

            c.beginPath();
            c.moveTo(40, 120);
            c.lineTo(80, 120);
            c.lineTo(80, 30);
            c.lineTo(60, 50);
            c.stroke();

        c.lineJoin = 'round';

            c.beginPath();
            c.moveTo(120, 120);
            c.lineTo(160, 120);
            c.lineTo(160, 30);
            c.lineTo(140, 50);
            c.stroke();
        
        c.lineJoin = 'miter';

            c.beginPath();
            c.moveTo(200, 120);
            c.lineTo(240, 120);
            c.lineTo(240, 30);
            c.lineTo(220, 50);
            c.stroke();
    }
</script>

<p>Since we just learned about the <span>miter</span> value of <Span>lineJoin</Span>, lets now 
talk about the <Span>miterLimit</Span> property.</p>

<p>The <Span>miterLimit</Span> property <span>sets</span> or 
<Span>returns</Span> the <Span>maximum miter length</Span>. The <Span>miter length</Span> is 
the <Span>distance</Span> between the <span>inner corner</span> and the <Span>outer corner</Span> where 
<Span>two lines meet</Span>.</p>

<img src="../images/ξ1.png">

<p>The <Span>miterLimit</Span> property works only if the <Span>lineJoin</Span> property is 
<Span>miter</Span>. The miter length <Span>grows bigger</Span> as the <span>angle of the corner gets smaller</span>.</p>

<p>To <Span>prevent</Span> the <Span>miter length</Span> from being too long, we can use 
the <span>miterLimit</span> property.</p>

<P>If the <span>miter length exceeds</span> the <Span>miter limit value</Span>, the 
<Span>corner</Span> will be displayed as <Span>lineJoin type 'bevel'</Span>.</P>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-idk');
let c = canvas.getContext('2d');

background(c);

function draw(x, y, y2){
    c.beginPath();
    c.moveTo(x, y);
    c.lineTo(x + 40, y);
    c.lineTo(x, y2);
    c.stroke(); 
}

c.lineWidth = 10;        
c.lineJoin = 'miter';
c.miterLimit = Number.POSITIVE_INFINITY;
c.strokeStyle = 'green';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);

c.miterLimit = 5;
c.strokeStyle = 'red';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);

c.lineJoin = 'bevel';
c.strokeStyle = 'blue';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-idk" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-idk');
        let c = canvas.getContext('2d');

        background(c);

        function draw(x, y, y2){
            c.beginPath();
            c.moveTo(x, y);
            c.lineTo(x + 40, y);
            c.lineTo(x, y2);
            c.stroke(); 
        }

        c.lineWidth = 10;        
        c.lineJoin = 'miter';
        c.miterLimit = Number.POSITIVE_INFINITY;
        c.strokeStyle = 'green';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);

        c.miterLimit = 5;
        c.strokeStyle = 'red';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);

        c.lineJoin = 'bevel';
        c.strokeStyle = 'blue';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);
           
    }
</script>

<p>So, in the example above, you can see how when <Span>miterLimit</Span>
is set to <span>5</span>, the <Span>middle lines</Span> use <span>bever type</span>
to connect, because the <Span>miter length</Span> extends <Span>5 pixels</Span>, while 
the others which don't are drawn without a problem.</p>


<p>Now, let's try <Span>setLineDash()</Span> method and <Span>lineDashOffSet</Span> property:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-010');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';
c.lineCap = 'butt';

c.setLineDash([20, 5, 10, 5]);
    c.beginPath();
    c.moveTo(40, 40);
    c.lineTo(200, 40);
    c.stroke();

c.setLineDash([20, 5, 20]);
     c.beginPath();
    c.moveTo(40, 80);
    c.lineTo(200, 80);
    c.stroke();

c.setLineDash([20, 5, 20]);
c.lineDashOffset = 25;
    c.beginPath();
    c.moveTo(40, 120);
    c.lineTo(200, 120);
    c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-010" class="canvas"></canvas>


<script>
    if(true){
        let canvas = document.querySelector('#canvas-010');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        c.lineCap = 'butt';

        c.setLineDash([20, 5, 10, 5]);
            c.beginPath();
            c.moveTo(40, 40);
            c.lineTo(200, 40);
            c.stroke();

        c.setLineDash([20, 5, 20]);
             c.beginPath();
            c.moveTo(40, 80);
            c.lineTo(200, 80);
            c.stroke();

        c.setLineDash([20, 5, 20]);
        c.lineDashOffset = 25;
            c.beginPath();
            c.moveTo(40, 120);
            c.lineTo(200, 120);
            c.stroke();
    }
</script>

<p>So, I need you to understand what happens with the <Span>dash pattern</Span>, the <span>pattern</span> 
goes like this: <span>line</span>, <Span>gap</Span>, <Span>line</Span>, etc, 
when it reads the <Span>array</Span>, the <Span>array values</Span> are used on this 
<Span>pattern</Span>, when the <span>array values</span> are over, it <Span>reads the array again</Span> from the <Span>start</Span>. If 
the <Span>array values</Span> are an <Span>even number</Span>, then everything works as expected, 
if however it's a <Span>an odd number</Span>, then after the <Span>array values end</Span>, when it 
<Span>starts reading from the start</Span> of the <Span>array</Span> the 
<span>first value</span> will be used to create a <Span>gap</Span>, and the <Span>second</Span> to 
create the <Span>line</Span>, and so on, till it reaches the end again, then it will get back to normal for the 
next run.</p>

<p>The <span>lineDashOffset</span> is used to <Span>move</Span> the <Span>stroke</Span>, 
this can create great effects when used for <Span>animations</Span>, here is an example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-011');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 5;
c.strokeStyle = 'red';
c.lineDashOffset = 0;

function draw(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    
    c.beginPath();
    c.moveTo(50, 50);
    c.lineTo(200, 50);
    c.lineTo(200, 120);
    c.lineTo(50, 120);
    c.closePath();
    c.stroke();
}

function march(){
    c.setLineDash([2,2]);
    c.lineDashOffset++;
    draw();
}

setInterval(march, 20);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-011" class="canvas"></canvas>


<script>
    if(true){
        let canvas = document.querySelector('#canvas-011');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 5;
        c.strokeStyle = 'red';
        c.lineDashOffset = 0;

        function draw(){
            c.clearRect(0, 0, canvas.width, canvas.height);
            
            c.beginPath();
            c.moveTo(50, 50);
            c.lineTo(200, 50);
            c.lineTo(200, 120);
            c.lineTo(50, 120);
            c.closePath();
            c.stroke();
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function march(){
            c.setLineDash([2,2]);
            c.lineDashOffset++;
            draw();
        }

        function animation(){
            if(isScrolledIntoView(canvas)){
                march();
            }
            requestAnimationFrame(animation);
        }

        animation();
    }
</script>

</article>

<hr>

<article id="ten">
    <header>
        <h1>Canvas globalAlpha property</h1>
    </header>

    <p>The <Span>globalAlpha</Span> property <Span>sets</Span>
    or <Span>returns</Span> the current <Span>transparency value</Span> of the 
<Span>drawing</Span>.</p>

<p>The <Span>globalAlpha property value</Span> must be a <Span>number</Span> 
between <Span>0.0</Span> (fully transparent) and <Span>1.0</Span> (no transparancy).</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-012');
let c = canvas.getContext('2d');

background(c);
c.fillStyle = 'red';

c.globalAlpha = 0.8;

c.fillRect(50, 50, 50, 50);

c.globalAlpha = 0.5;

c.fillRect(135, 50, 50, 50);

c.globalAlpha = 1;

c.fillRect(220, 50, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-012" class="canvas">
</canvas>

<Script>
    if(true){
        let canvas = document.getElementById('canvas-012');
        let c = canvas.getContext('2d');

        background(c);
        c.fillStyle = 'red';

        c.globalAlpha = 0.8;

        c.fillRect(50, 50, 50, 50);

        c.globalAlpha = 0.5;

        c.fillRect(135, 50, 50, 50);

        c.globalAlpha = 1;

        c.fillRect(220, 50, 50, 50);
    }
</Script>


</article>

<hr>

<article id ="eleven">
    <header>
        <h1>Using images</h1>
    </header>

<p>Until now we have created our own <Span>shapes</Span> and <Span>applied styles</Span>
to them. One of the more exciting feautures of <Span>canvas</Span> is the ability to use 
<Span>images</Span>. <span>External images</span> can be used in any format supported by the browser, 
such as <Span>PNG</Span>, <span>GIF</span>, or <Span>SJPEG</Span>. You can even use 
the <Span>image</Span> produced by other <Span>canvas elements</Span> on the same 
page as the <Span>source</Span>.</p>

<p><span>Importing images</span> into a <Span>canvas</Span> is basically a <Span>two step process</Span>:</p>

<div class="list_container" style="background-color: unset; border: unset;">
<ol>
    <li>Get a reference to an <Span>HTMLImageElement object</Span> or 
    <span>another canvas element</span> as a <Span>source</Span>. It is also possible to use <Span>images</Span> by 
prividing a <span>URL</span>.</li>
<li>Draw the <span>image</span> on the <Span>canvas</Span> using the <Span>drawImage()</Span> function.</li>
</ol>
</div>

<h2><u>Getting images to draw:</u></h2>

<p>The <Span>canvas API</Span> is able to use any of the following <span>data types</span> 
as an <Span>image source</Span>:</p>

<div class="list_container">
    <dl>
        <dt><Span>HTMLImageElement</Span></dt>
        <dd>These are images created using the Image() constructor, as well as any &lt;img> element.</dd>
        <dt><Span>SVGImageElement</Span></dt>
        <dd>These are images embedded using the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image">&lt;image></a> element of SVG.</dd>
        <dt><span>HTMLVideoElement</span></dt>
        <dd>Using an HTML &lt;video> element as your image source grabs the current frame from the video and uses it as an image.</dd>
        <dt><Span>HTMLCanvasElement</Span></dt>
        <dd>You can use another &lt;canvas> element as your image source.</dd>
    </dl>
</div>

<p>There are several ways to get <Span>images</Span> for use on a <Span>canvas</Span>.</p>

<h2><u>Using images from the same page:</u></h2>

<p>We can obtain a <Span>reference</Span> to <Span>images on the same page</Span> as 
the <Span>canvas</Span> by using one of the following methods:</p>

<div class="list_container">
    <ul>
        <li>The <span>document.images</span> collection</li>
        <li>The <Span>document.getElementsByTagName()</Span> method</li>
        <li>If you know the ID of the specific image you wish to use, you can 
            use <Span>document.getElementById()</Span> to retrieve that specific image.
        </li>
    </ul>
</div>

<p>I have already talked about <span>getElementsByTagName()</span> and 
<span>getElementsById()</span> methods before in my notes, I have never 
mentioned <Span>images</Span> property however, this property of the <span>Document object</span> returns a 
<Span>collection ot the images</Span> in the <Span>current HTML document</Span>. Let's try this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">console.dir(document.images);</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        console.dir(document.images);
    }
</script>

<img src="../images/ω1.JPG">

<p>Those <Span>image objects</Span> contain a lot of <Span>properties</Span> inside them, 
so you could use an <span>array method</span> such as <Span>filter</Span> to only get 
a specific <Span>image</Span>, if for example you want to check for their <Span>name</Span> 
you could use a <Span>regular expression</Span> and select it from the <span>outerHTML</span> property which contains 
a <Span>string</Span> of the <Span>outer HTML of the image</Span>.</p>

<h2><u>Using images from other domains:</u></h2>

<p>Using the <span>crossorigin attribute</span> of an <span>&lt;img></span> element (reflected by the 
<Span>HTMLImageElement.crossOrigin property</Span>), you can request permission to load 
an <Span>image</Span> from <span>another domain</span> for use in your call to <span>drawImage()</span>. If the hosting domain permits cross-domain access 
to the <Span>image</Span>, the <span>image</span> can be used in your <span>canvas</span> without tainting it, otherwise using the <Span>image</Span> will <Span>taint the canvas</Span>.</p>

<p>I have talked about the <Span>crossorigin attribute</Span> <a href="../HTML-Notes/HTML_Extra_1.html#one">here</a>, 
if you want to learn the different values you can use for this attribute check this out.</p>

<h2><u>Using other canvas elements:</u></h2>

<p>Just as with <Span>normal images</Span>, we can access other <Span>canvas elements</Span> using 
either <Span>document.getElementsByTagName()</Span> or <Span>document.getElementById()</Span>
method. Be sure you've drawn something to the <Span>source canvas</Span> before using it in your 
<Span>target canvas</Span>.</p>

<p>One of the more practical uses of this would be to use a <Span>second canvas element</Span>
as a <Span>thumbnail view</Span> of the <Span>other larger canvas</Span>.</p>

<h2><u>Creating an image from scratch:</u></h2>

<p>Another option is to create a new <span>HTMLImageElement</span> object in our script. To 
do this, you can use the convenient <Span>Image() constructor</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/example.png';

console.log(img);
console.dir(img);</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        let img = new Image();
        img.src = '../images/example.png';

        console.log(img);
        console.dir(img);
    }
</script>

<img src="../images/ω3.png">

<p>When this script gets executed, the <span>image</span> starts loading.</p>

<p>If you try to call <Span>drawImage()</Span> before the <Span>image has finished loading</Span>, it won't do anything (or in older browsers, may 
even throw an exception). So you need to be sure to use the <Span>load event</Span> so you don't try this before the <span>image</span> has loaded.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">var img = new Image();
img.src = ../images/example.png';
img.addEventListener('load', function(e){
    <Span class="gray">// execute drawImage statements here</Span>
});
</Span></p>

<p>This should work fine when working with only <Span>one image</Span>, what if you 
are using <Span>multiple images</Span> though? How do you make sure all of them have loaded?
One simple way would be to add all your <Span>images</Span> directly into your 
<span>HTML code</span> using <Span>&lt;image></Span> tag, you could put all of them 
inside a <Span>div</Span> and then <Span>hide it</Span> with <span>CSS</span>, after you do so 
you could simple use <Span>window.addEventListener('load', function(){})</Span>.</p>

<p>If you however want to create the <Span>images</Span> with <Span>JavaScript</Span>, a code like 
this should do the job:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let imgToLoad = 3, imgLoaded = 0;
        
function onImgLoad(){
    imgLoaded++;
    if(imgLoaded == imgToLoad){
        <Span class="gray">//execute draw image statements here</Span>
    }
}

img1 = new Image();
img1.src = ../images/example.png';

img2 = new Image();
img2.src = ../images/example2.png';

img3 = new Image();
img3.src = ../images/example3.png';

let arr = [img1, img2, img3];

arr.forEach((img) => {
    img.addEventListener('load', onImgLoad);
});</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        let imgToLoad = 3, imgLoaded = 0;
            
        function onImgLoad(){
            imgLoaded++;
            if(imgLoaded == imgToLoad){
                //execute draw image statements here
            }
        }

        img1 = new Image();
        img1.src = '../images/example.png';
        
        img2 = new Image();
        img2.src = '../images/example2.png';

        img3 = new Image();
        img3.src = '../images/example3.png';

        let arr = [img1, img2, img3];

        arr.forEach((img) => {
            img.addEventListener('load', onImgLoad);
        });
    }
</script>

<h2><u>Drawing images:</u></h2>

<p>Once we have a <Span>reference</Span> to our <span>source image object</span> 
we can use the <span>drawImage()</span> method to <Span>render it</Span> to the <span>canvas</span>. 
As we will see later the <span>drawImage()</span>  ethod is overloaded and has several variants. In it's most 
basic form it looks like this: <Span>drawImage(image, x, y)</Span> but it can take up to 
<Span>nine parameters</Span>, and the way the parameters work change depending on how many are used, we will 
go over all that here in this section.</p>

<p>Let's try to draw our first <Span>image</Span> now, using those 
<span>three first parameters</span> only:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/example.png';

let canvas = document.getElementById('canvas-013');
let c = canvas.getContext('2d');

img.addEventListener('load', (e) => {
    canvas.width = '600';
    canvas.height = '200';

    c.drawImage(img, 0, -115);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-013"></canvas>

<script>
    if(true){

        let img = new Image();
        img.src = '../images/example.png';

        let canvas = document.getElementById('canvas-013');
        let c = canvas.getContext('2d');

        img.addEventListener('load', (e) => {
            canvas.width = '600';
            canvas.height = '200';

            c.drawImage(img, 0, -115);
        });

    }
</script>

<p>The <Span>image</Span> was <Span>too big</Span> so I had to change the <Span>size of the canvas</Span> in order to 
fit it inside, wouldn't that be great if we could <Span>scale it?</Span>, well, we can! The 
<span>two next parameters</span> do just that:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/phoenix.png';

let canvas = document.getElementById('canvas-014');
let c = canvas.getContext('2d');

img.addEventListener('load', (e) => {
    c.drawImage(img, 40, 30, 200, 100);
    background(c);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-014"></canvas>

<script>
    if(true){

        let img = new Image();
        img.src = '../images/phoenix.png';

        let canvas = document.getElementById('canvas-014');
        let c = canvas.getContext('2d');

        img.addEventListener('load', (e) => {
            c.drawImage(img, 40, 30, 200, 100);
            background(c);
        });

    }
</script>

<p>So, now, if we add the next <Span>four parameters</Span> the <Span>drawImage()</Span> 
method will work different than expected, we would normally expect that those <Span>four new parameters</Span> 
would be the <Span>last four parameters</Span>, but they are not, if more than <Span>five parameters</Span> are added, 
then the order of the <span>parameters</span> changes a little, so, till now it was like this: 
<Span>(source, xPosition, yPosition, xScale, yScale)</Span>, if <Span>more parameters are added</Span> then 
it changes to be like this: <Span>(source, xSlice, ySlice, xSliceScale, ySliceScale, positionX, positionY, scaleX, scaleY)</Span>.</p>

<p>So, the <Span>first parameter</Span> and <Span>last four parameters</Span> are the same as before, 
but between them there are <Span>four new parameters</Span> added, those <Span>new parameters</Span> allow us 
to <Span>slice the image</Span>, so that we only use <Span>a part of the image</Span> inside of using the whole image, 
here is an example:</p>

<p>Let's use this image and use a <Span>loop</Span> to place <Span>grass tiles</Span> all over the 
<Span>canvas</Span>:</p>

<img src="../images/ω4.png" id="imageAA">

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let image = document.getElementById('imageAA');
let canvas = document.getElementById('canvas-015');
let c = canvas.getContext('2d');

image.addEventListener('load', (e) => {
    for(i = 0; i &lt;= 12; i++){
        for(j = 0; j &lt;= 6; j++){
            c.drawImage(image, 80, 40, 40, 50, i * 25, j * 25, 25, 25);
        }
    }
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-015"></canvas>

<script>
    if(true){
        let image = new Image();
        image.src = '../images/ω4.png';
        let canvas = document.getElementById('canvas-015');
        let c = canvas.getContext('2d');

        image.addEventListener('load', (e) => {
            for(i = 0; i <= 12; i++){
                for(j = 0; j <= 6; j++){
                    c.drawImage(image, 80, 40, 40, 50, i * 25, j * 25, 25, 25);
                }
            }
        });
    }
</script>

<p>Here is a video that may help you undersand <Span>imageDraw()</Span> method better:</p>
<iframe src="https://www.youtube.com/embed/jEUuM5bRAzw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Before I finish with this section I want to also talk about one more 
    property, the <Span>imageSmoothingEnabled = boolean</Span> property, whic is used to 
    control the use of <Span>image smoothing algorithms when scaling images</Span>. By default, it is <Span>true</Span>, meaning <Span>images</Span>
    will be <Span>smoothed when scaled</Span>. You can disable this future by setting the property to <Span>false</Span>:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-016');
let c = canvas.getContext('2d');

let img = new Image();
img.src = ../images/phoenix.png';

background(c);

img.addEventListener('load', (e) => {
    c.drawImage(img, 20, 40, 120, 80);
    c.imageSmoothingEnabled = false;
    c.drawImage(img, 160, 40, 120, 80);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-016"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-016');
        let c = canvas.getContext('2d');

        let img = new Image();
        img.src = '../images/phoenix.png';

        background(c);

        img.addEventListener('load', (e) => {
            c.drawImage(img, 20, 40, 120, 80);
            c.imageSmoothingEnabled = false;
            c.drawImage(img, 160, 40, 120, 80);
        })
    }
</script>

<h2><u>How to find the aspect ratio of an image:</u></h2>

<P>Let's now learn how to <Span>resize images</span> but <span>keep the original aspect ratio</span>, something useful 
if you want your <Span>images</span> to have good quality. First, in order to find the <Span>aspect ratio</span> we 
are gonna do <Span>img.naturalWidth / img.naturalHeight</span>, after we have the <Span>ratio</span> we can choose 
a <Span>width</span> for our <span>image</span> and in order to find what the <Span>height</span> should we we simple 
do <Span>width / aspect ratio</span>, what if we want to choose a <Span>height</span> and find what the <span>width</span> 
should be? By using a little bit of algebra, we can assume that <Span>width = height * ratio</Span>, lets try this on our 
<span>canvas</span> to see if that's true.</p>

<p></p>By the way, you may wonder what <span>naturalWidth</span> and <span>naturalHeight</span> are 
and how they are different to <Span>width</Span>, <Span>height</Span>, <Span>clientWidth</span> and <Span>clientHeight</span>, 
the <Span>width and height</Span> give us the <Span>value of the width and height attribute</Span>, the <Span>clientWidth and clientHeight</Span>
give us the <span>width and height of the element</span>, if for example we had <Span>changed it's size using CSS</Span> then 
this would give us <span>the exact width and height it takes on the page</span>, while lastly, <Span>naturalWidth and naturalHeight</Span>
give us the <span>original width and height of the image</span>.</p>


<p class="left">JavaScript Code:</p>
<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0001');
let c = canvas.getContext('2d');

let img = new Image();
img.src = ../images/phoenix.png';

background(c);
c.imageSmoothingEnabled = true;

img.addEventListener('load', (e) => {
    let aspectRatio = img.naturalWidth / img.naturalHeight;
    c.drawImage(img, 0, 0, 120, 120 / aspectRatio);
    c.drawImage(img, 120, 0, 100 * aspectRatio, 100)
});</span></p>
<p class="left">Outcome:</p>
<canvas class="canvas" id="canvas-0001"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-0001');
        let c = canvas.getContext('2d');

        let img = new Image();
        img.src = '../images/phoenix.png';

        background(c);
        c.imageSmoothingEnabled = true;

        img.addEventListener('load', (e) => {
            let aspectRatio = img.naturalWidth / img.naturalHeight;
            c.drawImage(img, 0, 0, 120, 120 / aspectRatio);
            c.drawImage(img, 120, 0, 100 * aspectRatio, 100)
        });
    }
</script>

</article>

<hr>

<article id="twelve">
    <header>
        <h1>Animating the Canvas</h1>
    </header>

    <p>In this section I'm gonna talk about ways you can <Span>animate</Span> 
    the <Span>canvas</Span>, there isn't really much to say, since we are gonna use 
simple <Span>JavaScript</Span> code to get the wanted result, there is however one <Span>method</Span> 
I want to talk about, the <Span>Window.requestAnimationFrame()</Span> method.</p>

<p>The <Span>window.requestAnimationFrame()</Span> method tells the browser that you wish to perform an 
<Span>animation</Span> and requests that the browser calls a <Span>specified function</Span> to <Span>update an animation before the next repaint</Span>. 
The <Span>method</Span> takes a <Span>callback</Span> as an <Span>argument</Span> to be <Span>invoked</Span> before the 
<Span>repaint</Span>.</p>

<p>Your <Span>callack routine</Span> must it self call <Span>requestAnimationFrame()</Span> again 
if you want to <Span>animate another frame</Span> at the next repaint. <Span>requestAnimationFrmae()</Span> is 1 shot.</p>

<p>So, why use the <span>requestAnimationFrame()</span> method if we can just use <Span>setInterval</Span>? That's because <Span>requestAnimationFrame</Span> produces 
<Span>higher quality animation</Span> completely <Span>eliminating flicker</Span> and <Span>shear</Span> that can happen 
when using <Span>setInterval</Span>, and it also <Span>reduce or completely remove frame skips</Span>.</p>

<p>Here is a simple example of <Span>requestAnimationFrame()</Span> method so that 
you can see it's syntax:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let container = document.getElementById('ctainer');

let i = 0;

function example(){
    i++
    if(i &lt;= 3){
        container.innerHTML += 'Hello World!';
        requestAnimationFrame(example);
    } else {
        return false;
    }
}

example();</Span></p>

<p class="left">Outcome:</p>

<p style="text-align: left;" id="ctainer"></p>

<script>
    if(true){

        let container = document.getElementById('ctainer');
       
        let i = 0;

        function example(){
            i++
            if(i <= 3){
                container.innerHTML += 'Hello World!';
                requestAnimationFrame(example);
            } else {
                return false;
            }
        }

        example();

    }
</script>

<p>Let's create an <Span>animation</Span> on the <Span>canvas</Span> now:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-017');
let c = canvas.getContext('2d');

c.fillStyle = 'black';
c.strokeStyle = 'blue';

let circle = function(x, y, r, dx, dy){
    this.x = x;
    this.y = y;
    this.r = r;
    this.dx = dx;
    this.dy = dy;
    this.draw = function draw(){
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.animate = function animate(){
        if(this.x > canvas.width - r || this.x - this.r < 0){
            this.dx = -this.dx;
        } if(this.y > canvas.height - r || this.y - this.r < 0){
            this.dy = -this.dy;
        }
        this.x += this.dx;
        this.y += this.dy;
        this.draw();
    }
}

let array = new Array();

for(let i = 1; i <= 100; i++){
    let r = 10;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 2) + r;
    let dx = (Math.random() - 0.5) * 2;
    let dy = (Math.random() - 0.5) * 2;
    array.push(new circle(x, y, r, dx, dy));
}

let animation = function(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    array.forEach((circle) => {
        circle.animate();
    })
    requestAnimationFrame(animation);
}

animation();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-017"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-017');
        let c = canvas.getContext('2d');

        c.fillStyle = 'black';
        c.strokeStyle = 'blue';

        let circle = function(x, y, r, dx, dy){
            this.x = x;
            this.y = y;
            this.r = r;
            this.dx = dx;
            this.dy = dy;
            this.draw = function draw(){
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.animate = function animate(){
                if(this.x > canvas.width - r || this.x - this.r < 0){
                    this.dx = -this.dx;
                } if(this.y > canvas.height - r || this.y - this.r < 0){
                    this.dy = -this.dy;
                }
                this.x += this.dx;
                this.y += this.dy;
                this.draw();
            }
        }
        
        let array = new Array();

        for(let i = 1; i <= 100; i++){
            let r = 10;
            let x = Math.random() * (canvas.width - r * 2) + r;
            let y = Math.random() * (canvas.height - r * 2) + r;
            let dx = (Math.random() - 0.5) * 2;
            let dy = (Math.random() - 0.5) * 2;
            array.push(new circle(x, y, r, dx, dy));
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            } 
        
        let animation = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                array.forEach((circle) => {
                    circle.animate();
                })
            }
            requestAnimationFrame(animation);
        }

        animation();
        
    }
</script>

<p>So, at first this may seem a little complicated, but it's more easy once you understand it, I created a 
    <Span>object constructor</Span> which has <span>five properties</span> inside, 
    the <Span>first two</Span> are used to set the <Span>x and y coordinates</Span>, 
    the <Span>third property</Span> sets the <Span>radius</Span> and the <Span>last two</Span> set 
    the <Span>speed of x and y</Span>, those will be added to the current <Span>x</Span>
    and <Span>y</Span> per every <Span>iteration</Span>, then I created a <Span>draw method</Span>, which simple 
    <Span>draws the circle on the canvas</Span> and then I created an <Span>animate method</Span> which 
    <Span>checks some conditions and updates x and y coordinates</Span>, then it <Span>draws the circles</Span> by executing 
    the <Span>draw method</Span> using the <Span>new coordinates</Span>. If the <Span>x</Span> reaches 
    the <Span>edge of the canvas</Span> I make it <Span>change direction</Span>, and when it 
    reaches the <Span>starting edge</Span> I make it <Span>change direction</Span> again, same goes for <Span>y</Span>.
</p>

<p>Alright, so far I have explained what the <span>methods</span> do, now let me explain what I did next, 
I used that <Span>constructor</Span> to create <Span>100 different circle objects</Span> inside an 
<Span>array</Span>, then I created a <Span>function</Span> that is <Span>executed again and again by requestAnimationFrame() method</Span>, 
this <span>function</span> in every single iteration <Span>clears the canvas</Span> and then
goes through <Span>every object in the array</Span>, and calls the 
<Span>animate()</Span> method, which checks the <Span>current x and y coordinates</Span>, and then <Span>updates them</Span> and 
<Span>draws the circles using them</Span>, each <Span>circle object</Span> has <Span>different coordinates and speed</Span>, and that was 
achieved using <span>Math.random()</span> when we created them before.</p>

<p>The <Span>x</Span> parameter is <Span>randomly generated</Span> by 
<Span>Math.random() * (canvas.width - r * 2) + r</Span>, why is that? That's 
because <Span>Math.random()</Span> returns a <Span>number between 0 and 1</Span>, if I <Span>multiply it by the canvas width</Span> then 
the <Span>x</Span> can be <Span>anywhere between 0 and the edge of the canvas</Span>, but since 
the <Span>circle</Span> has a <Span>radius</Span>, I want to make sure that no 
<Span>circle</Span> can <Span>spawn</Span> through the <Span>edges</Span> for both 
<span>left and right sides</span>, that's why I did <Span>canvas.height - r *2</Span>, which makes sure 
the <Span>circle</Span> will be able to only spawn between 0 and on a <Span>distance</Span> equal to it's 
<Span>full width</Span> before the <Span>right edge</Span>, then to make sure 
it will not spawn in the <Span>left edge</Span> we <Span>add r</Span>, that's also the 
reason the <Span>distance from the right side</Span> we specified before was <Span>multiplied by 2</Span>, 
because now, no matter where the <Span>circle</Span> spawns, it will not be inside the <span>edges</span>. 
A similar way was used to generate the <Span>y</Span> coordinate.</p>

<p>About the <Span>dx and dy values</Span> now, I did <Span>Math.random() - 0.5</Span> so that there 
is a <Span>50% chance to return a negative number</Span>, then I <span>multiplied by 2</span> in order to 
<Span>make it move faster</Span>.</p>

<p>Here is a video that helped me a lot, it goes through the process of creating the 
    project I made above, slower, and explains things very much clearer than I did:
</p>

<iframe  src="https://www.youtube.com/embed/yq2au9EfeRQ?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</article>

<hr>

<article id="thirteen">
    <header>
        <h1>Using event listeners with Canvas</h1>
    </header>

<p>Let's now try to create something more cool using <Span>event listeners</Span>, 
    there isn't really much to say about <Span>event listeners</Span>, because I have already talked 
    about them in previous pages, here is a nice project I created:
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">window.addEventListener('load', (e) => {
    var canvas = document.querySelector('#canvas-project1');
    var c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    var points = new Array();

<Span class="gray">    // function to be used for all touch events</Span>
    function getTouchOffset(e){
        points = [];
        let canvas_box = canvas.getBoundingClientRect();
        let coords = {
            x: canvas_box.left,
            y: canvas_box.top 
        }
        Array.from(e.touches).forEach((touch) =>{
            points.push({x: touch.clientX - coords.x, y: touch.clientY - coords.y});
        });
    }

<Span class="gray">    // touch events that update x and y points</Span>
    canvas.addEventListener('touchstart', (e) =>{     
        getTouchOffset(e);
    });

    canvas.addEventListener('touchmove', (e) =>{
        getTouchOffset(e);
    });

    canvas.addEventListener('touchend', (e) =>{
        getTouchOffset(e);
    });

<span class="gray">    // mouse events that update x and y points</span>
    canvas.addEventListener('mousemove', (e) =>{
        points = [];
        points.push({
            x: e.offsetX,
            y: e.offsetY
        });
    });

    canvas.addEventListener('mouseout', (e) =>{
        points = [{
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
        }]
    });

<Span class="gray">    // constructor that creates circles</Span>
    var circleMaker = function(x,y,r,dx,dy,cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.r2 = r;
        this.dx = dx;
        this.dy = dy;
        this.randomColor = cl;
        this.draw = function(){
            c.fillStyle = this.randomColor;
            c.beginPath()
            c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
            c.stroke();
            c.fill();
        }
        this.update = function(){

            let range = 30;
            let arr;

<Span class="gray">            // checks if any of the (x, y) coordinates inside the points array are inside the wanted range of the circle, 
            // the reason I am using an array for the points is so that multi-touches are supported for touchscreens</Span>
            arr = points.filter((point) => {
                if(point.x - this.x < range && point.x - this.x > -range){
                    if(point.y - this.y < range && point.y - this.y > -range){
                        return true;
                    }
                }        
            });

<Span class="gray">            // if the filter method above returned at least one item then it
            // increases the radius, else it decreases it</Span>
            if(arr.length == 0){
                if(this.r > this.r2){
                    this.r -= 1;
                }
            } else{
                if(this.r < 30){
                    this.r += 5;
                }
            }

<Span class="gray">            // checks if the circle has met or passed the edges of the canvas,
            // if it has passed the right edge then I make sure dx is converted to a negative number else if it 
            // is less than 0 I make sure it is a positive number, I didn't do it like in the tutorial because 
            // problems would occur while scaling the circles, since if it was scaled and surpassed the edge then 
            // it would get stuck, that would happen because with the code in the video it would multiple dx with - every time 
            // x was higher than the width of the canvas, if x was heigher than 100 pixels from the edge for example
            // (something that could happen due to fast scaling while near the edge) then dx would become -dx and would increase 
            // like 4 pixels for example but would still be higher than the width of the canvas so it would change back to dx and 
            // that would go on forever causing it get stuck there.</Span>
            if(this.x - this.r < 0){
                this.dx = Math.abs(this.dx);
            } else if(this.x + this.r > canvas.width){
                this.dx = (this.dx < 0)? this.dx: -this.dx;
            }

            if(this.y - this.r < 0){
                this.dy = Math.abs(this.dy);
            } else if(this.y + this.r > canvas.height){
                this.dy = (this.dy < 0)? this.dy: -this.dy;
            }

<span class="gray">            // updates x and y of the circle and then executes the draw method</span>
            this.x += this.dx;
            this.y += this.dy;
            this.draw();
        }
    }

    var circles = new Array();

    var clrs = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

<span class="gray">    // loop that creates circles using the constructor made earlier</span>
    for(let i = 1; i <= 400; i++){
        let r = Math.random() * 3 + 1;
        let x = Math.random() * 
        (canvas.width - r * 2) + r;
        let y = Math.random() * 
        (canvas.height - r * 2) + r;
        let dx = (Math.random() - 0.5) * 3;
        let dy = (Math.random() - 0.5) * 3;
        let cl = clrs[Math.floor(Math.random() * clrs.length)];
    circles.push(new circleMaker(x, y, r, dx, dy, cl));
    }

<span class="gray">    // function that executes again and again to animate the canvas</span>
    function animate(){
    c.clearRect(0,0,canvas.width,canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
    }

    animate();

});</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-project1" style="background-color: black; margin: auto; display: block; border: 3px solid black;"></canvas>

    <script>
        if(true){
        window.addEventListener('load', (e) => {
            var canvas = document.querySelector('#canvas-project1');
            var c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;
             
            var points = new Array();
            
            function getTouchOffset(e){
                points = [];
                let canvas_box = canvas.getBoundingClientRect();
                let coords = {
                    x: canvas_box.left,
                    y: canvas_box.top 
                }
                Array.from(e.touches).forEach((touch) =>{
                    points.push({x: touch.clientX - coords.x, y: touch.clientY - coords.y});
                });
            }

            canvas.addEventListener('touchstart', (e) =>{     
                getTouchOffset(e);
            });
            
            canvas.addEventListener('touchmove', (e) =>{
                getTouchOffset(e);
            });
            
            canvas.addEventListener('touchend', (e) =>{
                getTouchOffset(e);
            });
            
            canvas.addEventListener('mousemove', (e) =>{
                points = [];
                points.push({
                    x: e.offsetX,
                    y: e.offsetY
                });
            });
            
            canvas.addEventListener('mouseout', (e) =>{
                points = [{
                    x: Number.POSITIVE_INFINITY,
                    y: Number.POSITIVE_INFINITY
                }]
            });
            
            var circleMaker = function(x,y,r,dx,dy,cl){
                this.x = x;
                this.y = y;
                this.r = r;
                this.r2 = r;
                this.dx = dx;
                this.dy = dy;
                this.randomColor = cl;
                this.draw = function(){
                    c.fillStyle = this.randomColor;
                    c.beginPath()
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    
                    let range = 30;
                    let arr;
                 
                    arr = points.filter((point) => {
                        if(point.x - this.x < range && point.x - this.x > -range){
                            if(point.y - this.y < range && point.y - this.y > -range){
                                return true;
                            }
                        }        
                    });
                       
                    if(arr.length == 0){
                        if(this.r > this.r2){
                            this.r -= 1;
                        }
                    } else{
                        if(this.r < 30){
                            this.r += 5;
                        }
                    }
                    
                    if(this.x - this.r < 0){
                        this.dx = Math.abs(this.dx);
                    } else if(this.x + this.r > canvas.width){
                        this.dx = (this.dx < 0)? this.dx: -this.dx;
                    }
                       
                    if(this.y - this.r < 0){
                        this.dy = Math.abs(this.dy);
                    } else if(this.y + this.r > canvas.height){
                        this.dy = (this.dy < 0)? this.dy: -this.dy;
                    }
                             
                    this.x += this.dx;
                    this.y += this.dy;
                    this.draw();
                }
            }
            
            var circles = new Array();
            
            var clrs = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];
            
            for(let i = 1; i <= 400; i++){
                let r = Math.random() * 3 + 1;
                let x = Math.random() * 
                (canvas.width - r * 2) + r;
                let y = Math.random() * 
                (canvas.height - r * 2) + r;
                let dx = (Math.random() - 0.5) * 3;
                let dy = (Math.random() - 0.5) * 3;
                let cl = clrs[
                Math.floor(Math.random() * clrs.length)
                ];
            circles.push(new circleMaker(x, y, r, dx, dy, cl));
            }
            
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }        

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0,0,canvas.width,canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
            
            animate();
            
        });
        }
    </script>

<h2><u>Explanation of the code:</u></h2>

<p>Let me explain a little now, you already can see from the comments what each 
    part of the code basically does, but I will try to give a more organized explanation about what 
    happens behind the scenes here. First of all, the circles moving around 
    were made just like the ones I created in the previous section, I explained the code 
    there so I will not go into much details about this, I changed some stuff however, 
    I made the radius of the circles be defined randomly, by writing Math.random() * 3 + 1, this makes 
    so the radius of the circles is between 1 and 4 pixels. I also made a new property called color, and 
    made it pick a random color for each circle, it chooses a color from an array of colors randomly 
    something I did by writing Math.floor(Math.random() * clrs.length), Math.floor will take the result, and 
    if it's a float number such as 0.5 it will return 0, or if the number is 0.7 it will also return 0, if 
    it's 1.6 it will return 1, if it's 2.3 it will return 2, and so on.  
</p>

<p>So, every time you hover your mouse over the canvas or touch the canvas 
    an object with the current x and y positions is added to an array called points, the reason I want it 
    to be an array is because for touches multiple objects could be returned if multi-touches occur. For every 
    iteration of the animation, I made it so, for each circle, a filter method 
    is used on the points array, to check if any of the x and y positions of the objects 
    provided are withing a wanted range, if even one of the objects in the array pass the test, then 
    the object is added in a new array, then I check to see if that array has a length greater than 0 or not, 
    if it has a length of 0 then that means no object passed the test, in which case, I check if the circle is bigger 
    than it's default radius, and make it smaller if it is, else if an object was matched 
    this means the circle is within the wanted range of at least one of the touches so I check 
    if the circle is smaller than a maximum radius I want and if it is then I make it bigger. 
</p>

<p>Another thing I changed from the code I had written before is the 
    if else statements that determine when to change the dx and dy direction, before 
    I would simple multiple them with - to change their direction, but now that the circles 
    can be scaled, if their radius changed while being near the edges a problem could occur due 
    to the circle surpassing the edge by more than 1 pixel, in which case the dx or dy would keep being 
    multipled by - in every single iteration, making the circle get stuck there. The Math.abs() method 
    converts a negative number to a positive one, to convert dx to a negative number I first made it check if 
    it already is a negative number, in which case I want it to let it be, and if it is not I 
    multiply it with - to make it one.
</p>

<h2><u>Tutorial that helped me:</u></h2>

<p>I used this tutorial to make this project, however, a large part of my code was 
    changed, and I believe improved, mine also supports multi touches and I also fixed some 
    problems with the code in the video.
</p>

<iframe src="https://www.youtube.com/embed/vxljFhP2krI?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</article>

<hr>

<article id="fourteen">
    <header>
        <h1>Creating gravity effect on Canvas</h1>
    </header>

    <p>In this section we will try to create the <Span>effect of gravirty</Span>, before we do 
    this, we need to understand what are the basic elements that create the <Span>effect</Span>. 
When an object <Span>falls</Span>, it starts with a <span>small speed</span> and <span>increases</span>, till 
it <Span>reaches the ground</Span>, then, if it's a small ball you would expect it to 
bounce back up towards the sky and fall again, however, as it  goes up it should <Span>decrease speed</Span>, so 
that it stops at some point and then <span>increase speed</span> again, towards the ground however.</s></p>

<p>Creating this <Span>speed change</Span> is pretty easy actually, let's try this out:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-018');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        if(this.y + this.r > canvas.height){
            this.dy = -this.dy;
        } else{
            this.dy += 1;
        }

        this.y += this.dy;
        this.draw();

        let p = document.getElementById('somethings');
        p.innerHTML = this.dy;
    }
}

let circles = new Array();
let colors = ['red', 'blue', 'green', 'yellow'];

for(let i = 1; i<= 1; i++){
    let r = Math.random() * 3 + 20;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];

    circles.push(new circleMaker(200, 50, r, 1, 1, clr));
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-018" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <p id="somethings"></p>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-018');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    if(this.y + this.r > canvas.height){
                        this.dy = -this.dy;
                    } else{
                        this.dy += 1;
                    }

                    this.y += this.dy;
                    this.draw();

                    let p = document.getElementById('somethings');
                    p.innerHTML = this.dy;
                }
            }

            let circles = new Array();
            let colors = ['red', 'blue', 'green', 'yellow'];

            for(let i = 1; i<= 1; i++){
                let r = Math.random() * 3 + 20;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];

                circles.push(new circleMaker(200, 50, r, 1, 1, clr));
            }

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }        

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p>So, the code may seem a little big, but it's actually the same 
    peace of code I used for the project in the <span>previous sections</span>, what I want 
    you to pay attention at is the <Span>update method</span>, I have made it so when 
    it <span>reaches the edge of the canvas</span> the <Span>dy</Span> is <Span>reversed</Span>, 
    if it <span>hasn't reached the edge</span> then it <Span>adds 1 to dy</Span>, to help you understand 
    what this little trick does I made a <Span>paragraph</Span> in which I 
    <Span>insert the dy</Span> in every <Span>iteration</Span>, it starts with a <Span>dy</Span> of 
    <span>1</span> and <Span>increases</Span>, till it <Span>reaches the bottom of the canvas</Span>, then 
    it's <span>direction is reversed</span>, so now, for <Span>each iteration</Span> we 
    <Span>add 1 to dy</Span>, which is currently a <span>negative number</span>, so we <Span>dicrease the speed</Span>, 
    till it reaches <Span>0</Span>, then the <span>direction changes towards the bottom again</span>, and 
    the <span>speed increases again</span>.
</p>

<p>This is good and all, but there is something missing, every time the 
    <Span>ball hits the ground</Span>, some of it's <span>energy</span> should 
    <Span>decrease</Span>, so at some point, the ball <Span>stays still</Span>. 
    Let's try doing that now:
</p>


<Style>
    .orange{
        background-color: lightcoral;
        font-weight: bold;
    }
</style>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">if(true){
let canvas = document.getElementById('canvas-019');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        let gravity = 1;
        let finished = false;

<Span class="orange">        if(this.y + this.r > canvas.height){
            this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
            if(this.dy > -5){
                this.dy = 0;
                finished = true;
            }
        } else{
            this.dy += gravity;
        }</span>

<Span class="orange">        if(finished == true){
            this.y = canvas.height - this.r + 0.1;
        } else{
            this.y += this.dy;
        }</span>

        this.draw();

        let p = document.getElementById('somethings2');
        p.innerHTML = this.dy;
    }
}

let circles = new Array();
let colors = ['red', 'blue', 'green', 'yellow'];

function createCircles(){
    circles = [];
    for(let i = 1; i<= 1; i++){
    let r = Math.random() * 3 + 20;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];

    circles.push(new circleMaker(x, y, r, 1, 1, clr));
    }
}

createCircles();

<Span class="orange">canvas.addEventListener('click', (e) => {
    createCircles();
});</span>

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>


<canvas id="canvas-019" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <p id="somethings2"></p>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-019');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    let gravity = 1;
                    let finished = false;

                    if(this.y + this.r > canvas.height){
                        this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
                        if(this.dy > -5){
                            this.dy = 0;
                            finished = true;
                        }
                    } else{
                        this.dy += gravity;
                    }

                    if(finished == true){
                        this.y = canvas.height - this.r + 0.1;
                    } else{
                        this.y += this.dy;
                    }

                    this.draw();

                    let p = document.getElementById('somethings2');
                    p.innerHTML = this.dy;
                }
            }

            let circles = new Array();
            let colors = ['red', 'blue', 'green', 'yellow'];

            function createCircles(){
                circles = [];
                for(let i = 1; i<= 1; i++){
                let r = Math.random() * 3 + 20;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];

                circles.push(new circleMaker(x, y, r, 1, 1, clr));
                }
            }

            createCircles();

            canvas.addEventListener('click', (e) => {
                createCircles();
            });

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }            

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p><Span>Click</Span> on the <Span>canvas</Span> to make the <span>animation restart</span>, now, let me explain what 
the code does, every time the <Span>ball hits the ground</Span>, it checks if the <span>dy is negative</span>, and if it is, 
then it <Span>lets it be</Span>, else it <Span>multiples it with - to make it negative</Span>, I made this that way to 
prevent some bugs that could occur due the <Span>dy</Span> becoming a <Span>float number</Span>, since it sometimes 
would <span></span>move the ball beyond the edge</span> and a bug would occur. Anyway, <Span>each time the ball hits the ground</Span> I 
<Span>multiply dy</Span> with <Span>0.95</Span> which makes it <Span>decrease</Span>, since when it got 
<span>very low</span> it would create an ugly effect of a trembling ball, I made it so 
if it <Span>hits the ground</Span> and it's <Span>reversed speed</Span> is <Span>lower than 5</Span> it 
just changes directly to <Span>0</Span>. Now, because the <span>ball</span> would some times 
stop <span>a little under the edge</span> I created a <Span>variable named finished</Span>, which I change to 
<Span>true</Span> when the <Span>ball's speed has reached 0</Span> and I made it so <Span>y becomes canvas.height - this.r + 0.1</Span>, 
why the <Span>+ 0.1</Span> you may wonder now, well, that's so the <span>cirlce</span> is 
<Span>barely past the edge</Span>, so that the <span>this.dy += gravity</span> is not executed in the 
<Span>next iterations</Span>.</p>

<p>Lets add some more circles now, add <span>dx</span> and also 
    change the <Span>colors</Span> to finish with this project:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-020');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        let gravity = 1;
        let finished = false;

        if(this.y + this.r > canvas.height){
            this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
            if(this.dy > -5){
                this.dy = 0;
                finished = true;
            }
        } else{
            this.dy += gravity;
        }

        if(this.x + this.r > canvas.width){
            this.dx = ((this.dx < 0)? this.dx: -this.dx) * 0.7;
        } else if(this.x - this.r < 0){
            this.dx = Math.abs(this.dx) * 0.7;
        } else {
            this.dx = (this.dx < 0)? this.dx + 0.001: this.dx - 0.001;
        }

        if(finished == true){
            this.y = canvas.height - this.r + 0.1;
        } else{
            this.y += this.dy;
        }

        this.x += this.dx;

        this.draw();
    }
}

let circles = new Array();
let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

function createCircles(){
    circles = [];
    for(let i = 1; i<= 100; i++){
    let r = Math.random() * 5 + 15;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];
    let dx = (Math.random() - 0.5) * 5;
    circles.push(new circleMaker(x, y, r, dx, 1, clr));
    }
}

createCircles();

canvas.addEventListener('click', (e) => {
    createCircles();
});

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-020" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <script>
        if(true){
            let canvas = document.getElementById('canvas-020');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    let gravity = 0.4;
                    let finished = false;

                    if(this.y + this.r > canvas.height){
                        this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
                        if(this.dy > -5){
                            this.dy = 0;
                            finished = true;
                        }
                    } else{
                        this.dy += gravity;
                    }

                    if(this.x + this.r > canvas.width){
                        this.dx = ((this.dx < 0)? this.dx: -this.dx) * 0.7;
                    } else if(this.x - this.r < 0){
                        this.dx = Math.abs(this.dx) * 0.7;
                    } else {
                        this.dx = (this.dx < 0)? this.dx + 0.001: this.dx - 0.001;
                    }

                    if(finished == true){
                        this.y = canvas.height - this.r + 0.1;
                    } else{
                        this.y += this.dy;
                    }

                    this.x += this.dx;

                    this.draw();
                }
            }

            let circles = new Array();
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            function createCircles(){
                circles = [];
                for(let i = 1; i<= 100; i++){
                let r = Math.random() * 5 + 15;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];
                let dx = (Math.random() - 0.5) * 5;
                circles.push(new circleMaker(x, y, r, dx, 1, clr));
                }
            }

            createCircles();

            canvas.addEventListener('click', (e) => {
                createCircles();
            });

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }            

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p>This tutorial below helped me a lot with that project, however, my version is a bit different than the one 
    in the video, I have fixed some bugs and made it a little better, still the video is great since the guy goes through 
    the steps of creating the project and explains things better than I did, so check this out if you want:
</p>

<iframe src="https://www.youtube.com/embed/3b7FyIxWW94?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="fifteen">
    <header>
        <h1>Collision Detection</h1>
    </header>

<p>Determining when <Span>two objects touch</Span>, or when <Span>your mouse touches an object</Span> allows 
you to create some really cool stuff, that's why in this section, I will teach you how to 
<span>etect collision</span>.</p>

<p>To do so, we are gonna use the famous <Span>Pythagorean theorem</Span>, 
which allows us to find the <span>hypotenuse</span> of a <Span>triangle</Span>. The 
formula is <Span>√x^2 + y^2</Span>, however, in code it's faster for us to use the 
<span>Math.hypot(x, y)</span> method. Now, to get the <span>x, y</span> coordinates of a 
<Span>vector</Span> we need to know it's <Span>starting points</Span> and <span>end points</span>, then to get 
the <Span>Vx</Span> we can get it by doing <Span>x2 - x1</Span> and to get <Span>Vy</Span> we can get 
it by doing <Span>y2 - y1</Span>, I have also talked about that stuff, as well as how to get the <Span>angle</span> formed by 
the <Span>vector</span> in my <Span>Math notes</span>.</p>

<p>For now, let's try to make a simple <Span>collision</Span> border-image-width
<span>two circles</span>, one <Span>moving with our corsure</span>, when the <Span>two cicles touch</span> 
I will make it so the <Span>big static circle changes color</Span>:</p>


<style>
    .canvases{
        display: block;
        margin: auto;
        border: 3px solid black;
    }
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-001');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

function circleMaker(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        this.draw();
    }
}

let circle1 = new circleMaker(canvas.width/2, canvas.height/2, 50, 'black');  
let circle2 = new circleMaker(undefined, undefined, 20, 'red');

let cursorCoords = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    cursorCoords.x = e.offsetX;
    cursorCoords.y = e.offsetY;
});

canvas.addEventListener('touchstart', (e) => {
    let box = canvas.getBoundingClientRect();
    cursorCoords.x = box.left - e.touches[0].clientX;
    cursorCoords.y = box.top - e.touches[0].clientY;
});

canvas.addEventListener('touchmove', (e) => {
    let box = canvas.getBoundingClientRect();
    cursorCoords.x = box.left - e.touches[0].clientX;
    cursorCoords.y = box.top - e.touches[0].clientY;
});

function getDistance(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    [circle2.x, circle2.y] = [cursorCoords.x, cursorCoords.y];
    let distance = getDistance(circle2.x, circle2.y, circle1.x, circle1.y);
    if(distance < circle1.r + circle2.r){
        circle1.cl = 'red';
    } else { circle1.cl = 'black'; }
    circle1.update();
    circle2.update();
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvases" id="canvas-001"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-001');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 300;

        function circleMaker(x, y, r, cl){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.update = function(){
                this.draw();
            }
        }

        let circle1 = new circleMaker(canvas.width/2, canvas.height/2, 50, 'black');         
        let circle2 = new circleMaker(undefined, undefined, 20, 'red');
        
        let cursorCoords = {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
        }

        canvas.addEventListener('mousemove', (e) => {
            cursorCoords.x = e.offsetX;
            cursorCoords.y = e.offsetY;
        });

        canvas.addEventListener('touchstart', (e) => {
            let box = canvas.getBoundingClientRect();
            cursorCoords.x = box.left - e.touches[0].clientX;
            cursorCoords.y = box.top - e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            let box = canvas.getBoundingClientRect();
            cursorCoords.x = box.left - e.touches[0].clientX;
            cursorCoords.y = box.top - e.touches[0].clientY;
        });

        function getDistance(x1, y1, x2, y2){
            let Vx = x2 - x1;
            let Vy = y2 - y1;
            return Math.hypot(Vx, Vy);
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function animate(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                [circle2.x, circle2.y] = [cursorCoords.x, cursorCoords.y];
                let distance = getDistance(circle2.x, circle2.y, circle1.x, circle1.y);
                if(distance < circle1.r + circle2.r){
                    circle1.cl = 'red';
                } else { circle1.cl = 'black'; }
                circle1.update();
                circle2.update();
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<P>Here is a video that can help you understand the code above better:</p>

<iframe src="https://www.youtube.com/embed/XYzA_kPWyJ8?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<P>So, for my next code, I am gonna use some <span>math</span> and 
<Span>physics</span> to create <Span>realistic collisions</span>. In order 
to better understand this, I recommend you also check my <a href="../Math-and-Physics-Notes/math1.html#two">physics notes</a>, 
where I explained the <Span>physics of the code</Span> in more details. Anyway, here is the project:</P>

<p>First thing we need to do, is to make sure <Span>particles cannot spawn inside each other</Span>, to do so, 
we are gonna use this code:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-030');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let getDistance = function(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

let particle = function(x, y, r, cl, velocities, mass){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl; 
    this.velocity = velocities
    this.m = mass;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
    }
    this.update = function(){
        this.draw();
    }
}

let particles = new Array();

function int(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 15;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = 'red';

        if(i !== 0){
            for(let j = 0; j < particles.length; j++){
                let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    x = Math.random() * (canvas.width - r * 2) + r;
                    y = Math.random() * (canvas.height - r * 2) + r;
                    j = -1;
                }
            }
        }    

        particles.push(new particle(x, y, r, cl));
    }
}

int();

canvas.addEventListener('click', (e) => {
    int();
});

function animate(){
    c.fillStyle = 'black';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((x) => {
        x.update();
    });
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome</span>

<canvas id="canvas-030" style="display: block; margin: auto; border: 3px solid black;">

<script>
    if(true){
        let canvas = document.getElementById('canvas-030');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 300;

        let getDistance = function(x1, y1, x2, y2){
            let Vx = x2 - x1;
            let Vy = y2 - y1;
            return Math.hypot(Vx, Vy);
        }

        let particle = function(x, y, r, cl, velocities, mass){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl; 
            this.velocity = velocities
            this.m = mass;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.fill();
                c.stroke();
            }
            this.update = function(){
                this.draw();
            }
        }

        let particles = new Array();

        function int(){
            particles = [];
            for(let i = 0; i < 50; i++){
                let r = 15;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 2) + r;
                let cl = 'red';

                if(i !== 0){
                    for(let j = 0; j < particles.length; j++){
                        let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                        if(distance < 0){
                            x = Math.random() * (canvas.width - r * 2) + r;
                            y = Math.random() * (canvas.height - r * 2) + r;
                            j = -1;
                        }
                    }
                }    

                particles.push(new particle(x, y, r, cl));
            }
        }

        int();

        canvas.addEventListener('click', (e) => {
            int();
        });

        function animate(){
            c.fillStyle = 'black';
            c.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach((x) => {
                x.update();
            });
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>Check the code inside the <Span>int function</span>, <Span>after the first particle is created</span>, 
<Span>all the other particles I create</Span> will <Span>check their distance with all the previous particles created</span>, 
I made sure that the <Span>first particle will not be checked</span> since there would be 
<Span>no other particles to compare with</span>, if the <Span>distance with at least one of the other particles is less than 0</Span>
then I <span>redefine x and y</span> and <Span>change j to -1</span> which at the <Span>end of the iteration</span> will
<Span>become 0</Span>, so what basically happens is that the <span>whole loop is redone</span> and the <Span>distance with the new coordinates is calculated</span> 
this will happen again and again till <Span>coordinates</span> that <span>don't overlap any other particles</span> are found. Be aware, that if the <Span>particles are too big</span> 
and <span>there is no space for all to fit</span> then the <span>page will crash being unable to find coordinates that don't overlap</span>, so try different sizes or 
reduce the number of particles 
to make sure all particles can fit.</p>

<p class="left">JavaScript:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-031');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let getDistance = function(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

let rotate = function(velocity, angle){
    let rotatedVelocities = {
        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
    }
    return rotatedVelocities;
}

let particle = function(x, y, r, cl, velocities, mass){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl; 
    this.velocity = velocities;
    this.m = mass;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
    }
    this.changeVelocities = function(thisParticle, otherParticle){
        let [x1, y1, v1, m1] = [thisParticle.x, thisParticle.y, thisParticle.velocity, thisParticle.m];
        let [x2, y2, v2, m2] = [otherParticle.x, otherParticle.y, otherParticle.velocity, otherParticle.m];

        let xVelocityDiff = v1.x - v2.x;
        let yVelocityDff = v1.y - v2.y;

        let xDist = x2- x1;
        let yDist = y2 - y1;

        if(xVelocityDiff * xDist + yVelocityDff * yDist >= 0){
            let angle = -Math.atan2(y2 - y1, x2 - x1);

            let rotatedV1 = rotate(v1, angle);
            let rotatedV2 = rotate(v2, angle);

            let rotatedV1final = {x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2), y: rotatedV1.y};
            let rotatedV2final = {x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2), y: rotatedV2.y};

            let finalV1 = rotate(rotatedV1final, -angle);
            let finalV2 = rotate(rotatedV2final, - angle);

            thisParticle.velocity = finalV1; 
            otherParticle.velocity = finalV2;
        }
    }
    this.update = function(particles){
        if(this.x + this.r > canvas.width){
            this.velocity.x = (this.velocity.x < 0)? this.velocity.x: -this.velocity.x;
        } else if(this.x - this.r < 0){
            this.velocity.x = Math.abs(this.velocity.x);
        }

        if(this.y + this.r > canvas.height){
            this.velocity.y = (this.velocity.y < 0)? this.velocity.y: -this.velocity.y;
        } else if(this.y - this.r < 0){
            this.velocity.y = Math.abs(this.velocity.y);
        }

        for(let j = 0; j < particles.length; j++){
            if(this == particles[j]){
                continue;
            } else {
                let distance = getDistance(this.x, this.y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    this.changeVelocities(this, particles[j]);
                }
            }
        }

        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.draw();
    }
}

let particles = new Array();

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

function int(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 15;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        let dx = (Math.random() - 0.5) * 3;
        let dy = (Math.random() - 0.5) * 3;

        if(i !== 0){
            for(let j = 0; j < particles.length; j++){
                let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    x = Math.random() * (canvas.width - r * 2) + r;
                    y = Math.random() * (canvas.height - r * 2) + r;
                    j = -1;
                }
            }
        }    

        particles.push(new particle(x, y, r, cl, {x: dx, y: dy}, 1));
    }
}

int();

canvas.addEventListener('click', (e) => {
    int();
});

function animate(){
    c.fillStyle = 'black';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((x) => {
        x.update(particles);
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-031" style="display: block; margin: auto; border: 3px solid black;"></canvas>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-031');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
    
            let getDistance = function(x1, y1, x2, y2){
                let Vx = x2 - x1;
                let Vy = y2 - y1;
                return Math.hypot(Vx, Vy);
            }

            let rotate = function(velocity, angle){
                let rotatedVelocities = {
                    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
                }
                return rotatedVelocities;
            }
    
            let particle = function(x, y, r, cl, velocities, mass){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl; 
                this.velocity = velocities;
                this.m = mass;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.fill();
                    c.stroke();
                }
                this.changeVelocities = function(thisParticle, otherParticle){
                    let [x1, y1, v1, m1] = [thisParticle.x, thisParticle.y, thisParticle.velocity, thisParticle.m];
                    let [x2, y2, v2, m2] = [otherParticle.x, otherParticle.y, otherParticle.velocity, otherParticle.m];
                    
                    let xVelocityDiff = v1.x - v2.x;
                    let yVelocityDff = v1.y - v2.y;

                    let xDist = x2- x1;
                    let yDist = y2 - y1;

                    if(xVelocityDiff * xDist + yVelocityDff * yDist >= 0){
                        let angle = -Math.atan2(y2 - y1, x2 - x1);

                        let rotatedV1 = rotate(v1, angle);
                        let rotatedV2 = rotate(v2, angle);

                        let rotatedV1final = {x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2), y: rotatedV1.y};
                        let rotatedV2final = {x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2), y: rotatedV2.y};

                        let finalV1 = rotate(rotatedV1final, -angle);
                        let finalV2 = rotate(rotatedV2final, - angle);

                        thisParticle.velocity = finalV1; 
                        otherParticle.velocity = finalV2;
                    }
                }
                this.update = function(particles){
                    if(this.x + this.r > canvas.width){
                        this.velocity.x = (this.velocity.x < 0)? this.velocity.x: -this.velocity.x;
                    } else if(this.x - this.r < 0){
                        this.velocity.x = Math.abs(this.velocity.x);
                    }

                    if(this.y + this.r > canvas.height){
                        this.velocity.y = (this.velocity.y < 0)? this.velocity.y: -this.velocity.y;
                    } else if(this.y - this.r < 0){
                        this.velocity.y = Math.abs(this.velocity.y);
                    }

                    for(let j = 0; j < particles.length; j++){
                        if(this == particles[j]){
                            continue;
                        } else {
                            let distance = getDistance(this.x, this.y, particles[j].x, particles[j].y) - r * 2;
                            if(distance < 0){
                                this.changeVelocities(this, particles[j]);
                            }
                        }
                    }

                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.draw();
                }
            }
    
            let particles = new Array();
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            function int(){
                particles = [];
                for(let i = 0; i < 50; i++){
                    let r = 15;
                    let x = Math.random() * (canvas.width - r * 2) + r;
                    let y = Math.random() * (canvas.height - r * 2) + r;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    let dx = (Math.random() - 0.5) * 3;
                    let dy = (Math.random() - 0.5) * 3;
    
                    if(i !== 0){
                        for(let j = 0; j < particles.length; j++){
                            let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                            if(distance < 0){
                                x = Math.random() * (canvas.width - r * 2) + r;
                                y = Math.random() * (canvas.height - r * 2) + r;
                                j = -1;
                            }
                        }
                    }    
    
                    particles.push(new particle(x, y, r, cl, {x: dx, y: dy}, 1));
                }
            }
    
            int();
    
            canvas.addEventListener('click', (e) => {
                int();
            });
    
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'black';
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((x) => {
                        x.update(particles);
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>I did basically the same thing I did before while defining the <span>x and y coordinates</span> to 
<Span>check for collisions</span>, so there isn't much to explain, the hardest part to understand of this code 
is the <span>changeVelocities() function</span>, but I explain this <Span>function</span> 
in my <a href="../Math-and-Physics-Notes/math1.html#two">physics notes</a>. Here is a video if you need more help with the code:</p>

<iframe src="https://www.youtube.com/embed/789weryntzM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
 
</article>

<hr>

<article id="sixteen">
    <header>
        <h1>Circular Motion</h1>
    </header>

    <p>So, in order to code <Span>circular motion</Span>, we are gonna 
    need some basic knowledge of what <Span>radians</Span>, <Span>cos</Span> and 
<Span>sin</Span> are.</p>

<p><Span>Radians</Span> are used to measure <Span>angles</Span>, to 
conver <Span>degrees</Span> to <Span>radians</Span> you can multiple the <Span>degrees</Span> 
by <Span>π/180</Span>. <br><br><span>Half a circle</span> is <span>180 degrees</span>, which 
equals to <span>3.1416... radians</span>, or else <Span>π radians</Span>, a 
<Span>full circle</Span> would be <Span>2π radians</Span>.</p>

<p>The reason we are learning about <Span>radians</Span> is because the <Span>methods</Span> we 
are gonna use take <Span>radians</Span> are their <Span>parameter</Span>, those <span>methods</span> will be 
<Span>Math.cos()</Span> and <Span>Math.sin()</Span>, so what is <Span>cos</Span> and what is <span>sin</span>?
Take a look at this picture:</p>

<img src="../images/ω5.png">

<p>So, for a given <span>angle</span>, like <span>65 degrees</span> for example, we can form a <span>triangle</span>, 
the <Span>sin</Span> of a <Span>triangle</Span> is equal to <Span>opposite side / hypotenuse</Span> and 
the <Span>cos</Span> is equal to <span>adjacent side / hypotenuse</span>. Because of that, at <Span>90 degrees</span>, since the <Span>adjacent side</Span> 
of the <Span>triangle</Span> will be <span>zero</span>, <Span>cos will be zero</Span>, while <span>sin</span> will be 
equal to <Span>1</Span> since <span>opposite side</span> and <Span>hypotenuse</Span> will be equal. </p>

<img src="../images/ω6.png">

<p>Anyway, what we gotta understand from this basically is that
by doing <Span>circle's X position + Math.cos(radians) * radius</Span> we get the exact <Span>x position</span>
of the the <Span>angle</span>. If we created an <span>arc</span> at <Span>200 pixels x</Span> with a <Span>radius of 50 pixels</Span> and 
we then put our finger at the 
edge of the circle and draged it around the circle <Span>90 degrees</Span>, 
that would be <Span>π/2 radians</Span>, so if we wanted to find the exact <span>x position our finger is on</span> we could 
do <Span>200 + Math.cos(π/2) * 50</Span>, to find the <span>y position our finger is on</span> we simple would 
do the same but use <Span>Math.sin()</Span> instead, so we would do <span>200 + Math.sin(π/2) * 50</span>.</p>

<p>If in an <Span>animation</span>, we <Span>continuously increased the radians</Span>, it would be as if we were 
<Span>rotating around a circle again and again</Span>, if we used <Span>sin</Span> for <Span>y</Span> and <Span>cos</Span> for 
<Span>x</Span> positions of our <span>particle</span>, then a <Span>circual movement would be made</Span>, a 
small one though since <Span>sin</span> and <Span>cos</span> return numbers between <Span>-1 and 1</span>, anyway, let's test this out:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-021');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 200;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.005;
    this.radians = 0;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){

        this.radians += this.velocity;

        this.x = Math.cos(this.radians);
        this.y = Math.sin(this.radians);

        let p = document.getElementById('smthinga');
        p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
        this.draw();
    }
}

let particles = new Array();

for(let i = 1; i <= 1; i++){
    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-021"></canvas>
<p id="smthinga"></p>

<script>
    if(true){
        let canvas = document.getElementById('canvas-021');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 200;
        
        let createParticle = function(x, y, r, cl){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl;
            this.velocity = 0.005;
            this.radians = 0;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.update = function(){

                this.radians += this.velocity;

                this.x = Math.cos(this.radians);
                this.y = Math.sin(this.radians);

                let p = document.getElementById('smthinga');
                p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
                this.draw();
            }
        }

        let particles = new Array();

        for(let i = 1; i <= 1; i++){
            particles = [];
            particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function animate(){
            if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle) => {
                particle.update();
            });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>The <Span>code above</Span> already creates a <Span>circular motion</span>, its just way too small 
to notice easily, but the <Span>circle</Span> does move, the <span>radians</span> are <Span>increasing</Span> per each 
iteration, therefore, the <Span>sin</span> and <Span>cos</span> are changing too, if we add 
these for our <span>x, y</span> positions we should get a <Span>circular movement</Span>, however, there are two issues we gotta 
fix in order to make this visible, first, we gotta <spa>move the center of our circle</spa>, to our 
<span>original x, y positions</span>, then, we will <Span>increase the range of the rotation</Span>, since at the moment it's rotation is of 
a range between -1 and 1, if we wanted it to <Span>rotate</span> on a 
<Span>distance of 50 pixels from the center</span> then we could <span>multiple sin and cos by 50</span>, let's try this:</P>


<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">this.x = x + Math.cos(this.radians) * 50;
this.y = y + Math.sin(this.radians) * 50;</Span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-022"></canvas>
    <p id="smthinga2"></p>
    
    <script>
        if(true){
            let canvas = document.getElementById('canvas-022');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 200;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = 0;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
    
                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * 50;
                    this.y = y + Math.sin(this.radians) * 50;
    
                    let p = document.getElementById('smthinga2');
                    p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
                    this.draw();
                }
            }
    
            let particles = new Array();
    
            for(let i = 1; i <= 1; i++){
                particles = [];
                particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
            }
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 
            function animate(){
                if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach((particle) => {
                    particle.update();
                });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>Alright, now, let's add <Span>multiple particles</Span>, and 
    <Span>give them a random starting radians angle</Span>, as well as 
    a <Span>random distance from center</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-024');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    <Span class="orange">this.radians = Math.random() * Math.PI * 2;</span>
    <Span class="orange">this.distance = Math.random() * 50 + 50;</span>
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){

        this.radians += this.velocity;

        <Span class="orange">this.x = x + Math.cos(this.radians) * this.distance;</span>
        <Span class="orange">this.y = y + Math.sin(this.radians) * this.distance;</span>

        this.draw();
    }
}

let particles = new Array();

<Span class="orange">function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
    }
}

int();</span>

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

        <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-024"></canvas>
        
        <script>
            if(true){
                let canvas = document.getElementById('canvas-024');
                let c = canvas.getContext('2d');
        
                canvas.width = 500;
                canvas.height = 300;
                
                let createParticle = function(x, y, r, cl){
                    this.x = x;
                    this.y = y; 
                    this.r = r;
                    this.cl = cl;
                    this.velocity = 0.05;
                    this.radians = Math.random() * Math.PI * 2;
                    this.distance = Math.random() * 50 + 50;
                    this.draw = function(){
                        c.fillStyle = this.cl;
                        c.beginPath();
                        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                        c.stroke();
                        c.fill();
                    }
                    this.update = function(){
        
                        this.radians += this.velocity;
        
                        this.x = x + Math.cos(this.radians) * this.distance;
                        this.y = y + Math.sin(this.radians) * this.distance;
        
                        this.draw();
                    }
                }
        
                let particles = new Array();
                
                function int(){
                    particles = [];
                    for(let i = 1; i <= 50; i++){
                        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
                    }
                }

                int();
        
                function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
                } 

                function animate(){
                    if(isScrolledIntoView(canvas)){
                        c.clearRect(0, 0, canvas.width, canvas.height);
                        particles.forEach((particle) => {
                            particle.update();
                        });
                    }
                    requestAnimationFrame(animate);
                }
        
                animate();
            }
        </script>

<p>Now, let's try to create a nice <span>trail</span> to make the 
    animation smoother:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10"> function animate(){
    c.fillStyle = 'rgba(255, 255, 255, 0.06)';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}</span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-025"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-025');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
    
                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * this.distance;
                    this.y = y + Math.sin(this.radians) * this.distance;
    
                    this.draw();
                }
            }
    
            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(255, 255, 255, 0.06)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>This doesn't look very beautiful to me, and that's because we are using 
<Span>arcs</span>, to make it better let's change <span>arcs</span> to <Span>lines</span>, 
in order to create <Span>lines</span> we are gona need to keep reference of our 
<span>previous x,y positions</span> so that we can draw the line from 
<Span>the previous x,y positions</span> to <Span>new x,y positions</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let cas = document.getElementById('canvas-026');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
<Span class="orange">this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }</span>
    this.update = function(){
<Span class="orange">        let previousPoints = {
            x: this.x, 
            y: this.y
        }</span>

        this.radians += this.velocity;

        this.x = x + Math.cos(this.radians) * this.distance;
        this.y = y + Math.sin(this.radians) * this.distance;

        <Span class="orange">this.draw(previousPoints);</span>
    }
}

<Span class="orange">let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];</span>

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        <Span class="orange">let r = Math.random() * 3 + 1;</span>
        <Span class="orange">let cl = colors[Math.floor(Math.random() * colors.length)];</span>
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
</span></p>

<p class="left">Outcome:</p>

<canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-026"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-026');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * this.distance;
                    this.y = y + Math.sin(this.radians) * this.distance;
    
                    this.draw(previousPoints);
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>A lot better, don't you agree? I did some other changes too, like, I 
<Span>randomized the radius</span> and <span>color</span> to make it look better, 
since when the <Span>animation first starts</Span> the <Span>x</Span> and 
<Span>y</Span> are at the <Span>center of the circle</Span>, I made it so 
it checks if <Span>previous.x and y are equal to original x and y</Span> and if 
true I use the <Span>new x and y positions</Span> on both <Span>moveTo</span> and 
<Span>lineTo</Span>, I did that in order to fix a bug, after the canvas has been drawn, even though 
a lot of layers of <Span>black rectangles</Span> with a <Span>transparency of 0.05</span> are added to cover old drawings, 
the color stays slightly different, I don't know why, the background was just a little brighter, it wasn't very visible but I didn't like it 
so that's why I prevented the lines from starting at the center. 

<p>Let's now add some <Span>interactivity</span> so that the <span>particles</span> 
are <Span>moving with the mouse</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-027');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

<Span class="orange">let mouse = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mouseout', (e) => {
    mouse.x = Number.POSITIVE_INFINITY;
    mouse.y = Number.POSITIVE_INFINITY;
});</span>

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
    this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }
    this.update = function(){
        let previousPoints = {
            x: this.x, 
            y: this.y
        }

        this.radians += this.velocity;

        this.x = <Span class="orange">mouse.x</span> + Math.cos(this.radians) * this.distance;
        this.y = <Span class="orange">mouse.y</span> + Math.sin(this.radians) * this.distance;

        this.draw(previousPoints);
    }
}

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        let r = Math.random() * 3 + 1;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>



    <canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-027"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-027');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    this.x = mouse.x + Math.cos(this.radians) * this.distance;
                    this.y = mouse.y + Math.sin(this.radians) * this.distance;
    
                    this.draw(previousPoints);
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>So, this works fine, but it isn't very smooth, I would like to create a <span>dragging effect</span>, so that the 
<Span>particles</Span> are being <span>dragged towards the mouse slower</span>, lets try this:</p>


<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-028');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let mouse = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mouseout', (e) => {
    mouse.x = Number.POSITIVE_INFINITY;
    mouse.y = Number.POSITIVE_INFINITY;
});

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
    <Span class="orange">this.lastMouse = {x: x, y: y};</span>
    this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }
    this.update = function(){
        let previousPoints = {
            x: this.x, 
            y: this.y
        }

        this.radians += this.velocity;

<Span class="orange">        if(mouse.x != Number.POSITIVE_INFINITY){
            this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
            this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

            this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
            this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

            this.draw(previousPoints);
        }</span>
    }
}

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        let r = Math.random() * 3 + 1;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>


<canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-028"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-028');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.lastMouse = {x: x, y: y};
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    if(mouse.x != Number.POSITIVE_INFINITY){
                        this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
                        this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

                        this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
                        this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

                        this.draw(previousPoints);
                    }
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

    <p>So, when <Span>mouse.x stops being POSITIV_INFINITY</span>, if for example you 
    move your mouse to the <Span>top left corner of the canvas</Span>, the <Span>lastMouse.x</Span> will be increased by 
    the <Span>distance of your old mouse pisition and your new mouse positive * 0.09</Span>, then the result will be used to change the <Span>position of the circle</Span>, 
    which means, <Span>if you moved your mouse from (50, 50) to (100, 50)</Span>, then the <span>lastMouse.x</span> would become 
<span>50 (which was the last mouse position) + 50 (which is the distance from the new mouse position) * 0.09</span>, this is later used for the <Span>x</span> of the circle, 
so, what this basically does it that it makes <span>x increase slowly</span> instead of moving exactly with the mouse, and that creates a smoother effect than before.</p>

</article>
 
<hr>

<article id="seventeen">
    <header>
        <h1>How to obtain and manipulate pixels data</h1>
    </header>

    <p>In this section we will learn how to <Span>obtain</Span> and <Span>manipulate</Span> the <span>pixels data</span> 
        of the <span>canvas</span>, we will learn 
        how by providing <span>x, y coordinates</span> we can <span>obtain the RGBA value of the pixel at that position</span>, by knowing that, 
        we will then be able to <Span>manipulate them</Span>, using <Span>ctx.getImageData()</Span> and <span>ctx.putImageData()</span> 
        methods. Lastly we will also learn <Span>canvas.toDataURL()</Span> method which allows us to 
        <Span>save a canvas</span> as an <Span>URL</Span> that can later be used as 
        <Span>source</Span> of an <span>image</span>.

<h2><u>ctx.getImageDate() method:</u></h2>

    <p>The <Span>CanvasRenderingContext2D method getImageData()</span> of the 
    <span>Canvas 2D API</span> returns an <span>ImageData object</span> representing the
<Span>underlying pixel data</span> for a <span>specified portion of the canvas</span></p>

    <p>This <span>method</span> is <Span>not affected</span> by the <span>canva's transformation matrix</span>.
        If the <span>specified rectangle extends outside the bounds of the canvas</span>, the <Span>pixels outside the canvas</Span>
        are <Span>transparent black</span> in the <Span>returned ImageData object</span></p>

<p>The <Span>getImageData()</Span> method takes <span>four parameters</span>, which are the following: <Span>x, y, width, height</Span>, those 
<span>parameters</span> are used to <Span>select the area of the canvas you want</Span>, 
after using this <span>method</span> an <span>object will be returned</span>, let's take a look 
to that <span>object</span>:</p>

<p class="left">JavaScript Code:</p>
<p class="left"><span class="code10">let canvas = document.getElementById('canvas-020');
let c = canvas.getContext('2d');

let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

console.dir(imageData);</span></p>
<p class="left">Outcome:</p>

<script>
    if(true){
        let canvas = document.getElementById('canvas-020');
        let c = canvas.getContext('2d');

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

        console.dir(imageData);
    }
</script>

<img src="../images/ω7.png">

<p>There are <Span>two errors</span> that may appear when you 
call this <Span>method</span>, one is <span>IndexSizeError</span> which will 
be thrown if <span>either width or height are zero</span>, and the <span>second error</span> is 
<Span>SecurityError</Span>. The <span>canvas</span> contains or may contain <span>pixels which were loaded from an origin other than the one from 
which the document itself was loaded</span>. To avoid <Span>SecurityError</Span> being thrown in this situation, 
<Span>configure CORS</Span> to <Span>allow the source image to be used in this way</Span>.</p>

<p>Anyway, let's continue now and learn what the <Span>data property</span> is. The <span>data property</span>
is a <Span>Unit8ClampedArray</span> representing a <span>one-dimensional array</span> containing the <Span>data</Span> in the 
<span>RGBA order</span>, with <span>integer values between 0 and 255</span>.</p>

<p>The <span>data property</span> returns a <span>Uint8ClampedArray</span> which can be 
accessed to look at the <span>raw pixel data</span>. Each <Span>pixel</Span> is represented by 
<Span>four one-byte values</Span> (red, green, blue and alpha, in that order, that is, "RGBA" format). <Span>Each color</Span>
component is represented by an <Span>interger between 0 and 255</Span>. <Span>Each component</span> is 
assigned a <Span>consecutive index within the array</span>, with the <Span>top left pixel's red component</span> being at <Span>index 0 within the array</span>. <Span>Pixels</span> then proceed from 
<Span>left to right</span>, then <Span>downward</span>, throughout the <span>array</span>.</p>

<h2><u>How to find pixels in the pixels array:</u></h2>

<p>So, let me explain the <Span>pixels array</span> with simplier words now, the <Span>first four elements of the array</span> are the 
<Span>RGBA values of the first pixel at the top left of the canvas</span>, the <Span>first element is red</span>, 
the <Span>second element is green</span>, the <span>third element is blue</span> and the <span>fourth element is alpha</span>, 
so how could we <Span>find a specific pixel in the canvas</Span> inside this <span>array</span>? There is a 
<span>formula</span> we can use, if <Span>each pixel only was one element each</Span>, then <Span>x + y * width</Span> would return 
the <Span>pixel at the specified x and y position</Span>, the <Span>second pixel</Span> for example would be at <span>(1, 0)</span>, 
in a <Span>canvas with width 100pixels</Span>, if we did <span>2 + 0 * 100</span> we would get <span>2</span>, however, since <span>each pixel takes four elements</span> we 
should <span>multiple this by 4</span>, so if I wanted to choose the <span>first pixel</span>, I would do 
<span>(0 + 0 * 100) *4</span>, which would give me <Span>0</span>, which is indeed the 
<Span>first element of the first pixel</Span>, if I wanted to get the <Span>second pixel</Span> I would do 
<span>(1 + 0 * 100) *4</span> which would give me <Span>4</Span>, which is indeed the <span>first element of the second pixel</span>. 
What you need to remember is the following simple <Span>formula</Span> and you will be able to 
find the <Span>pixel</Span> you want in the <span>pixels array</span>: <Span>(x + y * canvas.width) * 4</Span></p>

<p>So, if you wanted to only choose the <span>red velue</span> of the <Span>pixels</Span> you could 
use the <Span>formula</span> I wrote above, if you however wanted to select the <Span>green value</Span> you could use this one instead:
<span>(x + y * canvas.width) * 4 + 1</span>, or if you wanted to select the <span>blue value</span> you could 
use this one: <span>(x + y * canvas.width) * 4 + 2</span>, and lastly, to select the <Span>alpha value</span> 
you could use this one: <Span>(x + y * canvas.width) * 4 + 3</span>.</p>

<p>Here is a video that really helped me understand the <span>pixels array</span>:</p>

<iframe src="https://www.youtube.com/embed/nMUMZ5YRxHI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>So, now, let's create a simple <Span>function</Span> that gets the
<Span>RGBA values</Span> of a <Span>specified pixel</Span>:

<p class="left">JavaScript Code:</p>
<p class="left"><Span class="code10">function getColorIndices(x, y, width){
let red = (x + y * width) * 4;
return [red, red + 1, red + 2, red + 3];
};

let colorIndices = getColorIndices(1, 0, 100);

let [redIndex, greenIndex, blueIndex, alphaIndex] = colorIndices;

// redIndex == 4, greenIndex == 5, blueIndex == 6, alphaIndex == 7
</Span></p>

<P>Let's create a <Span>color picker</Span> project for fun:</P>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;table id="colorpicker-project">
    &lt;tr>
        &lt;th>Source&lt;/th>
        &lt;th>Hovered color&lt;/th>
        &lt;th>Selected Color&lt;/th>
    &lt;/tr>
    &lt;tr>
        &lt;td>&lt;canvas id="canvas-colorpicker">&lt;/canvas>&lt;/td>
        &lt;td>&lt;div id="hoveredcolor">&lt;/div>&lt;/td>
        &lt;td>&lt;div id="selectedcolor">&lt;/div>&lt;/td>
    &lt;/tr>
&lt;/table></Span></p>

<p class="left">CSS Code:</p>

<p class="left"><Span class="code10">#colorpicker-project{
    border: 3px solid lightcyan;
    border-collapse: collapse;
    margin: auto;
    background-color: black;
    color: lightcyan;
}
#colorpicker-project th, #colorpicker-project td{
    border: 2px solid lightcyan;
    padding: 5px;
}
#selectedcolor, #hoveredcolor{
    height: 150px;
    width: 100%;
}</Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-colorpicker');
let c = canvas.getContext('2d');
let hoveredColor = document.getElementById('hoveredcolor');
let selectedColor = document.getElementById('selectedcolor');

let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
gradient.addColorStop(0, 'red');
gradient.addColorStop(0.5, 'green');
gradient.addColorStop(1, 'blue');

c.fillStyle = gradient;
c.fillRect(0, 0, canvas.width, canvas.height);

let mouse = {
    x: undefined,
    y: undefined
}

function colorPicker(event, target){
    mouse.x = event.offsetX;
    mouse.y = event.offsetY;

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
    function getColorIndices(x, y, width){
        let red = (x + y * width) * 4;
        return [red, red + 1, red + 2, red + 3];
    }

    let colorIndices = getColorIndices(mouse.x, mouse.y, canvas.width);

    let RGBA = colorIndices.map((x) => {
        return imageData.data[x];
    });

    target.style.backgroundColor = `rgba(${RGBA})`;
}

canvas.addEventListener('mousemove', (e) => {
    colorPicker(e, hoveredColor);
});

canvas.addEventListener('click', (e) => {
    colorPicker(e, selectedColor);
});</Span></p>

<p class="left">Outcome:</p>

<Style>
    #colorpicker-project{
        border: 3px solid lightcyan;
        border-collapse: collapse;
        margin: auto;
        background-color: black;
        color: lightcyan;
    }
    #colorpicker-project th, #colorpicker-project td{
        border: 2px solid lightcyan;
        padding: 5px;
    }
    #selectedcolor, #hoveredcolor{
        height: 150px;
        width: 100%;
    }
</Style>

<table id="colorpicker-project">
    <tr>
        <th>Source</th>
        <th>Hovered color</th>
        <th>Selected Color</th>
    </tr>
    <tr>
        <td><canvas id="canvas-colorpicker"></canvas></td>
        <td><div id="hoveredcolor"></div></td>
        <td><div id="selectedcolor"></div></td>
    </tr>
</table>

<script>
    if(true){
        let canvas = document.getElementById('canvas-colorpicker');
        let c = canvas.getContext('2d');
        let hoveredColor = document.getElementById('hoveredcolor');
        let selectedColor = document.getElementById('selectedcolor');
        
        let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'red');
        gradient.addColorStop(0.5, 'green');
        gradient.addColorStop(1, 'blue');
        
        c.fillStyle = gradient;
        c.fillRect(0, 0, canvas.width, canvas.height);

        let mouse = {
            x: undefined,
            y: undefined
        }

        function colorPicker(event, target){
            mouse.x = event.offsetX;
            mouse.y = event.offsetY;

            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            
            function getColorIndices(x, y, width){
                let red = (x + y * width) * 4;
                return [red, red + 1, red + 2, red + 3];
            }

            let colorIndices = getColorIndices(mouse.x, mouse.y, canvas.width);

            let RGBA = colorIndices.map((x) => {
                return imageData.data[x];
            });

            target.style.backgroundColor = `rgba(${RGBA})`;
        }

        canvas.addEventListener('mousemove', (e) => {
            colorPicker(e, hoveredColor);
        });

        canvas.addEventListener('click', (e) => {
            colorPicker(e, selectedColor);
        });
    }
</script>

<p>Getting the <Span>opacity</Span> is a little different however, the 
<Span>opacity</Span> is stored in <Span>values between 0 and 255</Span>, 
if for example the <Span>first pixel</Span> has the <Span>opacity of 0.5</Span>, 
then <Span>imageData.data[3]</Span> would return <Span>0.5 * 255</Span>, 
in order to <Span>convert that number</Span> back to the 
<Span>original float number of the opacity</Span> you should 
<Span>devide the given number by 255</Span>, like this:</p>

<style>
#canvass1{
    margin: auto;
    display: block;
    border: 3px solid black;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvass1');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

c.fillStyle = 'red';
c.globalAlpha = '0.5';

c.fillRect(0, 0, canvas.width, canvas.height);

let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
let data = imageData.data;

let opacity = data[3] / 255;
document.write(`The first pixel of the canvas has an opacity of ${opacity}`);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvass1"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvass1');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    c.fillStyle = 'red';
    c.globalAlpha = '0.5';

    c.fillRect(0, 0, canvas.width, canvas.height);

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;

    let opacity = data[3] / 255;
    document.write(`The first pixel of the canvas has an opacity of ${opacity}`);
}
</script>

<h2><u>putImageData() method:</u></h2>

<p>You can use the <Span>putImageData()</Span> method to <Span>paint pixel data</Span>
into a <Span>context</span>, it's <Span>syntax</span> looks like this: <Span>ctx.putImageDate(myImageData, dx, dy)</Span>;</p>

<p>The <Span>dx</span> and <Span>dy</span> parameters indicate the <Span>device coordinates within the context</Span>
which to paint the top left corner of the pixel data you wish to draw.</p>

<p>For example, to paint the <Span>entire image</Span> represented by <Span>myImageData</Span> to the 
<Span>top left corner of the context</span>, you can do the following: <Span>ctx.putImageData(myImageData, 0, 0);</Span></p>

<p class="left">HTML Code:</p>

<p class="left"><span class="code10">#canvas-project007{
    display: grid;
    grid-template-areas: 
    'canvas' 
    'form';
    justify-content: space-evenly;
    margin: auto; 
    width: fit-content;
}
#canvas-0002{
    border: 3px solid black;
    grid-area: canvas;
}
#canvas-project007 form{
    grid-area: form;
    display: flex; 
    width: 100%;
    justify-content: space-evenly;
}</span></p>

<p class="left">CSS Code:</p>

<p class="left"><span class="code10">&lt;div id="canvas-project007">
&LT;canvas id="canvas-0002" style="border: 3px solid black; display: block; margin: auto;">&lt;/canvas>
&lt;form>
    &lt;input type="radio" name="type" value="original" checked="true"> Original 
    &lt;input type="radio" name="type" value="Grayscale"> Grayscale 
    &lt;input type="radio" name="type" value="Inverted"> Inverted
&lt;/form>
&lt;/div></span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-0002');
let c = canvas.getContext('2d');

let inputs = document.querySelectorAll('#canvas-project007 input');

let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
gradient.addColorStop(0, 'red');
gradient.addColorStop(0.3, 'pink');
gradient.addColorStop(0.5, 'green');
gradient.addColorStop(0.7, 'yellow');
gradient.addColorStop(1, 'blue');

let img = new Image();
img.src = ../images/ω8.png';

function original(){
    let aspectRatio = img.naturalWidth / img.naturalHeight;
    canvas.height = canvas.width / aspectRatio;
    c.drawImage(img, 0, 0, canvas.width, canvas.height);
}

img.addEventListener('load', (e) => {
    original();
});

function grayscale(){
    original();
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;
    for(let i = 0; i < data.length; i+=4){
        let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = avg;
        data[i + 1] = avg;
        data[i + 2] = avg;
    }
    c.putImageData(imageData, 0, 0);
}

function inverted(){
    original();
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;
    for(let i = 0; i < data.length; i += 4){
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2]
    }
    c.putImageData(imageData, 0, 0);
}

inputs.forEach((input) => {
    input.addEventListener('change', (e) => {
        switch(e.target.value){
            case "Grayscale":
                return grayscale();
            break;
            case "Inverted":
                return inverted();
            break;
            default: 
                return original();
        }
    });
});</span></p>

<p class="left">Outcome:</p>

<style>
    #canvas-project007{
        display: grid;
        grid-template-areas: 
        'canvas' 
        'form';
        justify-content: space-evenly;
        margin: auto; 
        width: fit-content;
    }
    #canvas-0002{
        border: 3px solid black;
        grid-area: canvas;
    }
    #canvas-project007 form{
        grid-area: form;
        display: flex; 
        width: 100%;
        justify-content: space-evenly;
    }
</style>

<div id="canvas-project007">
<canvas id="canvas-0002" style="border: 3px solid black; display: block; margin: auto;"></canvas>
<form>
    <input type="radio" name="type" value="original" checked="true"> Original 
    <input type="radio" name="type" value="Grayscale"> Grayscale 
    <input type="radio" name="type" value="Inverted"> Inverted
</form>
</div>

<script>
    if(true){
        let canvas = document.getElementById('canvas-0002');
        let c = canvas.getContext('2d');

        let inputs = document.querySelectorAll('#canvas-project007 input');

        let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'red');
        gradient.addColorStop(0.3, 'pink');
        gradient.addColorStop(0.5, 'green');
        gradient.addColorStop(0.7, 'yellow');
        gradient.addColorStop(1, 'blue');
        
        let img = new Image();
        img.src = '../images/ω8.png';

        function original(){
            let aspectRatio = img.naturalWidth / img.naturalHeight;
            canvas.height = canvas.width / aspectRatio;
            c.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        img.addEventListener('load', (e) => {
            original();
        });

        function grayscale(){
            original();
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 0; i < data.length; i+=4){
                let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
            }
            c.putImageData(imageData, 0, 0);
        }

        function inverted(){
            original();
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 0; i < data.length; i += 4){
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2]
            }
            c.putImageData(imageData, 0, 0);
        }

        inputs.forEach((input) => {
            input.addEventListener('change', (e) => {
                switch(e.target.value){
                    case "Grayscale":
                        return grayscale();
                    break;
                    case "Inverted":
                        return inverted();
                    break;
                    default: 
                        return original();
                }
            });
        });        
    }
</script>

<p>In the <Span>previous section</span> I created a project in which some 
<Span>particles</span> are <Span>making a circual move around your mouse</span> 
with a <Span>trail effect</span>, but because I used <Span>fillRect with an opacity of 0.5</span> to
make that <Span>trail effect</span> the <Span>background of the canvas lost it's transparency</span>, something
that's bad since I wanted to later to make the <Span>canvas</span> take the 
whole page with a <Span>fixed position</span> and a <span>transparent background</span>, 
to fix that, I am gonna use <span>getImageData()</span>, to get the <Span>pixels data</Span> before 
each <Span>animation iteration</span>, then I will <Span>multiple the opacity of all pixels by 0.9</span>, meaning that 
<Span>pixels that are already transparent will stay transparent</span> while 
<Span>pixels that wer visible will become more transparent</span> then I will simple 
use <Span>clearRect()</span> to clear the <Span>canvas</span> and <span>putImageData()</span> to 
<Span>draw the particles with a lower transparency</Span>, then the <Span>next animation iteration will happen</span> 
and like that the <Span>trail effect</span> will be created:</p>

<p class="left">JavaScript:</p>

<p class="left"><span class="code10"> function animate(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-029"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-029');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.lastMouse = {x: x, y: y};
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    if(mouse.x != Number.POSITIVE_INFINITY){
                        this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
                        this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

                        this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
                        this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

                        this.draw(previousPoints);
                    }
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                    let data = imageData.data;
                    for(i = 3; i < data.length; i += 4){
                        data[i] = data[i] * 0.9
                    }
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    c.putImageData(imageData, 0, 0);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>







<h2><u>Saving images with canvas.toDataURL() method:</u></h2>

<p>The <span>HTMLCanvasElement</span> provides a <Span>toDataURL()</Span> method, which is
useful when <Span>saving images</Span>. It returns a <Span>data URL</Span> containing a 
representation of the <span>image</span> in the format specified by the type parameter (defaults to PNG). The <Span>returned image</Span> is a <Span>resolution of 9 dpi</Span>.</p>

<P>The syntax looks like this: <Span>canvas.toDataURL('image/png', quality)</span>, of course you can use other formats 
    such as <span>jpg</span>, <span>jpeg</span>, etc, and also, the <span>second parameter</span> is 
    <Span>optional</Span>, you don't need to add it, you can provide a 
    <span>quality</span> in a <Span>range from 0 to 1</Span>, with one being the 
    best quality and with - almost not recognizable but small in file size.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-idka');
let c = canvas.getContext('2d');

c.fillStyle = 'lightcoral';
c.fillRect(0, 0, canvas.width, canvas.height);

let colors = ["yellow", "brown", "green", "orange", "pink", 'purple'];

for(let i = 0; i&lt;100; i++){
    let r = Math.random() * 3 + 2;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 2) + r;
    let cl = colors[Math.floor(Math.random() * colors.length)];

    c.fillStyle = cl;
    c.beginPath();
    c.arc(x, y, r, 0, Math.PI * 2);
    c.stroke();
    c.fill();
}

let url = canvas.toDataURL('image/jpeg', 1);

let img = document.getElementById('image-container');
img.src = url;</span></p>

<p class="left">Outcome:</p>


<canvas id="canvas-idka" style="border: 3px solid black; display: block; margin: auto;"></canvas>
<img id="image-container">

<script>
    if(true){
        let canvas = document.getElementById('canvas-idka');
        let c = canvas.getContext('2d');

        c.fillStyle = 'lightcoral';
        c.fillRect(0, 0, canvas.width, canvas.height);

        let colors = ["yellow", "brown", "green", "orange", "pink", 'purple'];

        for(let i = 0; i<100; i++){
            let r = Math.random() * 3 + 2;
            let x = Math.random() * (canvas.width - r * 2) + r;
            let y = Math.random() * (canvas.height - r * 2) + r;
            let cl = colors[Math.floor(Math.random() * colors.length)];

            c.fillStyle = cl;
            c.beginPath();
            c.arc(x, y, r, 0, Math.PI * 2);
            c.stroke();
            c.fill();
        }

        let url = canvas.toDataURL('image/jpeg', 1);

        let img = document.getElementById('image-container');
        img.src = url;
    }
</script>

<p>The reason the image has a border and is center is because I 
have styled all the images I add to be like that since it's time consuming 
to add the styles on each seperately.

</article>

<hr>

<article id="eighteen">
    <header>
        <h1>How to make Sine Waves</h1>
    </header>

<p>In this section we will learn how to draw 
<Span>sine waves</span> and <Span>edit them</Span>, 
learning the theory behind them can be very useful, because 
<Span>sine waves</span> can be used in many ways. They are 
very beautiful to use for <Span>dynamic backgrounds</Span> 
and stuff, that make your <span>website</span> look better
than simple static drawings. 
</p>

<p>To create the <Span>waves</Span> we are 
going to use the <Span>Math.sin()</span> method, I explaine 
how it works in the previous section, when you want something 
to go <Span>forth and back</Span>, or <Span>up and down</span> 
the <Span>Math.sin()</span> method is usually what you are looking for, 
since it returns <Span>numbers between -1 and 1</span>, 
we are going to create a <Span>loop</Span> to draw the 
waves <Span>pixel by pixel</span> and use <Span>Math.sin()</Span>
to change the <Span>y value continuously<Span>, let's try this:</p>

<style>
.cvas{
    display: block; 
    margin: auto;
    border: 3px solid black;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0003');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i));
}
c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0003"></canvas>

<script>
if(true){
    let canvas = document.getElementById('canvas-0003');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let wave = {
        y: canvas.height / 2
    }

    c.beginPath();
    c.moveTo(0, wave.y);
    for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i));
    }
    c.stroke();
}
</script>

<p>Alright, we did make some <Span>really small waves</span>, 
but I would like them more if they were a little bigger, 
to do that we will add an <Span>aplitude</Span> to our 
<Span>waves</Span>, right now, <Span>Math.sin()</Span> returns 
<Span>numbers between -1 and 1</span>, if I were to <Span>multiple this</span> 
by <Span>50</Span> for example it would <Span>return numbers between -50 and 50</Span>, 
lets try this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0004');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2,
    aplitude: 50
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i) * wave.aplitude);
}
c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0004"></canvas>

<script>
if(true){
    let canvas = document.getElementById('canvas-0004');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let wave = {
        y: canvas.height / 2,
        aplitude: 50
    }

    c.beginPath();
    c.moveTo(0, wave.y);
    for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i) * wave.aplitude);
    }
    c.stroke();
}
</script>

<p>That's a little better, but it's still a little ugly, the <Span>length</Span>
of the <Span>waves</span> is way too small, to dix that we can <Span>multiple i inside Math.(sin) with a demical number</Span>, 
right now we are getting a <span>small length</span> because the <Span>numbers between -50 and 50</Span> are 
<Span>going up and down way too fast</Span>, if instead of <Span>increasing i by 1 for each loop</Span> I were 
<span>increasing it with 0.05</span> for example, the <Span>waves would get bigger</Span>, so all I have to do 
is <Span>multiple i with 0.05</span>.</p>

    <p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0005');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
}
c.stroke();</span></p>
    
    <p class="left">Outcome:</p>

    <canvas class="cvas" id="canvas-0005"></canvas>

    <script>
    if(true){
        let canvas = document.getElementById('canvas-0005');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let wave = {
            y: canvas.height / 2,
            aplitude: 50,
            length: 0.05
        }
    
        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
    }
    </script>

<p>Now, before I continue I would like to add a 
<Span>package</span> to our code that allows us to <Span>change the values of the variables</Span>
and see our <Span>animation change</span> on screen without having to <Span>edit the code and save</Span>, 
this will save us a lot of time since we won't have to just try out random values again and again till we find the ones we like, 
and also it's just cool, to be able to manipulate the <Span>wave</Span>, it also will help us better understand how the 
<Span>wave</span> works. 
</p>

<p>The <Span>package</Span> I will use is called <span>dat.GUI</span> and I have wrote about everything you need 
to know to <span>install it</span> in <a href="./../Extra-Notes/extranotes1.html">this page</a>, you will need to learn how to 
use the <Span>terminal</Span>, how to use <span>NPM</span>, then how to use <Span>parcel</Span> and then I have also 
wrote instructions abou thow to <Span>install and use dat.gui</Span>.</p>

<img src="./../images/waves1.png">

<p>I know this may seem a little complicated, so let me explain what I did, 
I created an <Span>external canvas.js file</Span> which I will from now on use 
to <Span>draw all my canvas elements</Span>, and I <Span>bundled it with parcel</Span>, 
so that <span>data.gui package works</span>. From now on, whenever I 
<Span>update canvas.js</span> the <Span>canvas.js inside canvas folder will also be updated automatically</span>. 
I will be using the <Span>bundled file</Span> inside <Span>the page you are currently viewing</Span>, 
after I'm done with all my projects, I will <span>use parcel build to minimize the bundled file</span> 
so it <Span>takes less space</Span>, I  then <span>remove the original canvas.js</span> file, or keep it somewhere 
for later anyway, and I will only need to keep the <Span>bundled canvas.js file</Span>.
</p>

<style>
.property-name{
    background-color: gray !important;
}
.c{
    background-color: gray !important;
}
.cvas{
    display: block; 
    margin: auto;
    border: 3px solid black;
}
</style>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10"><Span class="orange">import * as dat from 'dat.gui'</Span>

let canvas = document.getElementById('canvas-0006');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

<Span class="orange">canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

function animate(){
    if(isScrolledIntoView(canvas)){</span>
        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
<span class="orange">    }</span>
    requestAnimationFrame(animate);
<Span class="orange"></Span>}

animate();</Span></span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0006"></canvas>

<script src="./../CSS-JavaScript-External-Files/dat/canvas/canvas.js">
</script>

<P>If you <Span>click the canvas</Span> and <Span>play with the variables</Span> you 
will see the <Span>waves change</Span>, it will only work 
if the <Span>canvas</span> is <Span>scrolled into view</span> 
and I do that for <span>every animation I make</span> because 
I have built a lot of <Span>animations</span> and if all of them 
worked together the page would be very laggy. Anyway, there is a problem, it keeps on 
<Span>drawing over the previous frames</Span>, to fix that, I'm gonna use 
<Span>getImageData()</Span> and <Span>putImageData()</span>, I 
could just <Span>use clearRect()</span> but I want to add a 
<Span>trail effect</span> and <Span>keep a transparent background</span> 
so that the <Span>canvas</span> can later be used easily anywhere 
without a problem:</P>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui'

let canvas = document.getElementById('canvas-0007');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){

<span class="orange">        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);</span>

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0007"></canvas>

<p>Let's try to make the <Span>wave move</Span> now, by adding 
a <Span>frequency</span> variable. <span>Frequency</span> in a 
<Span>number of wave cycles</Span> that <Span>pass a fixed point over time</span>.</p>

<p>To create the <Span>moving effect</span> we will be <Span>adding an increasing number</Span> inside 
our <span>Math.sin()</span> method, this <Span>increment number</Span> will be <Span>increased by the frequency</span> 
every time <Span>an animation frame is over</span>, thus creating an <Span>illusion of moving</Span>. Why does 
this create the <Span>illusion of moving</span>? From what I understand, this <Span>increment number</span> changes the 
<Span>starting point of our waves</span>, since it's a <Span>static number</span> that <Span>does not increase throughout the for loop</span>,
the <Span>number inside Math.sin()</Span> method will be <span>increased the same</span> for <Span>all loops</Span> 
in an <Span>animation frame</Span>, thus <Span>moving all the pixels</Span> to slightly <Span>different positions</Span>
than in the <Span>previous animation frame</Span>.
The <Span>waves</Span> will always <Span>start from our y point</Span> since only the <Span>lineTo()</span> method is 
inside our <Span>loop</Span> and <Span>is effected by the frequency</Span>, as the <Span>increment number</Span> is 
<Span>increasing</Span> the <span>wave's y</span> seems to <Span>be going up and down</Span>, in reality, 
our <Span>pencil</Span> will <Span>always start from y</Span>, what changes is 
that <Span>y coordinate</Span> that the <Span>first line is drawn to</Span>, it's because, 
the <Span>y</Span> has <Span>changed</Span> from the <Span>previous animation frame</Span> just a little, 
either has <span>increased</span> or <Span>decreased</span>, depened on <Span>Math.sin()</Span>, 
since it gives a <Span>number between our aplutide and -aplitude</Span>. The 
<Span>increment number</Span> has been added to <Span>all of the lineTo() methods</Span>
that are <Span>called throughout the loop</Span>, and since the <Span>Math.sin()</Span>
method gives us a <Span>value between aplitude and -aplitude</Span> if the <Span>first y</Span> is 
<Span>increased</Span> that means the <Span>max/min aplitude</Span> will be <Span>reached faster</Span>, meaning 
that since <Span>the first wave will end faster</Span> the <Span>rest of the waves</Span> 
will <Span>also seem to have moved a little to the left</Span>, since they will <Span>start faster their circle</Span>
than they <Span>did in the previous animation frame</Span>, let's try this out: 
</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><Span class="code10">import * as dat from 'dat.gui' 

let canvas = document.getElementById('canvas-0008');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05,
<Span class="orange">    frequency: 0.01,</span>
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
<span class="orange">        wave_folder.add(wave, 'frequency', -1, 1);</span>
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

<Span class="orange">let increment = wave.frequency;</span>
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i * wave.length <Span class="orange">+ increment</span>) * wave.aplitude);
        }
        c.stroke();
<Span class="orange">        increment += wave.frequency;</span>
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0008"></canvas>

<p>To make it a little better lets make the <Span>aplitude</Span> go <Span>up and down</Span>, to do this 
we simple can <Span>multiple aplitude</Span> with <Span>Math.sin(increment)</Span>, it doesn't have 
to be <span>increment</span>, any <Span>increasing number would do</Span>, but since 
we have it ready we will use this one. Also, I want to <Span>change the starting length</Span> a little
to make it look better, you can always just eidt it back by opening the <Span>variable changer</Span>, which 
you can do by <Span>clicking the canvas</Span>.</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui' 

let canvas = document.getElementById('canvas-0009');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
<span class="orange">   length: 0.010,</span>
    frequency: 0.01,
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude <Span class="orange">* Math.sin(increment)</span>);
        }
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0009"></canvas>

<p>Let's now <Span>add stroke color</span> to our 
<span>>wave</span> and make it <Span>editable</span> 
from our <span>variable changer</san>:<p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-00010');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.01,
<Span class="orange">    frequency: 0.03,</span>
}

<span class="orange">let stroke = {
    h: 0,
    s: 50, 
    l: 50
}</span>

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
<Span class="orange">        wave_folder.open();

        let stroke_folder = gui.addFolder('stroke');
        stroke_folder.add(stroke, 'h', 0, 360);
        stroke_folder.add(stroke, 's', 0, 100);
        stroke_folder.add(stroke, 'l', 0, 100);
        stroke_folder.open();</span>
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude * Math.sin(increment));
        }
<Span class="orange">        c.strokeStyle = `hsl(${stroke.h}, ${stroke.s}%, ${stroke.l}%)`;</span>
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-00010"></canvas>

<p>I also made some other changes, like, I made the <span>frequency faster</span> and I also 
made it so the <Span>folders automatically open</span> after you <Span>click the canvas</span></p>

<p>Alright, last thing I'm gonna do is make it <Span>change color continuously</span>, 
for example, if the <Span>h is 360</span> I want it to change the <span>h value</span> 
<Span>from 360 to 0</span>, then <Span>from 0 to 360</span> and so on, to do that 
I can simple write <Span>strokeStyle = `hsl(${stroke.h * Math.sin(increment)}, ...`</span> 
however, that would mean <Span>negative numbers would also be looped through</span>, 
to fix that, I would use the <Span>Math.abs()</span> method, like this: <span>strokeStyle = `hsl(${Math.abs(stroke.h * Math.sin(increment)), ...`</span></p>

<p>Also, there is a problem I would like to fix, if you look closely you will notice 
that at the <Span>left edge</span> there is a <Span>visible line</Span> which before 
wasn't very visible but now with color it is. As I said before, the <Span>moveTo()</span>
method is not inside the <Span>for loop</span>, meaning that the <Span>waves</Span> will always 
start from <span>y</span>, its the <Span>lineTo()</span> values that change. To fix that 
I will simple make the <Span>moveTo()</Span> method go <Span>up and down</Span> as well, 
by writing <Span>moveTo(0, wave.y + Math.sin(wave.length + increment) * wave.aplitude * Math.sin(increment));</Span>.
This will <Span>change the y for every animation frame</span>, just like 
it does for the <Span>lineTo()</Span> methods inside the <Span>for loop</Span>.
</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui' 
let canvas = document.getElementById('canvas-00011');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

<span class="orange">canvas.style.backgroundColor = 'black';</span>

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.01,
<Span class="orange">    frequency: 0.02,</span>
}

let stroke = {
<span class="orange">    h: 360,</span>
    s: 50, 
    l: 50
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
        wave_folder.open();

        let stroke_folder = gui.addFolder('stroke');
        stroke_folder.add(stroke, 'h', 0, 360);
        stroke_folder.add(stroke, 's', 0, 100);
        stroke_folder.add(stroke, 'l', 0, 100);
        stroke_folder.open();
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
<span class="orange">            data[i] = data[i] * 0.95;</span>
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
<Span class="orange">        c.moveTo(0, wave.y + Math.sin(wave.length + increment) * wave.aplitude * Math.sin(increment));</span>
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude * Math.sin(increment));
        }
<Span class="orange">        c.strokeStyle = `hsl(${Math.abs(stroke.h * Math.sin(increment))}, ${stroke.s}%, ${stroke.l}%)`;</span>
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-00011"></canvas>

<p>As you can see I made some changes, I made the <Span>background black</span>, 
made the <Span>trail bigger</span> and the <Span>frequency slower</span>, I also 
made the <Span>changes mentioned before</span>.</p>

<p>Here is a video that helped me a lot, I think the final project I made 
is a little better because of some fixes I made and improvements, but the video 
definetely explains stuff better than I do:
</p>

<iframe src="https://www.youtube.com/embed/VNmTubIDZOY?list=PLYxnDvM22X3NBARfD2aZcyUoKvfdHfygn" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="nineteen">
    <header>
        <h1>Controlled Randomness with Perlin Noise</h1>
    </header>

<p>In this section I'm going to create a 
<Span>moving snake</Span> that <Span>moves randomly</Span> 
on the <Span>canvas</Span>, it however will <Span>not move completely randomly</Span>, 
since if it did then it would <Span>teleport around the screen</span>, 
the <Span>randomness</span> is going to be kind of <Span>controlled</Span>, 
meaning the <Span>values will be related to each other</span> and I will use 
a <Span>package</span> made by <Span>Chris</span> called <Span>Perlin Noise</Span>.
</p>

<p>So, what exactly is <Span>Perlin Noise</Span>? Just like 
<Span>Math.random()</Span> it is a <Span>function</span> that <span>returns</span> a <span>number between 0 and 1</span>, however, 
the difference is that it <Span>returns those numbers</Span> in a 
<Span>specific sequence</Span>. This <Span>is not a built in function</Span>, 
you have to write it on your own, however, it is fairly complex to make 
it, since it needs a lot of math, and for that reason we 
are going to <span>use a package</span>.</p>

<p>This <Span>package</Span> I'm gonna use is fairly simple, 
you just <Span>call the function</Span> with a <Span>number as a parameter</Span> 
and it <span>returns a number between 0 and 1</span>, for example, 
I could write <Span>noise(1)</Span> or <Span>noise(2)</Span>, however, 
the <Span>number</Span> that you pass does matter, if you want to 
<Span>continiously get random values</Span> that <Span>are relative to one another</Span>
so that <Span>the randomness is controlled</Span> and the <Span>ball is not teleporting around the screen</Span>
then the <Span>values you put inside the function</Span> should be <Span>near one another</Span>, 
for example, if <Span>noise(3)</Span> returned <Span>0.3</Span> then 
<Span>noise(3.2)</Span> could return <Span>0.35</Span> or <Span>0.25</span>, 
if you put a <Span>number of a bigger distance from the previous one used</Span>
then the <Span>number that would be returned would probably have a bigger distance</Span> 
from the <Span>previous number returned</span>, which could 
make the ball teleport around. </p>

<p>Alright, so, first of all, let's <Span>install it</span> 
using <Span>NPM</span>:</p>

<img src="./../images/noise.png">    

<p>Like in the previous section I will also need to 
<Span>use an external bundled JavaScript file</span>, 
to <Span>bundle the JavaScript file</span> I will use 
<Span>parcel</span>.</p>

<img src="./../images/noise2.png">

<p>From now on I will be writing my code in 
<Span>canvas2.js</span> and <Span>parcel</span> will <Span>automatically update bundled canvas2.js</span>
for me, let's create a simple code now:
</p>

<style>
.canvvaas{
    margin: auto;
    border: 3px solid black;
    display: block;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas1');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }
    
    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }

    update(){
        this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
        this.draw();
    }
}

let particle1 = new ball(canvas.width / 2, canvas.height / 2, 20, 'red');

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particle1.update();
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvvaas1" class="canvvaas"></canvas>

<p>So, in <Span>every animation loop</Span> I 
<Span>increase increment variable</Span> by <Span>0.01</span>, 
which then is used to set the <Span>new y coordinates</Span>
to this: <span>noise(increment) * (canvas.height - 2 * this.r) + this.r</span>, 
so, <span>noise(increment)</span> will return a <Span>number between 0 and 1</Span> 
that is <Span>relative to the previous number it returned</span>, and then 
it is <Span>multipled by (canvas.height - 2 * this.r) + this.r</span>, 
I have actually used the exact same line of code before, with <Span>Math.random()</Span>, 
it basically sets the <Span>range of numbers it can return</Span> to <Span>not be less than 0 or more 
than the canvas's width</Span>. Lets now try to 
do the same for the <Span>x coordinates</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">update(){
    this.x = noise(increment) * (canvas.width - 2 * this.r) + this.r;
    this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
    this.draw();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas2"></canvas>

<p>As you can see, it does work, however, the 
<Span>ball</span> moves from <Span>the top left corner</span> 
towards the <Span>bottom right corner</span> which isn't what we want, 
the reason this happens is because we use the <Span>same increment number</span> 
in <Span>noise() function</span>, to fix that, we can simple <Span>add an offset</span>, 
we could for example write <Span>x = noise(increment - 20)</span> and
that would fix the problem.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">update(){
    this.x = noise(increment - 20) * (canvas.width - 2 * this.r) + this.r;
    this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
    this.draw();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas3"></canvas>

<p>Now, I want to create <Span>more balls</span>, 
and <span>each ball</span> should have 
<Span>a slightly different offset for y and x</span> so that 
<Span>one is behind each other</span> like a <Span>snake</span>. 
To do that, we are gonna <Span>add an offset property to the ball object</span> 
and to give a <Span>different offset</span> to <Span>each ball</span> 
we will simple use a <Span>for loop</span> to <Span>create the balls</span> 
as we usually do and we will <Span>pass i as the parameter of the offset</span>, 
since <Span>i however will be increased by 1 for each ball</span>, which 
<Span>is a big offset</span> and <Span>would create a big space between the balls</Span>, 
we are gonna <Span>multiply i with 0.02</span> 
to give the balls <Span>smaller offsets</span>. 
Those <Span>offsets</span> will be used inside the <span>noise() function</span>, 
like this: <Span>noise(increment - offset)</Span>, for <Span>x property</Span> however 
we are <Span>also gonna keep the -20 offset</Span> so that the <Span>balls</Span>
aren't moving from the top left corner towards the bottom right corner like before.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas4');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl, <Span class="orange">offset</span>){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
<span class="orange">        this.offset = offset;</span>
    }
    
    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }

    update(){
<Span class="orange">        this.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
        this.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;</span>
        this.draw();
    }
}

<Span class="orange">let particles = new Array();

let int = function(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 10;
        let x = -999;
        let y = -999;
        let cl = 'red';
        particles.push(new ball(x, y, r, cl, i * 0.02));
    }
}

int();</span>

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
<Span class="orange">        particles.forEach((particle) =>{
            particle.update();
        });</span>
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas4"></canvas>

<p>This works really nice, all that's left now is to 
add some cool <Span>effects</Span>, you can play around with 
it to see what you can create, I will use some 
simple <span>effects</span> that I have used in previous projects 
just to make it a little more interesting.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas5');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl, cl2, offset){
        this.x = x;
        this.y = y;
        this.r = r;
        this.innerColor = cl;
        this.outerColor = cl2;
        this.offset = offset;
        this.previousCoords = {x: this.x, y: this.y};
    }
    
    draw(){
        c.lineCap = 'round';
        c.lineJoin = 'round';
        c.strokeStyle = this.outerColor;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.fill();

        c.lineWidth = this.r - 5;
        c.strokeStyle = this.innerColor;
        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.fill();
        c.stroke();
    }

    update(){
        if(this.x == undefined){
            this.previousCoords.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
            this.previousCoords.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;
        }
        this.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
        this.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;
        this.draw();
        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
}

let particles = new Array();
let particles2 = new Array();

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let int = function(){
    particles = [];
    particles2 = [];
    for(let i = 0; i < 30; i++){
        let r = 23;
        let x = undefined;
        let y = undefined;
        let innerColor = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new ball(x, y, r, innerColor, 'red', i * 0.03));
        particles2.push(new ball(x, y, r, innerColor, 'blue', i * 0.03 + 300));
    }
}
int();

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.7;
            if(data[i] / 255 < 0.1){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle) =>{
            particle.update();
        });
        particles2.forEach((particle) =>{
            particle.update();
        });
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</Span>
</p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas5" style="background-color: black;"></canvas>

<p>This tutorial helped me make this section, I recommend you watch it 
if you need extra help:</p>

<iframe  src="https://www.youtube.com/embed/M4WzhdQPyH0?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<script src="./../CSS-JavaScript-External-Files/dat/canvas/canvas2.js"></script>

</article>

<hr>

<article id="twenty">
    <header>
        <h1>How to create fireworks</h1>
    </header>

<p>In this section we are going to create <Span>fireworks</Span>, 
in order to do so we are gonna use knowledge gained from the 
<span>section I talked about gravity</span> and <Span>in the section I talked about circular motions</Span>,
we are also gonna use some other tricks I'm going to explain in more detail throughout the section.</p>

<p>First thing we want to do is to make 
<Span>particles spawn on click</Span>, so let's do just that 
and begin building on our way towards the <Span>fireworks</Span> 
effect we want to get slowly from there:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas6');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl, velocity, previousCoords){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.previousCoords = previousCoords;
    }

    draw(){
        c.strokeStyle = this.cl;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.lineWidth = this.r; 

        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
    }

    update(){
        if(this.previousCoords.x == undefined){
            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }

        this.x += this.velocity.x; 
        this.y += this.velocity.y;

        this.draw();

        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
} 

let particles = new Array();

canvas.addEventListener('click', (e)=>{
    let particlesCount = 1;

    for(let i = 0; i < particlesCount; i++){
        let x = e.offsetX;
        let y = e.offsetY;
        let cl = 'red';
        let velocity = {
            x: 1,
            y: 1
        }
        let r = 10;

        particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
            if(data[i] / 255 < 0.09){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<Style>
.blk{
    background-color: black;
}
</Style>

<canvas class="canvvaas blk" id="canvvaas6"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas6');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let mouse = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
        }

        draw(){
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 1;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = 'red';
            let velocity = {
                x: 1,
                y: 1
            }
            let r = 10;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>I now have to <Span>make the particles move towards all directions</span>, something that isn't 
hard to do, because we already have kind of done the same thing before in 
<Span>circular motions section</span>. So, whenever we <Span>click</span> 
we want to get <Span>some point along a circle's edge</Span>, and to get 
that we are going to use <Span>Math.sin()</span> and 
<Span>Math.con()</Span> functions, which are always gonna give 
us a <span>value between -1 and 1</span> but are <Span>related to one another</span>. 
If we were to <span>continuously icrease a number</span> and 
pass it in <Span>Math.sin()</Span> and <Span>Math.cos()</Span>, if 
we used the <Span>value returned from Math.sin() for our y point</Span>
and the <Span>value returned from Math.con() for our x point</Span> 
we would form up a <Span>circle</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas7');
let c = canvas.getContext('2d');

<Span class="gray">// sets the center of the circle</Span>
let Xoffset = canvas.width / 2;
let Yoffset = canvas.height / 2;
<span class="gray">// sets the radius</span>
let distance = 50;

for(let i = 1; i < 400; i++){
    c.beginPath();
    c.arc(Xoffset + Math.cos(i) * distance, Yoffset + Math.sin(i) * distance, 5, 0, Math.PI * 2);
    c.fill();
    c.stroke();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas7"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas7');
    let c = canvas.getContext('2d');

    let Xoffset = canvas.width / 2;
    let Yoffset = canvas.height / 2;
    let distance = 50;

    for(let i = 1; i < 400; i++){
        c.beginPath();
        c.arc(Xoffset + Math.cos(i) * distance, Yoffset + Math.sin(i) * distance, 5, 0, Math.PI * 2);
        c.fill();
        c.stroke();
    }
}
</script>

<p>As you can see the <Span>arcs</Span> are <Span>forming a circle</span>, 
however, this only happens because the <Span>arcs are enough</Span>, 
what if we only had <Span>3 circles</Span>? </p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaass1');
let c = canvas.getContext('2d');

let Xoffset = canvas.width / 2;
let Yoffset = canvas.height / 2;
let distance = 50;

for(let i = 0; i < 3; i++){
    c.beginPath();
    c.arc(Xoffset + Math.cos(i) * distance, Yoffset + Math.sin(i) * distance, 5, 0, Math.PI * 2);
    c.fill();
    c.stroke();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaass1"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaass1');
    let c = canvas.getContext('2d');

    let Xoffset = canvas.width / 2;
    let Yoffset = canvas.height / 2;
    let distance = 50;

    for(let i = 0; i < 3; i++){
        c.beginPath();
        c.arc(Xoffset + Math.cos(i) * distance, Yoffset + Math.sin(i) * distance, 5, 0, Math.PI * 2);
        c.fill();
        c.stroke();
    }
}
</script>

<p>As you can see, the <Span>arcs</Span> are kind of going to form 
a <Span>circle</span>, however they aren't enough to close the circle,
in order to <Span>evenly space the arcs</Span> we are gonna 
need to first <Span>devide the circle (Math.PI * 2)</Span>
with the <Span>number of arcs</Span>, and then <span>multiple the number we get</span>
with <Span>i</Span> in <Span>every iteration</Span> inside <Span>Math.sin()</Span>
and <Span>Math.cos()</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaass2');
    let c = canvas.getContext('2d');

    let Xoffset = canvas.width / 2;
    let Yoffset = canvas.height / 2;
    let distance = 50;

    let particlesCount = 3;
    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < particlesCount; i++){
        c.beginPath();
        c.arc(Xoffset + Math.cos(angleIncrement * i) * distance, Yoffset + Math.sin(angleIncrement * i) * distance, 5, 0, Math.PI * 2);
        c.fill();
        c.stroke();
    }
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaass2"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaass2');
    let c = canvas.getContext('2d');

    let Xoffset = canvas.width / 2;
    let Yoffset = canvas.height / 2;
    let distance = 50;

    let particlesCount = 3;
    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < 3; i++){
        c.beginPath();
        c.arc(Xoffset + Math.cos(angleIncrement * i) * distance, Yoffset + Math.sin(angleIncrement * i) * distance, 5, 0, Math.PI * 2);
        c.fill();
        c.stroke();
    }
}
</script>

<p>So, what exactly did I do? We know that <Span>Math.PI * 2</Span>
equals <Span>360 degrees</Span> in <Span>radians</span>, or in other 
words, a <Span>full circle</Span>, if we <Span>devide it by the number of arcs</span> 
it will give us a <Span>number</Span>, that <Span>if multiplied by the number of arcs</Span>
will <Span>have returned a full circle</span>. That's why the 
<Span>arcs</Span> are <Span>forming a circle</Span> with a 
<Span>even space between them</Span>, thus  making sure 
that <Span>arcs will be in all directions</Span>.</p>   

<p>We aren't really gonna need a <Span>radius or center</Span> in our case, 
it's our <span>velocities</span> we need to manipulate, all the <Span>particles</Span>
will <Span>spawn on the place we click</Span>, it's their <span>direction</span>
we need to change:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas8');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl, velocity, previousCoords){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.previousCoords = previousCoords;
    }

    draw(){
        c.strokeStyle = this.cl;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.lineWidth = this.r; 

        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
    }

    update(){
        if(this.previousCoords.x == undefined){
            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }

        this.x += this.velocity.x; 
        this.y += this.velocity.y;

        this.draw();

        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
} 

let particles = new Array();

canvas.addEventListener('click', (e)=>{
    let particlesCount = 50;
<span class="orange">    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < particlesCount; i++){
        let x = e.offsetX;
        let y = e.offsetY;
        let cl = 'red';
        let velocity = {
            x: Math.cos(angleIncrement * i),
            y: Math.sin(angleIncrement * i)
        }
        let r = 10;

        particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
    }
});</span>

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
            if(data[i] / 255 < 0.09){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas8"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas8');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let mouse = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
        }

        draw(){
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 50;
        let angleIncrement = Math.PI * 2 / particlesCount;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = 'red';
            let velocity = {
                x: Math.cos(angleIncrement * i),
                y: Math.sin(angleIncrement * i)
            }
            let r = 10;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>Alright, this creates a pretty nice effect on it self, but it's not 
what I am going for right now, I am actually trying to make 
<span>fireworks</span>, and I would like it if my <span>particles</span>
moved a little more <Span>randomly</Span>, since now they are too synchronized 
with one another, to do that I will simple <Span>multiply velocity.y and velocity.x with 
Math.random()</span>:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let velocity = {
    x: Math.cos(angleIncrement * i) * Math.random(),
    y: Math.sin(angleIncrement * i) * Math.random()
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas10"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas10');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let mouse = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
        }

        draw(){
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 50;
        let angleIncrement = Math.PI * 2 / particlesCount;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = 'red';
            let velocity = {
                x: Math.cos(angleIncrement * i) * Math.random(),
                y: Math.sin(angleIncrement * i) * Math.random()
            }
            let r = 10;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>So, the <span>particles</span> still form a <Span>ring</Span>, but 
their <span>speed has changed</span>, which makes them look a little more 
like <Span>fireworks</Span>, they do are a little slow right now, to 
fix that you can simple <Span>multiple Math.random() with the max speed you want</Span>.</p>

<p>Alright, so now we need to add some <Span>gravity and friction</span> so that 
the <span>fireworks slowly stop moving</span> and <span>fall on the ground</span>, 
this is fairly easy to do, for <span>friction</span> we will set a value of <span>0.99</span>
and <Span>multiple it with velocity.x and velocity.y</Span> to 
<span>slowly decrease their speed</span>, and for <Span>gravity</Span> we 
are <span>simple gonna add a number to velocity.y</span> for each iteration 
to <Span>make the speed increase</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas11');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl, velocity, previousCoords){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.previousCoords = previousCoords;
<Span class="orange">        this.friction = 0.99;
        this.gravity = 0.05;</span>
    }

    draw(){
        c.strokeStyle = this.cl;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.lineWidth = this.r; 

        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
    }

    update(){
        if(this.previousCoords.x == undefined){
            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }

<span class="orange">        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        this.velocity.y += this.gravity;</span>

        this.x += this.velocity.x; 
        this.y += this.velocity.y;

        this.draw();

        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
} 

let particles = new Array();

canvas.addEventListener('click', (e)=>{
    let particlesCount = 50;
    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < particlesCount; i++){
        let x = e.offsetX;
        let y = e.offsetY;
        let cl = 'red';
        let velocity = {
<Span class="orange">            x: Math.cos(angleIncrement * i) * Math.random() * 8,
            y: Math.sin(angleIncrement * i) * Math.random() * 8</span>
        }
        let r = 10;

        particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
            if(data[i] / 255 < 0.09){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas11"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas11');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let mouse = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
            this.friction = 0.99;
            this.gravity = 0.05;
        }

        draw(){
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.velocity.y += this.gravity;

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 50;
        let angleIncrement = Math.PI * 2 / particlesCount;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = 'red';
            let velocity = {
                x: Math.cos(angleIncrement * i) * Math.random() * 8,
                y: Math.sin(angleIncrement * i) * Math.random() * 8
            }
            let r = 10;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>Alright, so now, I want to make it so the <span>fireworks</span> are 
<Span>slowly fading</Span>, and <span>deleted when reached 0 opacity</span>, 
to do that I am gonna add an <Span>alpha property to the particle object</Span>, 
which I will be <Span>decreasing by each animation loop</Span>, and when 
it is <Span>less than zero</Span> I'm going to <Span>remove the particle from the array</Span>, 
the reason I want to remove the <Span>uneeded particles</span> is 
to <Span>improve performance</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas12');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl, velocity, previousCoords){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.previousCoords = previousCoords;
        this.friction = 0.99;
        this.gravity = 0.05;
<Span class="orange">        this.alpha = 1;</span>
    }

    draw(){
<Span class="orange">        c.save();
        c.globalAlpha = this.alpha;</span>
        c.strokeStyle = this.cl;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.lineWidth = this.r; 

        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
<Span class="orange">        c.restore();</span>
    }

    update(){
        if(this.previousCoords.x == undefined){
            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }

        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        this.velocity.y += this.gravity;

        this.x += this.velocity.x; 
        this.y += this.velocity.y;

        this.draw();

<Span class="orange">        this.alpha -= 0.005;</span>

        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
} 

let particles = new Array();

canvas.addEventListener('click', (e)=>{
    let particlesCount = 50;
    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < particlesCount; i++){
        let x = e.offsetX;
        let y = e.offsetY;
        let cl = 'red';
        let velocity = {
            x: Math.cos(angleIncrement * i) * Math.random() * 8,
            y: Math.sin(angleIncrement * i) * Math.random() * 8
        }
        let r = 10;

        particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
            if(data[i] / 255 < 0.09){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

<span class="orange">       particles.forEach((particle, i)=>{
            if(particle.alpha > 0){
                particle.update();
            } else{
                particles.splice(i, 1);
            }
        });</span>
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas12"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas12');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let mouse = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
            this.friction = 0.99;
            this.gravity = 0.05;
            this.alpha = 1;
        }

        draw(){
            c.save();
            c.globalAlpha = this.alpha;
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
            c.restore();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.velocity.y += this.gravity;

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.alpha -= 0.005;

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 50;
        let angleIncrement = Math.PI * 2 / particlesCount;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = 'red';
            let velocity = {
                x: Math.cos(angleIncrement * i) * Math.random() * 8,
                y: Math.sin(angleIncrement * i) * Math.random() * 8
            }
            let r = 10;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle, i)=>{
                if(particle.alpha > 0){
                    particle.update();
                } else{
                    particles.splice(i, 1);
                }
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>It is important to <Span>decrease the alpha property</Span> only
<span>after the draw() method is called</span>, that's because if 
you did that before, then it could <Span>draw the particle once with the 
alpha being less than zero</Span>, and when the <Span>alpha is less than zero</Span>
the <Span>particle becomes visible again</Span>, so the particle would vanish and 
appear again just for a moment before being removed.

<p>Anyway, that's everything, let's now play around with it a little to make 
it look better:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas13');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl, velocity, previousCoords){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.previousCoords = previousCoords;
        this.friction = 0.99;
        this.gravity = 0.05;
        this.alpha = 1;
    }

    draw(){
        c.save();
        c.globalAlpha = this.alpha;
        c.strokeStyle = this.cl;
        c.lineJoin = 'round';
        c.lineCap = 'round';
        c.lineWidth = this.r; 

        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.restore();
    }

    update(){
        if(this.previousCoords.x == undefined){
            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }

        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        this.velocity.y += this.gravity;

        this.x += this.velocity.x; 
        this.y += this.velocity.y;

        this.draw();

        this.alpha -= 0.005;

        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
} 

let particles = new Array();

canvas.addEventListener('click', (e)=>{
    let particlesCount = 200;
    let angleIncrement = Math.PI * 2 / particlesCount;

    for(let i = 0; i < particlesCount; i++){
        let x = e.offsetX;
        let y = e.offsetY;
        let cl = `hsl(${Math.random() * 360}, 50%, 50%`;
        let velocity = {
            x: Math.cos(angleIncrement * i) * Math.random() * 8,
            y: Math.sin(angleIncrement * i) * Math.random() * 8
        }
        let r = 6;

        particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
            if(data[i] / 255 < 0.09){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.fillStyle = 'white';
        c.font = 'normal 25px Arial';
        c.textAlign = 'left';
        c.fillText('Click to make fireworks go boom', 10, 20);

        particles.forEach((particle, i)=>{
            if(particle.alpha > 0){
                particle.update();
            } else{
                particles.splice(i, 1);
            }
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas13"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvvaas13');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let particle = class{
        constructor(x, y, r, cl, velocity, previousCoords){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.previousCoords = previousCoords;
            this.friction = 0.99;
            this.gravity = 0.05;
            this.alpha = 1;
        }

        draw(){
            c.save();
            c.globalAlpha = this.alpha;
            c.strokeStyle = this.cl;
            c.lineJoin = 'round';
            c.lineCap = 'round';
            c.lineWidth = this.r; 

            c.beginPath();
            c.moveTo(this.previousCoords.x, this.previousCoords.y);
            c.lineTo(this.x, this.y);
            c.stroke();
            c.restore();
        }

        update(){
            if(this.previousCoords.x == undefined){
                this.previousCoords.x = this.x;
                this.previousCoords.y = this.y;
            }

            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.velocity.y += this.gravity;

            this.x += this.velocity.x; 
            this.y += this.velocity.y;

            this.draw();

            this.alpha -= 0.005;

            this.previousCoords.x = this.x;
            this.previousCoords.y = this.y;
        }
    } 

    let particles = new Array();

    canvas.addEventListener('click', (e)=>{
        let particlesCount = 200;
        let angleIncrement = Math.PI * 2 / particlesCount;

        for(let i = 0; i < particlesCount; i++){
            let x = e.offsetX;
            let y = e.offsetY;
            let cl = `hsl(${Math.random() * 360}, 50%, 50%`;
            let velocity = {
                x: Math.cos(angleIncrement * i) * Math.random() * 8,
                y: Math.sin(angleIncrement * i) * Math.random() * 8
            }
            let r = 6;

            particles.push(new particle(x, y, r, cl, velocity, {x: undefined, y: undefined}));
        }
    });

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] = data[i] * 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] = data[i] * 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            c.fillStyle = 'white';
            c.font = 'normal 25px Arial';
            c.textAlign = 'left';
            c.fillText('Click to make fireworks go boom', 10, 20);

            particles.forEach((particle, i)=>{
                if(particle.alpha > 0){
                    particle.update();
                } else{
                    particles.splice(i, 1);
                }
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</script>

<p>This, and most of the things I have written about <span>canvas</span> 
are all taken from the <Span>Chris's canvas course</Span>, there do are some differences 
between our code, in some sections, in this there wasn't really anything to change, 
I only created the <Span>trail effect</Span> differently so that I can use it with 
<Span>transparent backgrounds</span> if I want to, anyway, here is his video, the guy 
is a really good teacher and taught me to use the <Span>canvas</Span>
so support him if you can:</p>

<iframe src="https://www.youtube.com/embed/R_CnWF3a_ks?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="twentyone">
    <header>
        <h1>How to make a light saber</h1>
    </header>

<p>In this section we are going to create a <Span>light saber</span>, this 
by it self isn't anything incredible, we have created more impressive stuff 
in previous sections, however, understanding how to <Span>rotate the light saber</span>
based on <Span>our mouse position</span> is something we are gonna learn, which 
is very useful to know since getting <Span>vector angle</span> is something that 
is used quite a lot. </p>

<p>Except from that we are also gonna learn a new <Span>package</span>, 
but I will speak more about it later. Let's now begin by creating 
the <Span>basic structure</span> of our <Span>light saber</span>:</p>

<p class = "left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas14');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let center = {
    x: canvas.width / 2,
    y: canvas.height / 2
}

let mouse = {
    x: center.x,
    y: center.y 
}

let particle = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.save();
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.restore();
    }

    update(){
        this.draw();
    }
}

let particles = new Array();

let int = function(){
<span class="orange">    let particleCount = 110;
    let colorsIncrement = 360 / particleCount;</span>

    for(let i = 0; i < particleCount; i++){
<span class="orange">        let x = center.x + i;
        let y = center.y + i;</span>
        let r = 5;
<Span class="orange">        let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`</span>
        particles.push(new particle(x, y, r, cl));
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] *= 0.9;
            if(data[i] / 255 < 0.09){
                data[i] *= 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
int();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas14"></canvas>   

<script>
if(true){
    let canvas = document.querySelector('#canvvaas14');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let center = {
        x: canvas.width / 2,
        y: canvas.height / 2
    }

    let mouse = {
        x: center.x,
        y: center.y 
    }

    let particle = class{
        constructor(x, y, r, cl){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
        }

        draw(){
            c.save();
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.restore();
        }

        update(){
            this.draw();
        }
    }

    let particles = new Array();

    let int = function(){
        let particleCount = 110;
        let colorsIncrement = 360 / particleCount;

        for(let i = 0; i < particleCount; i++){
            let x = center.x + i;
            let y = center.y + i;
            let r = 5;
            let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
            particles.push(new particle(x, y, r, cl));
        }
    }

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 3; i < data.length; i += 4){
                data[i] *= 0.9;
                if(data[i] / 255 < 0.09){
                    data[i] *= 0;
                }
            }
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.putImageData(imageData, 0, 0);

            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
    int();
}
</script>

<p>Alright, so, most of the code is just <Span>some basic preperations</span>, stuff I have already 
talked about in the past, I did mark two things however that I would like to explain. In 
order to create the <Span>light saber</span> I am being using <span>arcs</span>, to 
define their <Span>x and y positions</span> I am using this line of code: <Span>x = center.x + i</span>
and <span>y = center.y + i</span>, 
this means, <Span>starting from the center of the canvas</span>, <Span>each arc</Span> is going 
to be placed <Span>1 pixel horizontally and 1 pixel vertically next to the previous</span>, all the 
<Span>arcs</span> together are forming a big <Span>light saber</span>. Then, I wanted the <Span>light saber</span> 
to be <Span>colorful</span>, however, I wanted it to <Span>contain all colors of the rainbow</Span>, 
to <Span>make sure they all fit</Span> and <Span>are seperated evenly</Span> I <Span>devided 360 with the number of particles</Span>, 
(remember that 360 is the max value for the first parameter of an hsl color format), then I used the <Span>number it returned</span>
in my <Span>for loop</span> to define the <Span>h in hsl color format</Span> which I <span>multiplied by i</span>, 
this means, that <span>by the end of the loop</span> it should have <Span>reached 360</span>, since <span>(360 / particles) * particles = 360</span>,
I hope that makes sense, we actually did something similar in the <Span>previous section</span> when we wanted to 
place the arcs evenly on a circle.</p>

<p>The very next thing we need to do in order to continue is find a way to <Span>get an angle</Span> and
<Span>somehow use that angle to rotate the light saber</span>. To do that, we are gonna need 
to use <Span>Math.sin()</Span> and <span>Math.cos()</span>, if I wanted to find the <Span>x and y positions</span> 
of a <Span>particle</span> that has been <Span>rotated by an angle</span>, to <Span>get the x position</span> 
we would have to do <span>x * Math.cos(angle)</span>, and to <Span>get the y position</span> we would 
have to do <span>y * Math.sin(angle)</span>, so, as we know already, <Span>Math.cos() and Math.sin()</span> 
are <Span>creating a circular motion</Span>, the reason we <span>multiply them by x and y</span> is 
because <span>Math.sin() and Math.cos()</span> will <span>return values between -1 and 1</span>, 
so <Span>x and y define their distance from the center</span>, the <Span>angle</Span> should be 
in <span>radians</span>, let's try <Span>rotating it 180 degrees</span> to see if it works:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let int = function(){
    let particleCount = 130;
    let colorsIncrement = 360 / particleCount;

    for(let i = 0; i < particleCount; i++){
<span class="orange">        let angle = 180;
        let radians = angle * Math.PI / 180;

        let x = center.x + i * Math.cos(radians);
        let y = center.y + i * Math.sin(radians);</span>
        let r = 5;
        let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
        particles.push(new particle(x, y, r, cl));
    }
}</span></p>

<p class="left">Outcome:</p>

    <canvas class="canvvaas blk" id="canvvaas15"></canvas>   

    <script>
    if(true){
        let canvas = document.querySelector('#canvvaas15');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let center = {
            x: canvas.width / 2,
            y: canvas.height / 2
        }
    
        let mouse = {
            x: center.x,
            y: center.y 
        }
    
        let particle = class{
            constructor(x, y, r, cl){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
            }
    
            draw(){
                c.save();
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.restore();
            }
    
            update(){
                this.draw();
            }
        }
    
        let particles = new Array();
    
        let int = function(){
            let particleCount = 130;
            let colorsIncrement = 360 / particleCount;
    
            for(let i = 0; i < particleCount; i++){
                let angle = 180;
                let radians = angle * Math.PI / 180;

                let x = center.x + i * Math.cos(radians);
                let y = center.y + i * Math.sin(radians);
                let r = 5;
                let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
                particles.push(new particle(x, y, r, cl));
            }
        }
    
        function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }
    
        let animate = function(){
            if(isScrolledIntoView(canvas)){
                let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                for(let i = 3; i < data.length; i += 4){
                    data[i] *= 0.9;
                    if(data[i] / 255 < 0.09){
                        data[i] *= 0;
                    }
                }
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.putImageData(imageData, 0, 0);
    
                particles.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }
    
        animate();
        int();
    }
    </script>

<p>Alright, so before we continue something we have to do is
<Span>update our x and y positions</span> for <span>each animation iteration</span>, 
to do that, we are going to <Span>copy the lines that define our x and y in our init function</span>
and <Span>paste them inside our update method</span>. In order to do that however, we are gonna need to also 
<Span>pass the i value to our object</span> so that it can be used inside the <Span>update method</span>, 
therefore we are gonna need to create <Span>one more property</span> to our <span>particle object</span> 
which I will call <Span>distance</span>:
</p>

<P class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas16');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let center = {
    x: canvas.width / 2,
    y: canvas.height / 2
}

let mouse = {
    x: center.x,
    y: center.y, 
<span class="code10">    angle: Math.PI</span>
}

let particle = class{
    constructor(x, y, r, cl, <Span class="orange">distance</span>){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
<Span class="orange">        this.distance = distance;</span>
    }

    draw(){
        c.save();
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.restore();
    }

    update(){
<Span class="orange">        this.x = center.x + this.distance * Math.cos(mouse.angle);
        this.y = center.y + this.distance * Math.sin(mouse.angle);</span>
        this.draw();
    }
}

let particles = new Array();

let int = function(){
    let particleCount = 130;
    let colorsIncrement = 360 / particleCount;

    for(let i = 0; i < particleCount; i++){
        let x = center.x + i * Math.cos(mouse.angle);
        let y = center.y + i * Math.sin(mouse.angle);
        let r = 5;
        let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
        particles.push(new particle(x, y, r, cl, <Span class="orange">i</span>));
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] *= 0.9;
            if(data[i] / 255 < 0.09){
                data[i] *= 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
int();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas16"></canvas>   

    <script>
    if(true){
        let canvas = document.querySelector('#canvvaas16');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let center = {
            x: canvas.width / 2,
            y: canvas.height / 2
        }
    
        let mouse = {
            x: center.x,
            y: center.y, 
            angle: Math.PI
        }
    
        let particle = class{
            constructor(x, y, r, cl, distance){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.distance = distance;
            }
    
            draw(){
                c.save();
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.restore();
            }
    
            update(){
                this.x = center.x + this.distance * Math.cos(mouse.angle);
                this.y = center.y + this.distance * Math.sin(mouse.angle);
                this.draw();
            }
        }
    
        let particles = new Array();
    
        let int = function(){
            let particleCount = 130;
            let colorsIncrement = 360 / particleCount;

            for(let i = 0; i < particleCount; i++){
                let x = center.x + i * Math.cos(mouse.angle);
                let y = center.y + i * Math.sin(mouse.angle);
                let r = 5;
                let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
                particles.push(new particle(x, y, r, cl, i));
            }
        }
    
        function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }
    
        let animate = function(){
            if(isScrolledIntoView(canvas)){
                let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                for(let i = 3; i < data.length; i += 4){
                    data[i] *= 0.9;
                    if(data[i] / 255 < 0.09){
                        data[i] *= 0;
                    }
                }
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.putImageData(imageData, 0, 0);
    
                particles.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }
    
        animate();
        int();
    }
    </script>

<p>All that's left now is to <span>calculate the angle</span>, something I have already talked about 
in my <a href="./../Math-and-Physics-Notes/math1.html">math notes</a>, it's pretty simple, 
since we have <Span>two points</span> we are going to need to <Span>calculate Vx and Vy</span>, 
we know that <Span>Vy equals y2 - y1</span> and <span>Vx equals x2 - x1</span>, then to 
<Span>get the angle</span> of the <Span>vector</span> we will do <Span>Math.atan2(Vy, Vx)</span>,
so simple:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas17');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let center = {
    x: canvas.width / 2,
    y: canvas.height / 2
}

let mouse = {
    x: center.x,
    y: center.y, 
    angle: Math.PI
}

<Span class="orange">canvas.addEventListener('mousemove', (e)=>{
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;

    let Vx = mouse.x - center.x;
    let Vy = mouse.y - center.y;
    let angle = Math.atan2(Vy, Vx);

    mouse.angle = angle;
});</span>

let particle = class{
    constructor(x, y, r, cl, distance){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.distance = distance;
    }

    draw(){
        c.save();
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.restore();
    }

    update(){
        this.x = center.x + this.distance * Math.cos(mouse.angle);
        this.y = center.y + this.distance * Math.sin(mouse.angle);
        this.draw();
    }
}

let particles = new Array();

let int = function(){
    let particleCount = 130;
    let colorsIncrement = 360 / particleCount;

    for(let i = 0; i < particleCount; i++){
        let x = center.x + i * Math.cos(mouse.angle);
        let y = center.y + i * Math.sin(mouse.angle);
        let r = 5;
        let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
        particles.push(new particle(x, y, r, cl, i));
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] *= 0.9;
            if(data[i] / 255 < 0.09){
                data[i] *= 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
int();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas17"></canvas>   

    <script>
    if(true){
        let canvas = document.querySelector('#canvvaas17');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let center = {
            x: canvas.width / 2,
            y: canvas.height / 2
        }
    
        let mouse = {
            x: center.x,
            y: center.y, 
            angle: Math.PI
        }
    
        canvas.addEventListener('mousemove', (e)=>{
            let Vx = e.offsetX - center.x;
            let Vy = e.offsetY - center.y;
            let angle = Math.atan2(Vy, Vx);
            mouse.angle = angle;
        });

        let particle = class{
            constructor(x, y, r, cl, distance){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.distance = distance;
            }
    
            draw(){
                c.save();
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.restore();
            }
    
            update(){
                this.x = center.x + this.distance * Math.cos(mouse.angle);
                this.y = center.y + this.distance * Math.sin(mouse.angle);
                this.draw();
            }
        }
    
        let particles = new Array();
    
        let int = function(){
            let particleCount = 130;
            let colorsIncrement = 360 / particleCount;

            for(let i = 0; i < particleCount; i++){
                let x = center.x + i * Math.cos(mouse.angle);
                let y = center.y + i * Math.sin(mouse.angle);
                let r = 5;
                let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
                particles.push(new particle(x, y, r, cl, i));
            }
        }
    
        function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }
    
        let animate = function(){
            if(isScrolledIntoView(canvas)){
                let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                for(let i = 3; i < data.length; i += 4){
                    data[i] *= 0.9;
                    if(data[i] / 255 < 0.09){
                        data[i] *= 0;
                    }
                }
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.putImageData(imageData, 0, 0);
    
                particles.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }
    
        animate();
        int();
    }
    </script>

<p>This works, however, I would like it if it was a little <Span>smoother</span>, 
if it <Span>did not directly follow the mouse</span>, it it had a <Span>dragging effect</span>, 
to make that happen, I am going to use a <Span>package</span> called 
<Span>gsap</span>, and what it basically does, is that <Span>instead of setting the x and y positions of our mouse</span>, 
it can <span>slowly increase or decrease</span> the <Span>x and y values</span> 
to make the animation smoother.</p>

<p>So, as always, I will <span>install gsap</span>, I will then 
<Span>write the code in an external JavaScript file</span> which 
I will <Span>bundle with parcel</span> and I will <Span>link the bundled file to this page</span>, 
the <Span>bundled file then</span> is going to <span>automatically be updated by parcel</span> whenever
I <Span>update the original JS file</span>, I have already talked about 
how <span>parcel and npm</span> work in <a href="./../Extra-Notes/extranotes1.html">my extra notes</a>, 
so check these out for more information, here is the code:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">import gsap from 'gsap';

let canvas = document.querySelector('#canvvaas18');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let center = {
    x: canvas.width / 2,
    y: canvas.height / 2
}

let mouse = {
    x: center.x,
    y: center.y,
    angle: 0
}

<span class="orange">canvas.addEventListener('mousemove', (e)=>{
    gsap.to(mouse, {
        x: e.offsetX - center.x,
        y: e.offsetY - center.y,
        duration: 1
    });

    let angle = Math.atan2(mouse.y, mouse.x);
    mouse.angle = angle;
});</span>

let particle = class{
    constructor(x, y, r, cl, distance){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.distance = distance;
    }

    draw(){
        c.save();
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.restore();
    }

    update(){
        this.x = center.x + this.distance * Math.cos(mouse.angle);
        this.y = center.y + this.distance * Math.sin(mouse.angle);
        this.draw();
    }
}

let particles = new Array();

let int = function(){
    let particleCount = 130;
    let colorsIncrement = 360 / particleCount;

    for(let i = 0; i < particleCount; i++){
        let x = center.x + i * Math.cos(mouse.angle);
        let y = center.y + i * Math.sin(mouse.angle);
        let r = 6;
        let cl = `hsl(${colorsIncrement * i}, 50%, 50%)`
        particles.push(new particle(x, y, r, cl, i));
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] *= 0.9;
            if(data[i] / 255 < 0.09){
                data[i] *= 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
int();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas blk" id="canvvaas18"></canvas>   

<script src="./../CSS-JavaScript-External-Files/dat/canvas/canvas3.js"></script>

<p>So, what it basically does is that 
it <Span>increases mouse.x and mouse.y</span> every 
<span>1 second</span>, I didn't create <Span>vectors variables</span> 
this time, since I could directly set the <Span>vector points on 
my mouse.x and mouse.y</span>, before I just did that 
differently so that you can easier understand what's going on. 
Anyway, as you can see the 
<Span>light saber</span> is being more smooth than before now, 
here is a tutorial if you need more help with the project:</p>

<iframe src="https://www.youtube.com/embed/kaIT3T4a5YU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="twentytwo">
    <header>
        <h1>Torn-Like Particle Tunnels</h1>
    </header>
    <p>In this section I am gonna make a 
    simple project, nothing too hard, we 
    are gonna use knowledge gained from the 
    <Span>circular movements</span> section but 
    also from the <Span>firewords section</Span>, 
    and we are gonna create a nice <Span>mouse effect</Span>.
    </p>

    <p>Alright, let's get started then:</p>

    <p class="left">JavaScript Code:</p>

    <p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaass3');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let mouse = {
    x: -9999,
    y: -9999
}

canvas.addEventListener('mousemove', (e)=>{
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

let particle = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.ttl = 100;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
    }

    update(){
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.ttl -= 1;
        this.draw();
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let particles = new Array();

let generator = function(){
    let particlesCount = 50;
    let angleIncrement = Math.PI * 2 / particlesCount;
    for(let i = 0; i < particlesCount; i++){
        if(isScrolledIntoView(canvas)){
            let x = mouse.x;
            let y = mouse.y;
            let r = 5;
            let cl = 'red';
            let velocity = {
                x: Math.cos(angleIncrement * i) * 5,
                y: Math.sin(angleIncrement * i) * 5
            }
            particles.push(new particle(x, y, r, cl, velocity));
        }
    }
    setTimeout(generator, 300);
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle, i)=>{
            if(particle.ttl > 0){
                particle.update();
            } else {
                particles.splice(i, 1);
            }
        });
    }
    requestAnimationFrame(animate);
}

generator();
animate();</Span></p>

    <p class="left">Outcome:</p>

    <canvas class="canvvaas" id="canvvaass3"></canvas>

    <script>
        if(true){
            let canvas = document.querySelector('#canvvaass3');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let mouse = {
                x: -9999,
                y: -9999
            }

            canvas.addEventListener('mousemove', (e)=>{
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            let particle = class{
                constructor(x, y, r, cl, velocity){
                    this.x = x;
                    this.y = y;
                    this.r = r;
                    this.cl = cl;
                    this.velocity = velocity;
                    this.ttl = 100;
                }

                draw(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.fill();
                    c.stroke();
                }

                update(){
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.ttl -= 1;
                    this.draw();
                }
            }

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                return isVisible;
            }

            let particles = new Array();

            let generator = function(){
                let particlesCount = 50;
                let angleIncrement = Math.PI * 2 / particlesCount;
                for(let i = 0; i < particlesCount; i++){
                    if(isScrolledIntoView(canvas)){
                        let x = mouse.x;
                        let y = mouse.y;
                        let r = 5;
                        let cl = 'red';
                        let velocity = {
                            x: Math.cos(angleIncrement * i) * 5,
                            y: Math.sin(angleIncrement * i) * 5
                        }
                        particles.push(new particle(x, y, r, cl, velocity));
                    }
                }
                setTimeout(generator, 300);
            }

            let animate = function(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle, i)=>{
                        if(particle.ttl > 0){
                            particle.update();
                        } else {
                            particles.splice(i, 1);
                        }
                    });
                }
                requestAnimationFrame(animate);
            }

            generator();
            animate();
        }
    </script>

    <p>So, to make the <span>ring effect</span> I'm 
    using <Span>Math.sin()</span> and <Span>Math.cos()</span>, 
    exactly the same way I did in the <Span>fireworks section</span>,
    so I'm not going to go in more details about this. Something 
    new I have added to the code is the <Span>generator function</span>, 
    which <span>generates new particles every 300 miliseconds</span>, 
    I have also added to the <span>particles</span> a 
    <span>time to live property</span>, called <Span>tlt</span>, 
    so that I can <Span>delete them after a specific time has passed</span>,
    if I did not then the browser would eventually crash.</p>

    <p>To finish, I am going to add some <Span>effects</span> 
    and play around with it a little to make something beautiful, 
    I will make a <Span>trail effect</span>, make <Span>colors change</span> 
    and I may change the speed and other stuff as well:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaass4');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let mouse = {
    x: -9999,
    y: -9999
}

canvas.addEventListener('mousemove', (e)=>{
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

let particle = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.ttl = 100;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
    }

    update(){
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.ttl -= 1;
        this.draw();
    }
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let particles = new Array();
let increment = 0;

let generator = function(){
    let particlesCount = 50;
    let angleIncrement = Math.PI * 2 / particlesCount;
    let color = `hsl(${Math.abs(Math.sin(increment) * 360)}, 50%, 50%)`;
    for(let i = 0; i < particlesCount; i++){
        if(isScrolledIntoView(canvas)){
            let x = mouse.x;
            let y = mouse.y;
            let r = 5;
            let cl = color;
            let velocity = {
                x: Math.cos(angleIncrement * i) * 5,
                y: Math.sin(angleIncrement * i) * 5
            }
            particles.push(new particle(x, y, r, cl, velocity));
        }
    }
    increment += 2;
    setTimeout(generator, 300);
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i+=4){
            data[i] *= 0.7;
            if(data[i] / 255 < 0.09){
                data[i] *= 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle, i)=>{
            if(particle.ttl > 0){
                particle.update();
            } else {
                particles.splice(i, 1);
            }
        });
    }
    requestAnimationFrame(animate);
}

generator();
animate();</span></p>

<p class="left">Outcome:</p>

    <canvas class="canvvaas" id="canvvaass4" style="background-color: black"></canvas>

    <script>
        if(true){
            let canvas = document.querySelector('#canvvaass4');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let mouse = {
                x: -9999,
                y: -9999
            }

            canvas.addEventListener('mousemove', (e)=>{
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            let particle = class{
                constructor(x, y, r, cl, velocity){
                    this.x = x;
                    this.y = y;
                    this.r = r;
                    this.cl = cl;
                    this.velocity = velocity;
                    this.ttl = 100;
                }

                draw(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.fill();
                }

                update(){
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.ttl -= 1;
                    this.draw();
                }
            }

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                return isVisible;
            }

            let particles = new Array();
            let increment = 0;

            let generator = function(){
                let particlesCount = 50;
                let angleIncrement = Math.PI * 2 / particlesCount;
                let color = `hsl(${Math.abs(Math.sin(increment) * 360)}, 50%, 50%)`;
                for(let i = 0; i < particlesCount; i++){
                    if(isScrolledIntoView(canvas)){
                        let x = mouse.x;
                        let y = mouse.y;
                        let r = 5;
                        let cl = color;
                        let velocity = {
                            x: Math.cos(angleIncrement * i) * 5,
                            y: Math.sin(angleIncrement * i) * 5
                        }
                        particles.push(new particle(x, y, r, cl, velocity));
                    }
                }
                increment += 2;
                setTimeout(generator, 300);
            }

            let animate = function(){
                if(isScrolledIntoView(canvas)){
                    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                    let data = imageData.data;
                    for(let i = 3; i < data.length; i+=4){
                        data[i] *= 0.7;
                        if(data[i] / 255 < 0.09){
                            data[i] *= 0;
                        }
                    }
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    c.putImageData(imageData, 0, 0);

                    particles.forEach((particle, i)=>{
                        if(particle.ttl > 0){
                            particle.update();
                        } else {
                            particles.splice(i, 1);
                        }
                    });
                }
                requestAnimationFrame(animate);
            }

            generator();
            animate();
        }
    </script>

<p>Here is a <Span>tutorial</Span>
that you can use if you need help with the code:
</p>

<iframe src="https://www.youtube.com/embed/5MUsKgU6i0I?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="twentythree">
    <header>
    <h1>Shadow Properties</h1>
    </header>

<p>In this section we are gonna learn about <Span>shadow properties</span>, 
which can be used to create <Span>shadows</Span> and work very similar 
to how <Span>box-shadow CSS property</Span> works.</p>

<p>Before we begin, here is a quick explanation of what each 
of the <Span>shadow properties</Span> do, then we are gonna 
play around with these to better understand them:
</p>

<ul>
    <li><Span>shadowColor = color || hex || rgba()</Span> - sets 
    the color of the shadow</li>
    <li><span>shadowOffsetX = positive or negative number</span> - sets the horizontal offset 
    of the shadow</li>
    <li><span>shadowOffsetY = positive or negative number</span> - sets 
    the vertical offset of the shadow</li>
    <li><span>shadowBlur = blur</span> - can be used to create 
    a blur effect, the higher the number the more blurred the shadow is</li>
</ul>

<p>Alright, I think there isn't anything special about those <Span>properties</span>,
if you know <Span>CSS box-shadow property</Span> then you should already be familiar 
with the way they work, here are some examples:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvv
let ctx = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 330;

ctx.fillStyle = 'red';
ctx.lineWidth = 5;
ctx.strokeStyle = 'red';

function example(x, y, offsetX, offsetY, co
    ctx.shadowOffsetX = offsetX;
    ctx.shadowOffsetY = offsetY;
    ctx.shadowColor = color;
    ctx.shadowBlur = blur;
    ctx.fillRect(x, y, 50, 50)
    ctx.beginPath();
    ctx.arc(x + 100, y + 25, 25, 0, Math.PI
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 140, y + 20);
    ctx.lineTo(x + 180, y + 50);
    ctx.lineTo(x + 160, y);
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 210, y);
    ctx.quadraticCurveTo(x + 250, y + 80, x
    ctx.quadraticCurveTo(x + 300, y - 30, x
    ctx.stroke();
}

example(80, 20, 5, 5, 'rgba(0, 0, 0, 0.6', 
example(80, 100, -5, -5, 'rgba(0, 0, 0, 0.6
example(80, 180, -5, -5, 'blue', 0);
example(80, 260, -5, -5, 'blue', 10);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas19">

<script>
if(true){
    let canvas = document.querySelector('#canvvaas19');
    let ctx = canvas.getContext('2d');
    
    canvas.width = 500;
    canvas.height = 330;

    ctx.fillStyle = 'red';
    ctx.lineWidth = 5;
    ctx.strokeStyle = 'red';

    function example(x, y, offsetX, offsetY, color, blur){
        ctx.shadowOffsetX = offsetX;
        ctx.shadowOffsetY = offsetY;
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;

        ctx.fillRect(x, y, 50, 50)

        ctx.beginPath();
        ctx.arc(x + 100, y + 25, 25, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x + 140, y + 20);
        ctx.lineTo(x + 180, y + 50);
        ctx.lineTo(x + 160, y);
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 210, y);
        ctx.quadraticCurveTo(x + 250, y + 80, x + 280, y);
        ctx.quadraticCurveTo(x + 300, y - 30, x + 340, y + 40)
        ctx.stroke();
    }

    example(80, 20, 5, 5, 'rgba(0, 0, 0, 0.6', 5);
    example(80, 100, -5, -5, 'rgba(0, 0, 0, 0.6', 5);
    example(80, 180, -5, -5, 'blue', 0);
    example(80, 260, -5, -5, 'blue', 10);
}
</script>
</article>

<hr>

<article id="twentyfour">
    <header>
        <h1>Galactic Light Trails</h1>
    </header>

<p>In this section I'm gonna make a cool <Span>galaxy effect</Span>, so, 
there will be a bunch of <Span>stars</Span> around the <Span>canvas</Span>
that will <Span>rotate synchronously</Span>, something we will achieve 
by <Span>rotating the whole canvas</Span> instead of <Span>rotating each individual particle</Span> 
on it's own. We then will also make a nice <Span>trail effect</span> that will 
get <Span>bigger and bigger</Span> when you <Span>hold your mouse down</Span>. Anyway, 
let's start by simple <Span>randomly generating particles</Span> on the <Span>canvas</span>, 
nothing hard about it, we have done this already quite few times in previous sections, 
I will also <Span>randomly generate their width</span> and <Span>color</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas20');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.shadowColor = this.cl;
        c.shadowBlur = 15;
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        this.draw();
    }
}

let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
let particles = new Array();

for(let i = 0; i < 200; i++){
    let r = Math.random() * 3;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 2) + r;
    let cl = colors[Math.floor(Math.random() * colors.length)];
    particles.push(new particle(x, y, r, cl));
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas20" style="background-color: black; border: none"></canvas>

<Script>
if(true){
    let canvas = document.querySelector('#canvvaas20');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let particle = class{
        constructor(x, y, r, cl){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
        }

        draw(){
            c.shadowColor = this.cl;
            c.shadowBlur = 15;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
        }

        update(){
            this.draw();
        }
    }

    let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
    let particles = new Array();

    for(let i = 0; i < 200; i++){
        let r = Math.random() * 3;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new particle(x, y, r, cl));
    }

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle) => {
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</Script>

<p>The <span>black background</span> was made with <Span>CSS</Span>, I also used 
<Span>shadows</Span> to make the <span>stars glow a little</span>. Next thing we 
need to do is make the <span>canvas rotate</span> by using the <span>rotate method</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
<span class="orange">        c.rotate(0.01);</span>
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas21" style="background-color: black; border: none"></canvas>

<Script>
if(true){
    let canvas = document.querySelector('#canvvaas21');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let particle = class{
        constructor(x, y, r, cl){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
        }

        draw(){
            c.shadowColor = this.cl;
            c.shadowBlur = 15;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
        }

        update(){
            this.draw();
        }
    }

    let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
    let particles = new Array();

    for(let i = 0; i < 200; i++){
        let r = Math.random() * 3;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new particle(x, y, r, cl));
    }

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.rotate(0.01);
            particles.forEach((particle) => {
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</Script>

<p>So, for <span>each iteration</span> the <Span>canvas</span> 
is <Span>rotated by 0.01 radians</span>, however, as you can see, 
the <Span>rotation origin is at top left corner of the canvas</span>, 
so we don't get the wanted result, let's try <Span>moving the rotation origin</span>
by using the <Span>translate property</span>:</p>

    <p class="left">JavaScript Code:</p>

<p class="left"><span class="code10"><span class="orange">let increment = 0;</span>

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
<span class="orange">        c.save();
        c.translate(canvas.width / 2, canvas.height / 2);
        c.rotate(increment);</span>
        particles.forEach((particle) => {
            particle.update();
        });
<span class="orange">        c.restore();
        increment += 0.01;</span>
    }
    requestAnimationFrame(animate);
}

animate();</span></p>
    
    <p class="left">Outcome:</p>
    
    <canvas class="canvvaas" id="canvvaas22" style="background-color: black; border: none"></canvas>
    
    <Script>
    if(true){
        let canvas = document.querySelector('#canvvaas22');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let particle = class{
            constructor(x, y, r, cl){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
            }
    
            draw(){
                c.shadowColor = this.cl;
                c.shadowBlur = 15;
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
            }
    
            update(){
                this.draw();
            }
        }
    
        let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
        let particles = new Array();
    
        for(let i = 0; i < 200; i++){
            let r = Math.random() * 3;
            let x = Math.random() * (canvas.width - r * 2) + r;
            let y = Math.random() * (canvas.height - r * 2) + r;
            let cl = colors[Math.floor(Math.random() * colors.length)];
            particles.push(new particle(x, y, r, cl));
        }
    
        function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }
            
        let increment = 0;

        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.save();
                c.translate(canvas.width / 2, canvas.height / 2);
                c.rotate(increment);
                particles.forEach((particle) => {
                    particle.update();
                });
                c.restore();
                increment += 0.01;
            }
            requestAnimationFrame(animate);
        }
    
        animate();
    }
    </Script>

<p>So, I am now using <span>save()</span> and <span>restore()</span>
methods, which <Span>reset the canvas after each iteration</span>, 
that's also why <Span>clearRect()</span> doesn't have 
issues now like it did before.
and because of that we need to use an <Span>incresing number</span> 
in our <span>rotate() method</span> since the <Span>canvas</span> 
is always <Span>rotated back to normal</span> after each frame, that's why I created the 
<Span>increment variable</span>. The <span>translate proprerty</span> 
is <Span>moving the origin to the center of the canvas</span>, 
however, another problem appears beause of that, our 
<Span>particles</span> are <Span>also moved to the right and down</span>, since 
they are <Span>drawn after the origin has changed</span>. 
To fix that, we are gonna change our <Span>x and y randomness range</span>, 
so that <Span>particles</span> can <span>spawn on all places of the canvas</span>.</p>

<p>So, we have <Span>moved the origin to the center</span>, meaning 
<Span>only half of the width</span> and <Span>half of the height</span> 
of the <Span>canvas</span> are needed, we could write
<Span>Math.random() * canvas.width - canvas.width / 2</span>, 
if <Span>Math.random() returned 1</span> then 
the <Span>particle</span> would <Span>spawn half the width of 
the canvas outside our viewport</span>, if we then <Span>substracted 
half of the canvas width</span> then it would <span>spawn right on the edge</span>,
on the other hand, if <Span>Math.random() returned 0</span> then 
the <Span>particle</span> would spawn <Span>exactly over the canvas's origin</span>
which is set to be the <Span>center of the canvas</span>, therefore, 
if we <Span>substract half of the canvas</span> then it will 
<Span>spawn exactly at the left edge of the canvas</span>, this 
should give us exactly the <Span>min-max range</span> we want, 
let's try this:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
let particles = new Array();

for(let i = 0; i < 200; i++){
    let r = Math.random() * 3;
<Span class="orange">    let x = Math.random() * canvas.width - canvas.width / 2;
    let y = Math.random() * canvas.height - canvas.height / 2;</span>
    let cl = colors[Math.floor(Math.random() * colors.length)];
    particles.push(new particle(x, y, r, cl));
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas23" style="background-color: black; border: none"></canvas>
    
<Script>
if(true){
    let canvas = document.querySelector('#canvvaas23');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let particle = class{
        constructor(x, y, r, cl){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
        }

        draw(){
            c.shadowColor = this.cl;
            c.shadowBlur = 15;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
        }

        update(){
            this.draw();
        }
    }

    let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
    let particles = new Array();

    for(let i = 0; i < 200; i++){
        let r = Math.random() * 3;
        let x = Math.random() * canvas.width - canvas.width / 2;
        let y = Math.random() * canvas.height - canvas.height / 2;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new particle(x, y, r, cl));
    }

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }
        
    let increment = 0;

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.save();
            c.translate(canvas.width / 2, canvas.height / 2);
            c.rotate(increment);
            particles.forEach((particle) => {
                particle.update();
            });
            c.restore();
            increment += 0.01;
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</Script>

<p>So, this does is better than before, however, there are still some 
<Span>empty spaces</Span> at the <Span>corners of the canvas</span>, 
and that's because of it's <Span>aspect ratio</span>, it's only logical that 
as it <Span>rotates</Span>, the <Span>corners will be empty</Span>, 
and that's because our <Span>canvas and particles range are of the same width and height</Span>,
we want our <Span>range to be bigger</Span>, so that <Span>even when it rotates</Span>
it can <Span>cover the whole canvas at all angles</Span>, to do that, we are gonna 
<Span>add some pixels to our width and height range</Span>, some <Span>particles</span> 
will <Span>spawn outside the canvas</span> but that's the price we have to pay 
to achieve what we want, in return we can simple <Span>create more particles</span>:

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas24');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.shadowColor = this.cl;
        c.shadowBlur = 15;
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        this.draw();
    }
}

let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
let particles = new Array();

for(let i = 0; i < <Span class="orange">400</span>; i++){
    let r = 0.5 + Math.random() * 2;
<span class="orange">    let canvasWidth = canvas.width + 200;
    let canvasHeight = canvas.height + 200;
    let x = Math.random() * canvasWidth - canvasWidth / 2;
    let y = Math.random() * canvasHeight - canvasHeight / 2;</span>
    let cl = colors[Math.floor(Math.random() * colors.length)];
    particles.push(new particle(x, y, r, cl));
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}
    
let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.save();
        c.translate(canvas.width / 2, canvas.height / 2);
        c.rotate(increment);
        c.fillStyle = 'red';
        particles.forEach((particle) => {
            particle.update();
        });
        c.restore();
<span class="orange">        increment += 0.001;</span>
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas24" style="background-color: black; border: none"></canvas>
    
<Script>
if(true){
    let canvas = document.querySelector('#canvvaas24');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let particle = class{
        constructor(x, y, r, cl){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
        }

        draw(){
            c.shadowColor = this.cl;
            c.shadowBlur = 15;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
        }

        update(){
            this.draw();
        }
    }

    let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
    let particles = new Array();

    for(let i = 0; i < 400; i++){
        let r = 0.5 + Math.random() * 2;
        let canvasWidth = canvas.width + 200;
        let canvasHeight = canvas.height + 200;
        let x = Math.random() * canvasWidth - canvasWidth / 2;
        let y = Math.random() * canvasHeight - canvasHeight / 2;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new particle(x, y, r, cl));
    }

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }
        
    let increment = 0;

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.save();
            c.translate(canvas.width / 2, canvas.height / 2);
            c.rotate(increment);
            c.fillStyle = 'red';
            particles.forEach((particle) => {
                particle.update();
            });
            c.restore();
            increment += 0.001;
        }
        requestAnimationFrame(animate);
    }

    animate();
}
</Script>

<p>This looks fine, all that's left now is to 
create a <Span>trial effect</span> that 
<span>turns on when you click and hold over the canvas</span>
and <Span>turns off when you release the click</span>:</p>

<p class="left">JavaScript Code:</p>
<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas25');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let particle = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.shadowColor = this.cl;
        c.shadowBlur = 15;
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        this.draw();
    }
}

let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
let particles = new Array();

for(let i = 0; i < 400; i++){
    let r = 0.5 + Math.random() * 2;
    let canvasWidth = canvas.width + 200;
    let canvasHeight = canvas.height + 200;
    let x = Math.random() * canvasWidth - canvasWidth / 2;
    let y = Math.random() * canvasHeight - canvasHeight / 2;
    let cl = colors[Math.floor(Math.random() * colors.length)];
    particles.push(new particle(x, y, r, cl));
}

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

<Span class="orange">let mouseDown = false;

canvas.addEventListener('mousedown', (e)=>{
    mouseDown = true;
});

window.addEventListener('mouseup', (e)=>{
    mouseDown = false;
});

canvas.addEventListener('touchstart', (e)=>{
    mouseDown = true;
});

window.addEventListener('touchend', (e)=>{
    mouseDown = false;
});</span>

let increment = 0;
<span class="orange">let alpha = 0;
let speed = 0.001;</span>

let animate = function(){
    if(isScrolledIntoView(canvas)){
<span class="orange">        if(mouseDown){
            if(alpha < 0.94){
                alpha += 0.005;
            } else {
                alpha = alpha;
            }

            if(speed < 0.01){
                speed += 0.0001;
            } else {
                speed = speed;
            }
        } else {
            if(alpha > 0){
                alpha -= 0.005;
            } else{
                alpha = 0;
            } 

            if(speed > 0.001){
                speed -= 0.0001;
            } else {
                speed = 0.001;
            }
        }

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] *= alpha;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);</span>

        c.save();
        c.translate(canvas.width / 2, canvas.height / 2);
        c.rotate(increment);
        c.fillStyle = 'red';
        particles.forEach((particle) => {
            particle.update();
        });
        c.restore();
<Span class="orange">        increment += speed;</span>
    }
    requestAnimationFrame(animate);
}

animate();</span></p>
<p class="left">Outcome:</p>

    <canvas class="canvvaas" id="canvvaas25" style="background-color: black; border: none"></canvas>
    
    <Script>
    if(true){
        let canvas = document.querySelector('#canvvaas25');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let particle = class{
            constructor(x, y, r, cl){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
            }
    
            draw(){
                c.shadowColor = this.cl;
                c.shadowBlur = 15;
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
            }
    
            update(){
                this.draw();
            }
        }
    
        let colors = ['#2185C5', '#7ECEFD', '#FFF6E5', '#FF7F66'];
        let particles = new Array();
    
        for(let i = 0; i < 400; i++){
            let r = 0.5 + Math.random() * 2;
            let canvasWidth = canvas.width + 200;
            let canvasHeight = canvas.height + 200;
            let x = Math.random() * canvasWidth - canvasWidth / 2;
            let y = Math.random() * canvasHeight - canvasHeight / 2;
            let cl = colors[Math.floor(Math.random() * colors.length)];
            particles.push(new particle(x, y, r, cl));
        }
    
        function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        let mouseDown = false;

        canvas.addEventListener('mousedown', (e)=>{
            mouseDown = true;
        });

        window.addEventListener('mouseup', (e)=>{
            mouseDown = false;
        });

        canvas.addEventListener('touchstart', (e)=>{
            mouseDown = true;
        });

        window.addEventListener('touchend', (e)=>{
            mouseDown = false;
        });
            
        let increment = 0;
        let alpha = 0;
        let speed = 0.001;
    
        let animate = function(){
            if(isScrolledIntoView(canvas)){
                if(mouseDown){
                    if(alpha < 0.94){
                        alpha += 0.005;
                    } else {
                        alpha = alpha;
                    }

                    if(speed < 0.01){
                        speed += 0.0001;
                    } else {
                        speed = speed;
                    }
                } else {
                    if(alpha > 0){
                        alpha -= 0.005;
                    } else{
                        alpha = 0;
                    } 

                    if(speed > 0.001){
                        speed -= 0.0001;
                    } else {
                        speed = 0.001;
                    }
                }

                let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                for(let i = 3; i < data.length; i += 4){
                    data[i] *= alpha;
                }
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.putImageData(imageData, 0, 0);

                c.save();
                c.translate(canvas.width / 2, canvas.height / 2);
                c.rotate(increment);
                c.fillStyle = 'red';
                particles.forEach((particle) => {
                    particle.update();
                });
                c.restore();
                increment += speed;
            }
            requestAnimationFrame(animate);
        }
    
        animate();
    }
    </Script>

<p>Here is a <span>tutorial</span> if you need more help with the code:</p>

<iframe src="https://www.youtube.com/embed/D_BPilf_F8k?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="twentyfive">
<header>
<h1>How to create a text wrapper in Canvas</h1>
</header>

<p>To <span>wrap text</span> with <Span>HTML5 Canvas</span>, we
can create a <Span>custom function</span> that requires the <span>canvas context</span>, 
a <Span>text string</span>, a <Span>position</span>, a <Span>max width</span> 
and a <Span>line height</span>. The <span>function</span> should use 
the <span>measureText()</span> method of the <Span>canvas context</span> to 
<Span>calculate when the next line should wrap</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas30');
let c = canvas.getContext('2d');

function wrapText(text, x, y, maxWidth, lineHeight){
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++){
        let testLine = line + words[n];
        let metrics = c.measureText(testLine);
        let testWidth = metrics.width;
        if(testWidth > maxWidth){
            c.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        }
        else{
            line = testLine + ' ';
        }
    }
    c.fillText(line, x, y);
}

canvas.width = 500;
canvas.height = 300;
let maxWidth = canvas.width;
let lineHeight = 25;
let x = 15;
let y = 25;
let text = 'All the world \'s a stage, and all the men and 
women merely players. They have their exits and their 
entrances; And one man in his time plays many parts.';
c.font = 'normal 20px Arial';
c.fillStyle = 'red';

wrapText(text, x, y, maxWidth, lineHeight);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas30"></canvas>

<script>
if(true){
let canvas = document.querySelector('#canvvaas30');
let c = canvas.getContext('2d');

function wrapText(text, x, y, maxWidth, lineHeight){
    let words = text.split(' ');
    let line = '';
    for(let n = 0; n < words.length; n++){
        let testLine = line + words[n];
        let metrics = c.measureText(testLine);
        let testWidth = metrics.width;
        if(testWidth > maxWidth){
            c.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        }
        else{
            line = testLine + ' ';
        }
    }
    c.fillText(line, x, y);
}

canvas.width = 500;
canvas.height = 300;
let maxWidth = canvas.width;
let lineHeight = 25;
let x = 15;
let y = 25;
let text = 'All the world \'s a stage, and all the men and women merely players. They have their exits and their entrances; And one man in his time plays many parts.'
c.font = 'normal 20px Arial';
c.fillStyle = 'red';

wrapText(text, x, y, maxWidth, lineHeight);
}
</script>

<p>So, let me explain how that <Span>function</span> works.
It first uses <Span>split</span> to <Span>create an array of all the words</span>
inside the <Span>text</span>, then, it uses a <Span>for loop</span> 
to <Span>loop through each word</span>. So, when the <Span>first words is picked</span>, 
it creates a <Span>testLine</span>, which is created by merging the 
<Span>current line</span> with the <Span>word</span>, then it 
<Span>calculates the width of the testLine</span>, since it's the 
<Span>first word</span>, as expected it <Span>will not be bigger than MaxWidth</span>, 
so the <Span>testLine</span> together with a <Span>space</span> is 
set to be the <Span>line</span>. Now, this continues to happen 
again and again with <span>each word</span>, and the 
<Span>line is filled with more and more words</span> in 
<Span>each iteration</span>, till the <span>testLine has a greater width than maxWidth</span>, 
when that happens, it <span>draws the line</span>, <Span>clears the line variable and add it the next word that didn't fit in line</span>, 
and <Span>increase the y by lineHeight</span>, then the <Span>words iteration continues</span>, 
till <Span>the line again has a greater width than maxWidth</span>, 
and the <Span>same thing happens</span>, at the end, <Span>after the loop</span>, 
since there will be a <Span>line</span> that has not been <Span>drawn</span> yet
I simple use <Span>fillText</span> to draw the line.</p>

</article>

<hr>

<article id="twentysix">
    <header>
        <h1>Creating my first Canvas game</h1>
    </header>

<p>So, it's time to finally put all the knowledge we have gained 
through all those <Span>canvas projects</Span> we have created 
into use and make our first <Span>canvas game</span>. This is 
going to be a simple <Span>shooter game</span>, the <Span>player</span> 
will be an <Span>arc</Span>, he will be able to <Span>shoot particles</span>, 
and there will be <Span>enemies coming towards him</Span>, that's the basic idea.
</p>

<p>First thing we are gonna do is <Span>create our player</Span>, 
we are gonna use a simple <Span>arc</Span> for the <Span>player's model</span>, 
to keep things simple, but you can also use
<Span>images</Span> if you want a drawn character, in that 
case however you would probably want to also create 
a <Span>seperate hit box</Span> to be <Span>used as a way 
to detect collisions</span>, I recommend to use an <Span>arc</Span> because 
<Span>it's easier to detect collisions on arcs</span>, but it could be 
a <Span>rectangle</Span> too, you could also add 
<Span>multiple hit boxes</span> on the <Span>player</span> for
<Span>more complex shapes</span>, it's up to you, for my game I am going 
to use the <span>player him self to detect collision</span>, because he 
will be an <Span>arc</Span> him self. Anyway, here 
is our player:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas26');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 500;

let playerMaker = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        if(keys.up){
            if(this.y - this.r > 0){
                this.y -= 1;
            }
        } 
        if(keys.down){
            if(this.y < canvas.height - this.r){
                this.y += 1;
            }
        }
        if(keys.right){
            if(this.x < canvas.width - this.r){
                this.x += 1;
            }
        }
        if(keys.left){
            if(this.x - this.r > 0){
                this.x -= 1;
            }
        }
        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

let player = new playerMaker(Cwidth/2, Cheight/2, 10, 'green');

let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

function animate(){
    c.clearRect(0, 0, Cwidth, Cheight);
    player.update();
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas26"></canvas>

<script>
if(true){
let canvas = document.querySelector('#canvvaas26');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 500;

let playerMaker = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        if(keys.up){
            if(this.y - this.r > 0){
                this.y -= 1;
            }
        } 
        if(keys.down){
            if(this.y < canvas.height - this.r){
                this.y += 1;
            }
        }
        if(keys.right){
            if(this.x < canvas.width - this.r){
                this.x += 1;
            }
        }
        if(keys.left){
            if(this.x - this.r > 0){
                this.x -= 1;
            }
        }
        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

let player = new playerMaker(Cwidth/2, Cheight/2, 10, 'green', {x: 0, y: 0});

let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

function animate(){
    c.clearRect(0, 0, Cwidth, Cheight);
    player.update();
    requestAnimationFrame(animate);
}

animate();

}
</script>

<p>So, I created the <Span>player</span>, and also 
made him <Span>moveable</span>, to do that I used the <Span>onkeydown event</span>,
by checking the <Span>event's object</span> you can 
read the <Span>keyCode</span>, I found out the <Span>key codes</span>
for the <Span>arrow keys</span> and <Span>wasd keys</span> 
and made them so that they <Span>change up, left, right, down properties</span> 
of <Span>keys object</span> to <Span>true, depending on the key</span>, 
and <Span>back to false when key is released</span>. With that 
I then made it so inside the <span>update method</span> it 
<Span>checks if any of the keys are being pressed</span> so that 
the <Span>player's (x, y) positions can change accordently</span>.
To finish I added some simple <Span>collision code</span> that 
checks if the <Span>player is inside the canvas</span> so that 
the <Span>player cannot move outside the canvas</span>.</p>

<p>Next thing we are gonna need to do is make 
it so that the <Span>player</span> can 
<span>shoot particles</span> towards where the 
<Span>cursor is when the mouse is clicked</span>,  
let's do this:
</p>

<style>
    .grey{
        background-color: lightgray;
        font-weight: bold;
    }
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvvaas27');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 500;

<span class="grey">// code for the player</span>

let playerMaker = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        if(keys.up){
            if(this.y - this.r > 0){
                this.y -= 1;
            }
        } 
        if(keys.down){
            if(this.y < canvas.height - this.r){
                this.y += 1;
            }
        }
        if(keys.right){
            if(this.x < canvas.width - this.r){
                this.x += 1;
            }
        }
        if(keys.left){
            if(this.x - this.r > 0){
                this.x -= 1;
            }
        }
        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

let player = new playerMaker(Cwidth/2, Cheight/2, 10, 'green');

let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

<span class="grey">// code for the bullets</span>

<span class="orange">let bullet = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        console.log(this.x);
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.draw();
    }
}

let bullets = new Array();
let mousedown = false;

let mouse = {
    x: 0,
    y: 0
}

canvas.addEventListener('mousemove', (e)=>{
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mousedown', (e)=>{
    e.preventDefault();
    mousedown = true;
    let interval = setInterval(()=>{
        let r = 5;
        let cl = 'red'
        let x = player.x;
        let y = player.y;
        let vx = mouse.x - x;
        let vy = mouse.y - y;
        let angle = Math.atan2(vy, vx);
        let velocity = {
            x: Math.cos(angle) * 4,
            y: Math.sin(angle) * 4
        }
        bullets.push(new bullet(x, y, r, cl, velocity));
    }, 200);
    let interval2 = setInterval(()=>{
        if(mousedown == false){
            clearInterval(interval);
            clearInterval(interval2);
        }
    }, 1);
});

window.addEventListener('mouseup', (e)=>{
    mousedown = false;
});</span>

function animate(){
    c.clearRect(0, 0, Cwidth, Cheight);
    player.update();
<span class="orange">    bullets.forEach((bullet, i)=>{
        bullet.update();
        if(bullet.x - bullet.r < 0 |
        bullet.x > Cwidth - bullet.r |
        bullet.y - bullet.r < 0 |
        bullet.y > Cheight - bullet.r){
            bullets.splice(i, 1);
        }
    });</span>
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas27"></canvas>

<script>
if(true){
let canvas = document.querySelector('#canvvaas27');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 500;

// code for the player 

let playerMaker = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        if(keys.up){
            if(this.y - this.r > 0){
                this.y -= 1;
            }
        } 
        if(keys.down){
            if(this.y < canvas.height - this.r){
                this.y += 1;
            }
        }
        if(keys.right){
            if(this.x < canvas.width - this.r){
                this.x += 1;
            }
        }
        if(keys.left){
            if(this.x - this.r > 0){
                this.x -= 1;
            }
        }
        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

let player = new playerMaker(Cwidth/2, Cheight/2, 10, 'green');

let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

// code for the bullets 

let bullet = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
    }

    update(){
        console.log(this.x);
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.draw();
    }
}

let bullets = new Array();
let mousedown = false;

let mouse = {
    x: 0,
    y: 0
}

canvas.addEventListener('mousemove', (e)=>{
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mousedown', (e)=>{
    e.preventDefault();
    mousedown = true;
    let interval = setInterval(()=>{
        let r = 5;
        let cl = 'red'
        let x = player.x;
        let y = player.y;
        let vx = mouse.x - x;
        let vy = mouse.y - y;
        let angle = Math.atan2(vy, vx);
        let velocity = {
            x: Math.cos(angle) * 4,
            y: Math.sin(angle) * 4
        }
        bullets.push(new bullet(x, y, r, cl, velocity));
    }, 200);
    let interval2 = setInterval(()=>{
        if(mousedown == false){
            clearInterval(interval);
            clearInterval(interval2);
        }
    }, 1);
});

window.addEventListener('mouseup', (e)=>{
    mousedown = false;
});
function animate(){
    c.clearRect(0, 0, Cwidth, Cheight);
    player.update();
    bullets.forEach((bullet, i)=>{
        bullet.update();
        if(bullet.x - bullet.r < 0 |
        bullet.x > Cwidth - bullet.r |
        bullet.y - bullet.r < 0 |
        bullet.y > Cheight - bullet.r){
            bullets.splice(i, 1);
        }
        console.log(bullets);
    });
    requestAnimationFrame(animate);
}

animate();

}
</script>

<p>So, while the <Span>cursor</span> is 
<Span>moving over the canvas</span>, I 
am <Span>saving the cursor's coordinates</span> 
inside the <span>mouse object</span>. When the 
<Span>mouse button is pushed down</span> I 
<Span>set an interval</span> 
that <span>creates and adds new bullets in the bullets array</span>. 
The <Span>x and y values of the bullets</span> are the 
<Span>player's x and y position</span> since I want them 
to <Span>spawn at the center of the player</span>, 
then I calculate the <span>x and y values of the vector formed 
from the center of the player and our cursor's position</span> and 
use them on <Span>Math.atan2() method</span> to get 
the <Span>angle in radians</span>, I then use this <Span>angle</span>
with <Span>cos and sin</span> to <Span>set the velocities</span>, 
to better understand how this works I recommend you 
check out my <Span>previous sections</span>, more specifically, 
you can check out <span>circular motions</span>, <span>how to make fireworks</span>, 
<Span>light saber</span> and <Span>particle tunnels</span>. 
</p>

<p>Anyway, I also created a <Span>second interval</span>, 
which however <Span>loops every 1 milesecond</span> and checks 
wether <Span>mouseDown is true or false</span> if it's 
<Span>false</span> then it <Span>stops both intervals</span>, 
we <Span>set mouseDown to true</span> when <Span>mouse button is pushed</span>
and <Span>set it back to false</span> when <Span>mouse button is released</span>.</p>

<p>Last thing I did was to <Span>check if bullet is inside the canvas</span>
every time I <Span>update it</span>, so that <span>when a bullet leaves the viewport</span> 
I can <Span>remove it from the array</span>, I do this for 
<Span>performance reasons</span>.</p>

<p>Next I'm gonna create <Span>enemies</span> and <span>collision between 
the enemies and the player</span>, I want <span>the enemies to collid with each other</span> 
and also <Span>collid with the player</span>, but I want the <span>player to have a bigger mass</span>
so that he can <Span>push the enemies</Span> so that <Span>he doesn't get trapped by them</span>. 
Now, <span>collisions</span> are a little tricky, I have spoken about how to calculate the 
<Span>velocities</span> after <Span>two particles collid</span> in an <Span>earlier section</span>,
and I have even gone deeper into the <Span>sience of elastic collisions</Span> and talked about it 
in my <span>math and physics notes</span> which you can find in the <Span>home page of my notes</span>. 
Anyway, to make <Span>colission between the player and the enemies</Span> we are need to add 
a <Span>velocity to the player</span>, right now we are simple <Span>decreasing or increasing x and y</span>,
but that won't do anymore since we want to <Span>change the velocity after collision happens</span>. 
Here is what the final code looks like, there are a few stuff I made and it took me a while since 
I faced a lot of problems through the process, but I will try to explain what each line of code does:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvvaas26');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 500;

<span class="grey">// function that checks wether element is scrolled into view or not</span>
function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

<span class="orange"><Span class="grey">// event that let us know whether the window is viewed or not</span>
let pageIsViewed = 'unknown';

document.body.onmouseover = (e)=>{
    pageIsViewed = true; 
}

window.addEventListener("visibilitychange", (e)=>{
if(pageIsViewed == true | pageIsViewed == 'unknown'){
    pageIsViewed = false;
} else if(pageIsViewed == false){
    pageIsViewed = true;
}
});

<Span class="grey">// functions that are used to detect collisions

    // constructor used to create hitboxes at the edges of the canvas</span>
    let wall = class{
        constructor(x, y, velocity){
            this.x = x;
            this.y = y;
            this.r = 0;
            this.velocity = {
                x: 0,
                y: 0
            }
            this.mass = 999;
        }
    }

<span class="grey">    // gets the distance between two particles</span>
    let getDistance = function(thisEnemy, otherEnemy){
        let Vx = thisEnemy.x - otherEnemy.x;
        let Vy = thisEnemy.y - otherEnemy.y;
        let distance = Math.hypot(Vx, Vy) - thisEnemy.r - otherEnemy.r;
        return distance;
    }

<span class="grey">    // rotates the axis so that the final velocities can be calculated</span>
    let rotate = function(velocity, angle){
        let rotatedVelocities = {
            x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
            y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
        }
        return rotatedVelocities;
    }

<span class="grey">    // calculates and sets the final velocities after the collision</span>
    let changeVelocity = function(thisParticle, otherParticle){
        let [x1, x2] = [thisParticle.x, otherParticle.x];
        let [y1, y2] = [thisParticle.y, otherParticle.y];
        let [v1, v2] = [thisParticle.velocity, otherParticle.velocity];
        let [m1, m2] = [thisParticle.mass, otherParticle.mass];

        let xVelocityDiff = v1.x - v2.x;
        let yVelocityDiff = v1.y - v2.y;
        let xDist = x2 - x1;
        let yDist = y2 - y1;

        if(xVelocityDiff * xDist + yVelocityDiff * yDist >= 0){
            let angle = -Math.atan2(y2 - y1, x2 - x1);

            let rotatedV1 = rotate(v1, angle);
            let rotatedV2 = rotate(v2, angle);

            let rotatedV1final = {
                x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2),
                y: rotatedV1.y
            }

            let rotatedV2final = {
                x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2),
                y: rotatedV2.y
            }

            let finalV1 = rotate(rotatedV1final, -angle);
            let finalV2 = rotate(rotatedV2final, -angle);

            thisParticle.velocity = finalV1;
            otherParticle.velocity = finalV2;
        }
    }</span>

<span class="grey">// code for the player</span>

let playerMaker = class{
    constructor(x, y, r, cl, <Span class="orange">velocity, mass</span>){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
<Span class="orange">        this.velocity = velocity;
        this.mass = mass;</span>
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
<span class="orange">        c.stroke();</span>
    }

    update(<span class="orange">enemies</span>){

<span class="orange"><span class="grey">        // if key.up is true makes player move up and increases mass</span>
        if(keys.up){
            this.mass = 2.2;
            this.velocity.y = -1.5;
        } 
        
<span class="grey">        // else if key.down is true increases mass but makes player move down</span>
        else if(keys.down){
            this.mass = 2.2;
             this.velocity.y = 1.5;
        }

<span class="grey">        // else if this.collapsed is less than zero it sets mass to 1 and velocity.y to zero</span>
        else if(this.collapsed < 0){
            this.mass = 1;         
            this.velocity.y = 0;
        }

<span class="grey">        // if key.right is true makes player move to right and increases mass</span>
        if(keys.right){
            this.mass = 2.2;
            this.velocity.x = 1.5;
        } 
        
<span class="grey">        // else if keys.left is true increases mass but makes player move to left</span>
        else if(keys.left){
            this.mass = 2.2;
            this.velocity.x = -1.5;
        } 
        
<span class="grey">        // else if this.collapsed is less than zero it sets mass to 1 and velocity.x to zero</span>
        else if(this.collapsed < 0){
            this.velocity.x = 0;
            this.mass = 1;         
        }

        this.collapsed -= 1;

        enemies.forEach((enemy)=>{
            if(getDistance(this, enemy) < 0){
                changeVelocity(this, enemy);
            }
        });

<Span class="grey">        // checks for overlapping</span>
        enemies.forEach((enemy)=>{
            if(getDistance(this, enemy) < -3){
                changeVelocity(this, enemy);
                this.collapsed = 2;
            }
        });

        let rightWall = new wall(canvas.width, this.y)
        let leftWall = new wall(0, this.y);
        let topWall = new wall(this.x, 0);
        let bottomWall = new wall(this.x, canvas.height);

        if(getDistance(this, rightWall) < 0){
            changeVelocity(this, rightWall);
        }

        if(getDistance(this, topWall) < 0){
            changeVelocity(this, topWall);
        }

        if(getDistance(this, leftWall) < 0){
            changeVelocity(this, leftWall);
        }
        
        if(getDistance(this,  bottomWall) < 0){
            changeVelocity(this, bottomWall);
        }

        this.x += this.velocity.x;
        this.y += this.velocity.y;</span>
        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

let player = new playerMaker(Cwidth/2, Cheight/2, 10, <Span class="orange">'orange', {x: 0, y: 0}, 1</span>);

let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

<span class="grey">// code for the bullets</span>

<Span class="grey">    // bullets constructor</span>
    let bullet = class{
        constructor(x, y, r, cl, velocity){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
        }

        draw(){
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
        }

        update(){
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.draw();
        }
    }

<span class="grey">    // bullets generator</span>
    let bullets = new Array();
    let mousedown = false;

    let mouse = {
        x: 0,
        y: 0
    }

    canvas.addEventListener('mousemove', (e)=>{
        mouse.x = e.offsetX;
        mouse.y = e.offsetY;
    });

    canvas.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        mousedown = true;
        let interval = setInterval(()=>{
            let r = <Span class="orange">3</span>;
            let cl = <Span class="orange">'black'</span>;
            let x = player.x;
            let y = player.y;
            let vx = mouse.x - x;
            let vy = mouse.y - y;
            let angle = Math.atan2(vy, vx);
            let velocity = {
                x: Math.cos(angle) * 4,
                y: Math.sin(angle) * 4
            }
            bullets.push(new bullet(x, y, r, cl, velocity));
        }, 200);
        let interval2 = setInterval(()=>{
            if(mousedown == false){
                clearInterval(interval);
                clearInterval(interval2);
            }
        }, 1);
    });
    
    window.addEventListener('mouseup', (e)=>{
        mousedown = false;
    });

<Span class="orange"><span class="grey">// code for enemies</span>

<span class="grey">    // enemies constructor</span>
    let enemie = class{
        constructor(x, y, r, cl, velocity, speed, mass){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.speed = speed;
            this.mass = mass;
            this.collapsed = -1;
            this.enemycollapses = -1;
            this.hasenteredcanvas = false;
        }

        draw(){
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
        }

        update(otherEnemies){
            let vx = player.x - this.x;
            let vy = player.y - this.y;
            let angle = Math.atan2(vy, vx);
            if(this.collapsed < 0 && this.enemycollapses < 0){
                this.velocity.x = Math.cos(angle) * this.speed;
                this.velocity.y = Math.sin(angle) * this.speed;
            } else if(this.collapsed > 0){
                this.velocity.x *= 0;
                this.velocity.y *= 0;
            } 
            this.enemycollapses -= 1;
            this.collapsed -= 1;
            otherEnemies.forEach((enemy)=>{
                if(enemy != this){
                    if(getDistance(this, enemy) < 0){
                        changeVelocity(this, enemy);
                        this.enemycollapses = 0.5;
                    }
                }
            });

            if(getDistance(this, player) < 0){
                changeVelocity(this, player);
                    this.collapsed = 1;
            }

<span class="grey">            // checks for overlapping between enemies</span>
            otherEnemies.forEach((enemy)=>{
                if(enemy != this){
                    if(getDistance(this, enemy) < -3){
                        changeVelocity(this, enemy);
                        this.enemycollapses = 2;
                        this.mass = 2;
                    }
                }
            });

<span class="grey">            // checks for overlapping between player and enemy</span>
            if(getDistance(this, player) < -3){
                changeVelocity(this, player);
                    this.enemycollapses = 2;
                    this.mass = 4;
            }

            let rightWall = new wall(canvas.width, this.y)
            let leftWall = new wall(0, this.y);
            let topWall = new wall(this.x, 0);
            let bottomWall = new wall(this.x, canvas.height);

            if(this.hasenteredcanvas == false){
                if((this.x  - this.r > 0 && this.x + this.r < canvas.width) && 
                (this.y - this.r > 0 && this.y + this.r < canvas.height)){
                    this.hasenteredcanvas = true;
                }
            } else{
                if(getDistance(this, rightWall) < 0){
                    changeVelocity(this, rightWall);
                }

                if(getDistance(this, topWall) < 0){
                    changeVelocity(this, topWall);
                }

                if(getDistance(this, leftWall) < 0){
                    changeVelocity(this, leftWall);
                }

                if(getDistance(this,  bottomWall) < 0){
                    changeVelocity(this, bottomWall);
                }
            }

            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.draw();
        }
    }

<span class="grey">    // enemies generator</span>
    let enemies = new Array();

    setInterval(()=>{
        let r = 10;
        let x, y;
        if(Math.random() < 0.5){
            x = (Math.random() < 0.5)? 0 - r: canvas.width + r;
            y = Math.random() * canvas.height;
        } else{
            x = Math.random() * canvas.width;
            y = (Math.random() < 0.5)? 0 - r: canvas.height + r;
        }
        let cl = 'green';
        let mass = 1.1;
        let velocity = {
            x: 0, 
            y: 0
        }
        let speed = 0.4 + Math.random() 
        let maxEnemies = 10;
        if(enemies.length < maxEnemies){
            if(isScrolledIntoView(canvas) && (pageIsViewed | pageIsViewed == 'unknown')){
                enemies.push(new enemie(x, y, r, cl, velocity, speed, mass));
            }
        }
    }, 4000);</span>

<span class="grey">// the animate function</span>

let animate = function(){
<Span class="orange">    if((pageIsViewed | pageIsViewed == 'unknown') && isScrolledIntoView(canvas)){</span>
        c.clearRect(0, 0, Cwidth, Cheight);
        player.update(<span class="orange">enemies</span>);
<span class="orange">        enemies.forEach((enemy, i)=>{
            enemy.update(enemies);
        });</span>
        bullets.forEach((bullet, i)=>{
            bullet.update();
            if(bullet.x - bullet.r < 0 |
            bullet.x > Cwidth - bullet.r |
            bullet.y - bullet.r < 0 |
            bullet.y > Cheight - bullet.r){
                bullets.splice(i, 1);
            }
        });
<span class="orange">    } else{
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.save();
        c.font = 'normal 24px Arial';
        c.alignText = 'left';
        c.fillStyle = 'black';
        c.fillText('The game is paused', 10, 30);
        c.restore();
    }</span>
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas28"></canvas>

<script>
    if(true){
    let canvas = document.querySelector('#canvvaas28');
    let c = canvas.getContext('2d');
    
    canvas.width = 500;
    canvas.height = 500;
    
    // function that checks wether element is scrolled into view or not
    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }
    
    // event that let us know whether the window is viewed or not
    let pageIsViewed = 'unknown';

    document.body.onmouseover = (e)=>{
            pageIsViewed = true; 
    }

    window.addEventListener("visibilitychange", (e)=>{
        if(pageIsViewed == true | pageIsViewed == 'unknown'){
            pageIsViewed = false;
        } else if(pageIsViewed == false){
            pageIsViewed = true;
        }
    });

    // functions that are used to detect collisions
    
        // constructor used to create hitboxes at the edges of the canvas 
        let wall = class{
            constructor(x, y, velocity){
                this.x = x;
                this.y = y;
                this.r = 0;
                this.velocity = {
                    x: 0,
                    y: 0
                }
                this.mass = 999;
            }
        }
    
        // gets the distance between two particles
        let getDistance = function(thisEnemy, otherEnemy){
            let Vx = thisEnemy.x - otherEnemy.x;
            let Vy = thisEnemy.y - otherEnemy.y;
            let distance = Math.hypot(Vx, Vy) - thisEnemy.r - otherEnemy.r;
            return distance;
        }
    
        // rotates the axis so that the final velocities can be calculated 
        let rotate = function(velocity, angle){
            let rotatedVelocities = {
                x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
            }
            return rotatedVelocities;
        }
    
        // calculates and sets the final velocities after the collision
        let changeVelocity = function(thisParticle, otherParticle){
            let [x1, x2] = [thisParticle.x, otherParticle.x];
            let [y1, y2] = [thisParticle.y, otherParticle.y];
            let [v1, v2] = [thisParticle.velocity, otherParticle.velocity];
            let [m1, m2] = [thisParticle.mass, otherParticle.mass];
    
            let xVelocityDiff = v1.x - v2.x;
            let yVelocityDiff = v1.y - v2.y;
            let xDist = x2 - x1;
            let yDist = y2 - y1;
    
            if(xVelocityDiff * xDist + yVelocityDiff * yDist >= 0){
                let angle = -Math.atan2(y2 - y1, x2 - x1);
    
                let rotatedV1 = rotate(v1, angle);
                let rotatedV2 = rotate(v2, angle);
    
                let rotatedV1final = {
                    x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2),
                    y: rotatedV1.y
                }
    
                let rotatedV2final = {
                    x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2),
                    y: rotatedV2.y
                }
    
                let finalV1 = rotate(rotatedV1final, -angle);
                let finalV2 = rotate(rotatedV2final, -angle);
    
                thisParticle.velocity = finalV1;
                otherParticle.velocity = finalV2;
            }
        }
    
    // code for the player 
    
    let playerMaker = class{
        constructor(x, y, r, cl, velocity, mass){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.mass = mass;
            this.collapsed = -1;
        }
    
        draw(){
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
        }
    
        update(enemies){
    
            // if key.up is true makes player move up and increases mass
            if(keys.up){
                this.mass = 2.2;
                this.velocity.y = -1.5;
            } 
            
            // else if key.down is true increases mass but makes player move down
            else if(keys.down){
                this.mass = 2.2;
                 this.velocity.y = 1.5;
            }

            // else if this.collapsed is less than zero it sets mass to 1 and velocity.y to zero
            else if(this.collapsed < 0){
                this.mass = 1;         
                this.velocity.y = 0;
            }

            // if key.right is true makes player move to right and increases mass
            if(keys.right){
                this.mass = 2.2;
                this.velocity.x = 1.5;
            } 
            
            // else if keys.left is true increases mass but makes player move to left
            else if(keys.left){
                this.mass = 2.2;
                this.velocity.x = -1.5;
            } 
            
            // else if this.collapsed is less than zero it sets mass to 1 and velocity.x to zero
            else if(this.collapsed < 0){
                this.velocity.x = 0;
                this.mass = 1;         
            }
    
            this.collapsed -= 1;
    
            enemies.forEach((enemy)=>{
                if(getDistance(this, enemy) < 0){
                    changeVelocity(this, enemy);
                }
            });
    
            // checks for overlapping
            enemies.forEach((enemy)=>{
                if(getDistance(this, enemy) < -3){
                    changeVelocity(this, enemy);
                    this.collapsed = 2;
                }
            });
    
            let rightWall = new wall(canvas.width, this.y)
            let leftWall = new wall(0, this.y);
            let topWall = new wall(this.x, 0);
            let bottomWall = new wall(this.x, canvas.height);
    
            if(getDistance(this, rightWall) < 0){
                changeVelocity(this, rightWall);
            }
    
            if(getDistance(this, topWall) < 0){
                changeVelocity(this, topWall);
            }
    
            if(getDistance(this, leftWall) < 0){
                changeVelocity(this, leftWall);
            }
    
            if(getDistance(this,  bottomWall) < 0){
                changeVelocity(this, bottomWall);
            }
    
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.draw();
        }
    }
    
    let Cwidth = canvas.width;
    let Cheight = canvas.height;
    
    let player = new playerMaker(Cwidth/2, Cheight/2, 10, 'orange', {x: 0, y: 0}, 1);
    
    let keys = {
        up: false,
        right: false, 
        down: false,
        left: false
    }
    
    addEventListener('keydown', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = true;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = true;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = true;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = true;
        }
    });
    
    addEventListener('keyup', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = false;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = false;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = false;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = false;
        }
    });
    
    // code for the bullets 
    
        // bullets constructor
        let bullet = class{
            constructor(x, y, r, cl, velocity){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
            }
    
            draw(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
            }
    
            update(){
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.draw();
            }
        }
    
        // bullets generator
        let bullets = new Array();
        let mousedown = false;
    
        let mouse = {
            x: 0,
            y: 0
        }
    
        canvas.addEventListener('mousemove', (e)=>{
            mouse.x = e.offsetX;
            mouse.y = e.offsetY;
        });
    
        canvas.addEventListener('mousedown', (e)=>{
            e.preventDefault();
            mousedown = true;
            let interval = setInterval(()=>{
                let r = 3;
                let cl = 'black'
                let x = player.x;
                let y = player.y;
                let vx = mouse.x - x;
                let vy = mouse.y - y;
                let angle = Math.atan2(vy, vx);
                let velocity = {
                    x: Math.cos(angle) * 4,
                    y: Math.sin(angle) * 4
                }
                bullets.push(new bullet(x, y, r, cl, velocity));
            }, 200);
            let interval2 = setInterval(()=>{
                if(mousedown == false){
                    clearInterval(interval);
                    clearInterval(interval2);
                }
            }, 1);
        });
    
        window.addEventListener('mouseup', (e)=>{
            mousedown = false;
        });
    
    // code for enemies
    
        // enemies constructor
        let enemie = class{
            constructor(x, y, r, cl, velocity, speed, mass){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
                this.speed = speed;
                this.mass = mass;
                this.collapsed = -1;
                this.enemycollapses = -1;
                this.hasenteredcanvas = false;
            }
    
            draw(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.stroke();
            }
    
            update(otherEnemies){
                let vx = player.x - this.x;
                let vy = player.y - this.y;
                let angle = Math.atan2(vy, vx);
                if(this.collapsed < 0 && this.enemycollapses < 0){
                    this.velocity.x = Math.cos(angle) * this.speed;
                    this.velocity.y = Math.sin(angle) * this.speed;
                } else if(this.collapsed > 0){
                    this.velocity.x *= 0;
                    this.velocity.y *= 0;
                } 
    
                this.enemycollapses -= 1;
                this.collapsed -= 1;
                this.mass = 1.1;
    
                otherEnemies.forEach((enemy)=>{
                    if(enemy != this){
                        if(getDistance(this, enemy) < 0){
                            changeVelocity(this, enemy);
                            this.enemycollapses = 0.5;
                        }
                    }
                });
    
                if(getDistance(this, player) < 0){
                    changeVelocity(this, player);
                        this.collapsed = 1;
                }
    
                // checks for overlapping between enemies
                otherEnemies.forEach((enemy)=>{
                    if(enemy != this){
                        if(getDistance(this, enemy) < -3){
                            changeVelocity(this, enemy);
                            this.enemycollapses = 2;
                            this.mass = 2;
                        }
                    }
                });

                // checks for overlapping between player and enemy
                if(getDistance(this, player) < -3){
                    changeVelocity(this, player);
                        this.enemycollapses = 2;
                        this.mass = 4;
                }

                let rightWall = new wall(canvas.width, this.y)
                let leftWall = new wall(0, this.y);
                let topWall = new wall(this.x, 0);
                let bottomWall = new wall(this.x, canvas.height);
    
                if(this.hasenteredcanvas == false){
                    if((this.x  - this.r > 0 && this.x + this.r < canvas.width) && 
                    (this.y - this.r > 0 && this.y + this.r < canvas.height)){
                        this.hasenteredcanvas = true;
                    }
                } else{
                    if(getDistance(this, rightWall) < 0){
                        changeVelocity(this, rightWall);
                    }
    
                    if(getDistance(this, topWall) < 0){
                        changeVelocity(this, topWall);
                    }
    
                    if(getDistance(this, leftWall) < 0){
                        changeVelocity(this, leftWall);
                    }
    
                    if(getDistance(this,  bottomWall) < 0){
                        changeVelocity(this, bottomWall);
                    }
                }
    
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.draw();
            }
        }
    
        // enemies generator 
    
        let enemies = new Array();
    
        setInterval(()=>{
            let r = 10;
            let x, y;
            if(Math.random() < 0.5){
                x = (Math.random() < 0.5)? 0 - r: canvas.width + r;
                y = Math.random() * canvas.height;
            } else{
                x = Math.random() * canvas.width;
                y = (Math.random() < 0.5)? 0 - r: canvas.height + r;
            }
            let cl = 'green';
            let mass = 1.1;
            let velocity = {
                x: 0, 
                y: 0
            }
            let speed = 0.4 + Math.random() 
            let maxEnemies = 10;
            if(enemies.length < maxEnemies){
                if(isScrolledIntoView(canvas) && (pageIsViewed | pageIsViewed == 'unknown')){
                    enemies.push(new enemie(x, y, r, cl, velocity, speed, mass));
                }
            }
        }, 4000);
    
    // the animate function
    
    let animate = function(){
        if((pageIsViewed | pageIsViewed == 'unknown') && isScrolledIntoView(canvas)){
            c.clearRect(0, 0, Cwidth, Cheight);
            player.update(enemies);
            enemies.forEach((enemy, i)=>{
                enemy.update(enemies);
            });
            bullets.forEach((bullet, i)=>{
                bullet.update();
                if(bullet.x - bullet.r < 0 |
                bullet.x > Cwidth - bullet.r |
                bullet.y - bullet.r < 0 |
                bullet.y > Cheight - bullet.r){
                    bullets.splice(i, 1);
                }
            });
        } else{
            c.clearRect(0, 0, canvas.width, canvas.height);
            c.save();
            c.font = 'normal 24px Arial';
            c.alignText = 'left';
            c.fillStyle = 'black';
            c.fillText('The game is paused', 10, 30);
            c.restore();
        }
        requestAnimationFrame(animate);
    }
    
    animate();
    
    }
    </script>

<h2><u>What did I add to the code:</u></h2>

<p>So, there are a bunch of stuff I did, let me 
categorize them before starting talking about them. 
As you can see, I <Span>changed the color of the player</span>,
added him a <Span>stroke</span> and I also <Span>changed the color and size 
of the bullets</span>. The next thing I did was to 
<span>create the enemies</span> and <Span>make them follow the player</span>, 
with <span>random speeds</span>, after that I <Span>added collisions</span>
to <span>both the player and the enemies</span>, in order to do so, 
I had to <span>change the way the player is moving</span> 
so that <Span>instead of increasing or decreasing directly the x and y positions</span> 
he is using <Span>velocities</span>, I did that so that 
<Span>I can calculate his final velocity after collisions</span>. 
Then I made some <span>imrpovements to the collisions</span>, tried 
to <span>prevent overlapping between particles</span>, and I also made 
it so it checks if <Span>the page is visible</span> before <Span>generating the enemies</span> 
and <span>updating the canvas</span>, if it is <Span>not visible</span> or the 
<span>canvas is not scrolled into view</span> I made a <Span>pause screen appear</span>.
</p>

<h2><u>How I created the enemies:</u></h2>

<p>Alright, so, first let's talk about how I created 
the <Span>enemies</span>, all <Span>properties</span> I needed 
at first were <Span>x, y, r, cl, velocity and speed</span>, the 
<span>draw method simple draws the arcs</span> while the 
<Span>update method</span> does all the magic. Before 
I speak about <span>collisions</span> and stuff, let me explain 
<span>how I make the enemies follow the player</span>. I'm basically 
<Span>getting the angle between the player and the enemy</span> just 
like I got the <Span>angle between the player and the cursor</span> before 
when <Span>I created the bullets</span>, and then I 
use <Span>Math.cos() and Math.sin()</span> to <Span>set the x and y velocities</span>, 
I <Span>also multiply them by speed</span> so that <Span>the enemies move at different speeds</span>.
At the <Span>end of the method</span> I am just 
<Span>add the velocities to x and y properties</span> to 
<Span>move the arcs</span>.
</p>

<h2><u>How do I spawn the enemies:</u></h2>

<p>Let's talk about how I <Span>generate the enemies</span> now, 
I wanted to make it so they <Span>spawn every 4 seconds</span>
at <Span>random positions</span> but <Span>outside the canvas</span>.
So, I created an <Span>enemies array</span> and then <span>set an interval</span>. 
In <Span>each loop</span>, it first <Span>sets r to 10</span>, 
then <Span>creates two empty x and y variables</span>, which then 
are <Span>defined inside and if else statement</span>. So, 
<Span>if(Math.random() < 0.5)</span> actually has a <Span>50% chance to be true</span>, 
so <span>if it's true</span> then by using 
a <Span>conditional operator</span> we set <Span>x to have 50% chance to be 0 - r</span> 
and <Span>50% chance to be canvas.width + r</span>, so it basically 
<Span>randomly defines wether the enemy will spawn at left or right</span>, 
then <Span>y</Span> is set to be <span>anything from 0 to canvas.height</span>.
If <Span>first if statement returns false</span> however 
then <Span>y has 50% chance to be 0 -r</span> and 
<Span>50% chance to be canvas.height + r</span> while 
<Span>x can be anything between 0 and canvas.width</span>.
With this line of code the <Span>enemies</Span> can 
<span>spawn from all directions</span>. The 
<Span>velocities</span> are <Span>set to 0</span>, 
since they are <Span>being updated inside update method</span>
anyway, the <Span>speed is set to be anything between 0.4 and 1.4</span>,
and I also made it so <Span>maxEnemies are 10</span>.
The <Span>mass</span> was added so that 
I can <Span>calculate the final velocities after collisions</span>.
Lastly, to make sure that the <span>enemies</span> are 
<Span>only being spawned</span> when the <span>page is viewed</span> and 
the <Span>canvas is scrolled into viewd</Span> I created a 
<Span>variable</span> named <Span>pageIsViewed</span> which I set 
to <span>'unknown'</span> and used <span>visibilitychange event</span> 
on <Span>window</span> which <Span>triggers every time it's visibility changes</span> 
to <Span>toggle the variable from false to true, and true to false</span>, the 
event normally should <span>already trigger once when the page is opened</span> 
but I had some issue in which some times, for some reason, it didn't, that's 
why I set the <span>variable</span> to <span>unknown</span> at first. Now, to 
<Span>avoid any errors</span>, I also made sure to <Span>set the variable to true</span>
whenever the <Span>cursor is moved over the page</span>, just in case for whatever 
reason it hasn't already been set. </p>

<h2><u>Functions used to detect collisions and calculate final velocities:</u></h2>

<p>So, it's time to speak about 
<Span>collisions</span>, first thing 
I did was <span>create some functions at the beginning of my code</span>
which I needed to later make <Span>collisions</span>.
The <span>first function</span> is a <Span>class</Span> which 
let's you <Span>create wall objects</Span> to later use with 
the <Span>getDistance</Span> and <Span>cangeVelocities</span> functions, 
I only needed this <Span>function</span> to add <Span>collision</span> 
between the <Span>particles</span> and the <Span>edges of the canvas</span>.
The <Span>second function</span> is the 
<Span>getDistance() function</Span>, it takes <Span>two round particles</span>
ad it's <Span>parameters</span> and <Span>returns the distance between them</Span>.
The <Span>third function</span> takes an <Span>(x, y) value</span>
and an <span>angle</span> and <Span>rotates the axis by that angle</span>, 
then it <Span>returns the x and y values on the rotated axis</span>.
This <span>function</span> is needed because I can 
only <Span>calculate the final velocities</span> 
of an <span>elastic collision</span> when <Span>two particles collid horizontally</span>, 
but since <Span>particles are moving both vertically and horizontally</span>
they <span>don't always collid horizontally</span>, that's why 
I <span>calculate the angle of the vector formed between 
the center of the one and the center of the other</span> and
then <Span>rotate the axis by that angle</span> to be able 
and <Span>calculate their final velocities</span>, after doing 
so I <Span>rotate the axis back and return the x and y values of 
the normal axis</span>. I have talked more about 
<Span>collisions</span> in a <Span>previous section</span> 
and I also have <Span>written about elastic collisions</span> 
in my <span>math and physics notes</span>, so check them out 
for more information about how <span>final velocities are calculated</span>.
The <Span>last function</span> takes <span>two particles</span>,
<Span>calculates their final velocities</span> and <Span>sets their velocities to the new ones</span>. 
</p>

<h2><u>Collisions on enemies:</u></h2>

<p>So, next thing we need to talk about is 
<Span>how I added the collisions</span> to 
the <Span>enemies</span> and <Span>player</span>
as well as <Span>what bugs were created and how they were fixed</span>.
It's the first time I create <span>collisions</span> 
with <Span>particles that don't have static velocities</span>
so I worked quite a while on this, <Span>played around with the code a lot</span>
and ended up with <Span>collisions</span> which 
may aren't perfect, but are good enough for me to be 
satisfied. 
</p>

<p>Alright, so, when <Span>calling the update method of enemies in animate function</span> 
I pass in the <Span>enemies array</span> as a <Span>parameter</span>. 
I then <Span>access that array inside update method</span>
in a <Span>forEach loop</span>, the <Span>if(enemy != this)</span> 
condition simple <Span>makes sure that the distance will only be calculated</span> 
between <Span>different enemy objects</span>. So, 
<Span>for every enemy object that is not equal to this</span> 
it <Span>measures the distance between the other enemy object and this enemy object</span> 
and <Span>if less than 0</span> it <Span>calculates and sets thie final velocities</span>. 
It also <Span>sets this.enemycollapses to 0.5</span>, so let 
me explain what this does. In <Span>every animate iteration</span> 
the <Span>velocities of the enemies</span> are 
<span>recalculated and set to follow the player</span>, so,
<Span>after two enemies collided</span> their <Span>velocities would change 
only for the current iteration</span> and <span>quickly change to follow the player again</span>,
something that was a little <Span>ugly</span>, creating a 
<Span>constant back and forth motion</span>, and also 
<Span>made it hard to push multiple enemies around</span> 
with the <span>player</span> later after I <span>added collisions to the player</span>.
I did want them to <span>have a sort of resistance</span> since 
they <Span>do are trying to move towards the player</span>, but 
I wanted some kind of <span>cooldown after the collision</span> so 
that <Span>they are pushed back a little</span> and 
<Span>then after two iterations they continue following the player</span>, 
that would make <Span>collisions more smooth</span> and 
it would also <Span>make it easier for the player to push multiple enemies around</span>.
</p>

<p>So, at first the <span>enemycollapses is set to -1</span>, 
in <Span>each iteration</span> it <span>checks
wether enemycollapses is smaller than 0</span> 
and <Span>if true</span> it <span>sets the 
velocities to follow the player</span>, 
<Span>if false</span> it does nothing, 
<span>after each iteration enemycollapses decreases by 1</span>,
later I also added <span>this.collapsed property</span>
which checks if <Span>enemies collided with the player</span>
but I will talk about it later. So, they do <Span>collid with each other</Span>
now, but to make them <Span>collid with the player</span>
I also <Span>calculated the distance between the enemy and the player</span> 
and <Span>when less than 0</span> called the <span>changeVelocity(this, player)</span> method
to <span>set their final velocities after the collision</span>, 
however, I also set <Span>this.collapsed to 1</span>, this 
is another <Span>property</span> used to <Span>fix some bugs</span>, 
as I said before, <span>right after the velocities changed</span>, 
at the <Span>very next iteration</span> they would be 
<Span>changed back to follow the player</span>, so it 
would create a <Span>constant back and forth motion every time enemies and player touched</span>, 
and also, it would be <Span>hard to push them around</span>.
Why didn't I use <Span>only one property for both enemy and player collapses</span>? 
It's because I wanted a slightly different behavior for 
<span>player collapses</span>, first of all, I <Span>set collapsed to 1</span>,
meaning, it will be <Span>greater than or equal to 0</span> for 
<Span>at least 2 more iterations</span>, secondly, I wanted 
the <span>player</span> to be able to <span>push the enemies around</span>, 
by <Span>constantly colliding to them</span>, so I wanted their 
<Span>velocities at the very next iteration to be set to 0</Span>
so that the <span>player can collid with them again</span>, 
else they would <Span>move the other direction</span> meaning 
<Span>constant collision</span> would not occur, and the 
<Span>enemies would change their velocities to follow the player again</span> 
so a little <span>back and forth motion would occur while trying to push enemies around</span>, 
which was just ugly. Just like <Span>enemycollapses</span> the 
<Span>collapsed property is decreased by 1 in each iteration</span>. 
So, last thing I did for <Span>enemy collisions</span> was to make sure 
that <span>enemies cannot be pushed off the canvas</span>,
to do that I created the <span>wall class</span> which I used to 
create <Span>wall objects</span>, for the <span>right and left walls</span> 
I give them the <Span>enemy's y</Span> and <Span>for x I give them 0 for left 
and canvas.width for right</span>, this way, I can use <span>getDistance() function</span>
to <span>detect when the enemies hit the edge</span>, I similarly created the 
<Span>top and bottom walls</span>. This created a problem however, 
the <Span>particles</span> are <span>spawining outside of the canvas</span>, 
so I needed to make sure the <span>wall collisions</span> were only 
added <Span>after particles had entered the canvas viewport</span>, to do 
this I made the <Span>hasenteredcanvas property</Span> which I set to <span>false</span>, 
then I created a <Span>condition</span> which  <span>if hasenteredcanvas is false</span> 
it <span>checks if the particle is inside the canvas</span> and <span>if it is</span> 
it <Span>sets hasenteredcanvas to true</span>, if <span>hasenteredcanvas isn't false</span>
only then it <Span>checks for wall collisions</span>. 
<p>

<h2><u>Collisions on player:</u></h2>

<p>Alrigt, so, we now know how <Span>enemies detect collisions</span>,
but what about the <Span>player</span>? The 
<Span>changeVelocities function</span> requires 
the <Span>two particles</span> to have <Span>velocities</span>, 
so I added <span>velocities</span> to my <span>player</span>, it also 
requires them to have <Span>masses</span>, so I 
added a <Span>slightly smaller mass than the enemies</span>, 
so that <Span>the enemies can easier push me</span>, which <Span>mass</span> 
I however <Span>change to 2 every time I move</span> 
so that I can <Span>easier push the enemies when moving</span>.
I am also passing the <Span>enemies array</span> 
inside the <Span>update method of the player object</span>, 
which I <span>loop through with forEach array method</span> 
and <Span>checks if the distance with the player is less than 0 for any of the enemies</span>. 
If it returns <Span>true</span> then <Span>changeVelocity function is called</span>, 
which <Span>calculates and sets the final velocities</span>.
To <Span>prevent the player from leaving the canvas</span> I used the 
<Span>wall class</span> just like I did for the <Span>enemies</Span>.</p>

<h2><u>How I fixed overlapping issues:</u></h2>
<p>So, my <span>collisions</span> were fine and all, but 
there was a lot of <span>overlapping happening</span> between 
the <span>particles</span>, especially when <Span>gathered together on the corners</span>, 
to fix that I used the <span>getDistance()</span> function, but 
instead of checking if the <Span>distance</span> is <span>less than 0</span> I checked if 
the <span>distance</span> is <span>less than -3</span>, in which case that 
would mean they are <span>overlapping each other</span>. If
<span>two enemies overlapped each other</span> 
I made it so <span>enemycollapses is set to 2</span>, 
thus, <Span>preventing the velocities from changing 
to follow the player for at least 4 iterations</span> and 
I also <Span>increased mass of the enemies to 2</span>, when
<Span>the player overlaps with an enemy</span> I made it so 
<span>enemycollapses is set to 2 and the mass is set to 4</span>,
and that's because the <span>player</span> can also <Span>move around</Span>
and if an <Span>enemy</span> was <Span>stuck at the corner</span> you could 
<span>force your way inside him</span>, by <Span>increasing his mass when overlapped</span> 
I prevent this from happening, I had also tried <Span>preventing the player from moving</span> 
but that created other issues in which the player would get stuck and stuff, so that 
was the best solution I could find.
For the <span>player</span> I made a <Span>collapsed property</span> which 
I <span>increase to 2</span> and made it so <span>velocities when no key is pressed 
do not return to 0 unless collapsed is less than zero</span>, I also made sure to 
<span>decrease collapsed variable by 1 in each iteration</span>, this makes sure 
that if the <span>player overlaps an enemy</span> the <Span>player</span> is <span>pushed off the enemy
for at least 4 iterations</span>. 
Anyway, there still are some <Span>small overlapping</span> but
it's much better than before for sure, and it's also my first game so it is expected 
that it won't be perfect.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">if(true){
let canvas = document.querySelector('#canvvaas26');
let c = canvas.getContext('2d');

<span class="grey">// sizes the canvas</span>
<span class="orange">canvas.width = 600;</span>
canvas.height = 500;

<span class="orange"><span class="grey">// sets the original background of the canvas before animation begins</span>
c.save();
c.fillStyle = 'black';
c.fillRect(0, 0, canvas.width, canvas.height);
c.restore();
// creates an imageData variable 
let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

<span class="grey">// my particles</span>
let bullets = new Array();
let enemies = new Array();
let bloodParticles = new Array();
let explosionParticles = new Array();
let player;

<span class="grey">// health, score and highscore variables</span>
let score = 0;
let highscore = 0;
let health = 100;</span>

<span class="grey">// function that checks wether element is scrolled into view or not</span>
function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

<span class="grey">// event that let us know whether the window is viewed or not</span>
let pageIsViewed = 'unknown';

document.body.onmouseover = (e)=>{
        pageIsViewed = true; 
}

window.addEventListener("visibilitychange", (e)=>{
    if(pageIsViewed == true | pageIsViewed == 'unknown'){
        pageIsViewed = false;
    } else if(pageIsViewed == false){
        pageIsViewed = true;
    }
});

<span class="grey">// functions that are used to detect collisions</span>

<span class="grey">    // constructor used to create hitboxes at the edges of the canvas</span>
    let wall = class{
        constructor(x, y, velocity){
            this.x = x;
            this.y = y;
            this.r = 0;
            this.velocity = {
                x: 0,
                y: 0
            }
            this.mass = 999;
        }
    }

<span class="grey">    // gets the distance between two particles</span>
    let getDistance = function(thisEnemy, otherEnemy){
        let Vx = thisEnemy.x - otherEnemy.x;
        let Vy = thisEnemy.y - otherEnemy.y;
        let distance = Math.hypot(Vx, Vy) - thisEnemy.r - otherEnemy.r;
        return distance;
    }

<span class="grey">    // rotates the axis so that the final velocities can be calculated</span>
    let rotate = function(velocity, angle){
        let rotatedVelocities = {
            x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
            y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
        }
        return rotatedVelocities;
    }

<span class="grey">    // calculates and sets the final velocities after the collision</span>
    let changeVelocity = function(thisParticle, otherParticle){
        let [x1, x2] = [thisParticle.x, otherParticle.x];
        let [y1, y2] = [thisParticle.y, otherParticle.y];
        let [v1, v2] = [thisParticle.velocity, otherParticle.velocity];
        let [m1, m2] = [thisParticle.mass, otherParticle.mass];

        let xVelocityDiff = v1.x - v2.x;
        let yVelocityDiff = v1.y - v2.y;
        let xDist = x2 - x1;
        let yDist = y2 - y1;

        if(xVelocityDiff * xDist + yVelocityDiff * yDist >= 0){
            let angle = -Math.atan2(y2 - y1, x2 - x1);

            let rotatedV1 = rotate(v1, angle);
            let rotatedV2 = rotate(v2, angle);

            let rotatedV1final = {
                x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2),
                y: rotatedV1.y
            }

            let rotatedV2final = {
                x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2),
                y: rotatedV2.y
            }

            let finalV1 = rotate(rotatedV1final, -angle);
            let finalV2 = rotate(rotatedV2final, -angle);

            thisParticle.velocity = finalV1;
            otherParticle.velocity = finalV2;
        }
    }

<span class="grey">// code for the player</span>

let playerMaker = class{
    constructor(x, y, r, cl, velocity, mass){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.mass = mass;
        this.collapsed = -1;
<span class="orange">        this.cooldown = -1;
        this.dmg_duration = 0;</span>
    }

    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.stroke();
    }

    update(enemies){

<span class="grey">        // if key.up is true makes player move up and increases mass</span>
        if(keys.up){
            this.mass = 2.2;
            this.velocity.y = -1.5;
        } 

<span class="grey">        // else if key.down is true increases mass but makes player move down</span>
        else if(keys.down){
            this.mass = 2.2;
             this.velocity.y = 1.5;
        }

<span class="grey">        // else if this.collapsed is less than zero it sets mass to 1 and velocity.y to zero</span>
        else if(this.collapsed < 0){
            this.mass = 1;         
            this.velocity.y = 0;
        }

<span class="grey">        // if key.right is true makes player move to right and increases mass</span>
        if(keys.right){
            this.mass = 2.2;
            this.velocity.x = 1.5;
        } 

<span class="grey">        // else if keys.left is true increases mass but makes player move to left</span>
        else if(keys.left){
            this.mass = 2.2;
            this.velocity.x = -1.5;
        } 

<span class="grey">        // else if this.collapsed is less than zero it sets mass to 1 and velocity.x to zero</span>
        else if(this.collapsed < 0){
            this.velocity.x = 0;
            this.mass = 1;         
        }

<span class="grey">        // decreases collapsed property</span>
        this.collapsed -= 1;

<span class="grey">         // loops through all the enemies</span>
        enemies.forEach((enemy)=>{
<span class="grey">             // checks if distance is less than zero</span>
            if(getDistance(this, enemy) < 0){
<span class="grey">                 // calculates their final velocities after collision and sets them</span>
                changeVelocity(this, enemy);
<span class="grey">                 // checks if cooldown is less than zero</span>
<span class="orange">                if(this.cooldown < 0){
<span class="grey">                     // sets was_hit property of enemy to enemy's cooldown</span>
                    enemy.was_hit = enemy.cooldown;
<span class="grey">                     // sets player's cooldown property to enemy's cooldown</span>
                    this.cooldown = enemy.cooldown;
<span class="grey">                     // increases dmg_duration property of player</span>
                    this.dmg_duration += enemy.damage_duration;
<span class="grey">                     // sets an interval</span>
                    let interval = setInterval(()=>{
<span class="grey">                         //decreases health by enemy's damage in each iteration</span>
                        health -= enemy.dmg;
<span class="grey">                         // prevents health from becoming less than zero</span>
                        if(health < 0){
                            health = 0;
                        }
<span class="grey">                         // checks if the dmg_duration is less or equal to 0</span>
                        if(this.dmg_duration <= 0){
<span class="grey">                             // stops the interval</span>
                            clearInterval(interval);
                        }
<span class="grey">                         // decreases dmg_duration by 1 after each iteration of the iinterval</span>
                        this.dmg_duration -= 1;
                    }, 200);
                }</span>
            }
        });

<span class="grey">         // decreases cooldown by 1 every time player updates</span>
<span class="orange">        this.cooldown -= 1;</span>

<span class="grey">        // checks for overlapping</span>
        enemies.forEach((enemy)=>{
            if(getDistance(this, enemy) < -3){
                changeVelocity(this, enemy);
                this.collapsed = 2;
            }
        });

<span class="grey">        // set hitboxes at the edges of the canvas</span>
        let rightWall = new wall(canvas.width, this.y)
        let leftWall = new wall(0, this.y);
        let topWall = new wall(this.x, 0);
        let bottomWall = new wall(this.x, canvas.height);

<span class="grey">        // detects collisions with the edges of the canvas</span>
        if(getDistance(this, rightWall) < 0){
            changeVelocity(this, rightWall);
        }

        if(getDistance(this, topWall) < 0){
            changeVelocity(this, topWall);
        }

        if(getDistance(this, leftWall) < 0){
            changeVelocity(this, leftWall);
        }

        if(getDistance(this,  bottomWall) < 0){
            changeVelocity(this, bottomWall);
        }

<span class="grey">        // updates x and y positions</span>
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        this.draw();
    }
}

let Cwidth = canvas.width;
let Cheight = canvas.height;

<span class="grey">// creates the player</span>
player = new playerMaker(Cwidth/2, Cheight/2, <span class="orange">15</span>, 'orange', {x: 0, y: 0}, 1);

<span class="grey">// object that lets us know what keys are being pressed</span>
let keys = {
    up: false,
    right: false, 
    down: false,
    left: false
}

<span class="grey">// event listener that updates keys object when a key is pressed</span>
addEventListener('keydown', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = true;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = true;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = true;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = true;
    }
});

<span class="grey">// event listener that updates keys object when a key is released</span>
addEventListener('keyup', (e)=>{
    if(e.keyCode == 37 || e.keyCode == 65){
        keys.left = false;
    } 
    if(e.keyCode == 39 || e.keyCode == 68){
        keys.right = false;
    } 
    if(e.keyCode == 38 || e.keyCode == 87){
        keys.up = false;
    }
    if(e.keyCode == 40 || e.keyCode == 83){
        keys.down = false;
    }
});

<span class="grey">// code for the bullets</span>

<span class="grey">    // bullets constructor</span>
    let bullet = class{
        constructor(x, y, r, cl, velocity, <span class="orange">mass</span>){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
<span class="orange">            this.mass = mass;
            this.opacity = 1;</span>
        }

        draw(){
            c.save();
<Span class="orange">            c.globalAlpha = this.opacity;</span>
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
            c.restore();
        }

        update(){

<span class="grey">            // updates the x and y position</span>
            this.x += this.velocity.x;
            this.y += this.velocity.y;

            this.draw();
        }
    }

<span class="grey">    // bullets generator</span>

<span class="grey">    // variable that determines wether mouse is down or not</span>
    let mousedown = false;

<span class="grey">    // an object to save the mouse's position</span> 
    let mouse = {
        x: 0,
        y: 0
    }

<span class="grey">    // updates the mouse position as it moves around the canvas</span>
    canvas.addEventListener('mousemove', (e)=>{
        mouse.x = e.offsetX;
        mouse.y = e.offsetY;
    });

<span class="grey">    // event that triggers when mouse button is pushed down</span>
    canvas.addEventListener('mousedown', (e)=>{
<span class="grey">        // prevents default behaviour</span>
        e.preventDefault();

<span class="grey">        // sets mousedown to true</span>
        mousedown = true;

<span class="grey">        // sets an interval</span>
        let interval = setInterval(()=>{
            let r = 3;
<span class="orange">            let cl = 'grey'</span>
            let x = player.x;
            let y = player.y;
            let vx = mouse.x - x;
            let vy = mouse.y - y;

<span class="grey">            // gets angle and sets velocities</span>
            let angle = Math.atan2(vy, vx);
            let velocity = {
                x: Math.cos(angle) * 4,
                y: Math.sin(angle) * 4
            }

<span class="orange">            let mass = 3;</span>

<span class="grey">            // creates bullets if gave hasn't ended</span>
            if(health > 0){
                bullets.push(new bullet(x, y, r, cl, velocity, <span class="orange">mass</span>));
            }
        }, 200);

<span class="grey">        // checks if mousedown is false to clear the interval above</span>
        let interval2 = setInterval(()=>{
            if(mousedown == false){
                clearInterval(interval);
                clearInterval(interval2);
            }
        }, 1);
    });

<span class="grey">    // event that triggers when mouse button is released</span>
    window.addEventListener('mouseup', (e)=>{
<span class="grey">        // sets mousedown to false</span>
        mousedown = false;
    });

<span class="orange"><span class="grey">// blood constructor</span>

let blood = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.friction = 0.93;
        this.life_time = 1;
    }

    draw(){
        c.save();
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        c.fill();
        c.restore();
    }

    update(){
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;

        this.x += this.velocity.x;
        this.y += this.velocity.y;

        this.draw();

        this.life_time -= 0.15;
    }
}

<span class="grey">// explosion constructor</span>

let explosion = class{
    constructor(x, y, r, cl, velocity){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
        this.velocity = velocity;
        this.friction = 0.99;
        this.gravity = 0.01;
        this.alpha = 1;
    }

    draw(){
        c.save();
        c.globalAlpha = this.alpha;
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
        c.restore();
    }

    update(){
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;

        this.velocity.y += this.gravity;

        this.x += this.velocity.x;
        this.y += this.velocity.y;

        this.draw();

        this.alpha -= 0.01;
    }
}</span>

<span class="grey">// code for enemies</span>

<span class="grey">    // enemies constructor</span>
    let enemyConstructor = class{
        constructor(x, y, r, cl, velocity, speed, mass, <span class="orange">cooldown, damage_dur, damage, health</span>){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.speed = speed;
            this.mass = mass;
<span class="orange">            this.original_mass = mass;</span>
            this.player_collapsed = -1;
            this.enemy_collapsed = -1;
            this.has_entered_canvas = false;
<Span class="orange">            this.stroke = 'black';
            this.maxHealth = health;
            this.health = health;
            this.damage_duration = damage_dur;
            this.dmg_duration = 0;
            this.dmg = damage;
            this.cooldown = cooldown;
            this.was_hit;</span>
        }

        draw(){
            c.save();
            c.strokeStyle = this.stroke;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
            c.restore();
        }

<Span class="orange">        drawHealthBar(){
            c.save();
            c.fillStyle = 'red';
<span class="grey">            // draws red layer of health</span>
            c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5);
            c.fillStyle = 'green';
<span class="grey">            // draws green layer of health, the width is multiplied by (this.health / this.maxHealth) 
            // so that it decreases as this.health gets smaller and smaller till it reaches zero</span>
            c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2) * (this.health / this.maxHealth), 3.5);
            c.lineWidth = 2;
            c.strokeStyle = 'black';
<span class="grey">            // draws a border around the healthbar</span>
            c.strokeRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5);  
            c.restore();
        }</span>

        update(otherEnemies, <span class="orange">bullets</span>){
<span class="grey">            // gets angle between enemy and player</span>
            let vx = player.x - this.x;
            let vy = player.y - this.y;
            let angle = Math.atan2(vy, vx);
            
<span class="grey">            // if no collisions have happened the enemy moves towards the player</span>
            if(this.player_collapsed < 0 && this.enemy_collapsed < 0){
<span class="grey">                // sets stroke to black</span>
<span class="orange">                this.stroke = 'black';</span>
<span class="grey">                // sets velocities to follow the player</span>
                this.velocity.x = Math.cos(angle) * this.speed;
                this.velocity.y = Math.sin(angle) * this.speed;
            } 
<span class="grey">            // if the enemy collapsed with the player the velocities are being decreased</span>
            else if(this.player_collapsed > 0){
<span class="grey">                this.velocity.x *= 0.5;
                this.velocity.y *= 0.5;</span>
            } 

<span class="grey">            // deacreases enemy_collapsed and player_collapsed properties</span>
            this.enemy_collapsed -= 1;
            this.player_collapsed -= 1;
<span class="grey">            // decreases cooldown</span>
<Span class="orange">            this.was_hit -= 1;</span>
<span class="grey">            // sets mass to original mass</span>
            this.mass = this.original_mass;

<span class="grey">            // loops through all the enemies</span>
            otherEnemies.forEach((enemy)=>{
<span class="grey">                // prevents this from running the code on it self</span>
                if(enemy != this){
<span class="grey">                    // checks if collision</span>
                    if(getDistance(this, enemy) < 0){
<span class="grey">                        // calculates and sets final velocities</span>
                        changeVelocity(this, enemy);
<span class="grey">                        // checks if enemy_collapsed is less than 0.5, that's because
                        // when enemy collapses with a bullet I set enemy_collapsed to 
                        // 4, so I don't want it to be set back to 0.5, and I didn't want 
                        // to create a different variable for bullet collisions since it isn't needed</span>
<span class="orange">                        if(this.enemy_collapsed < 0.5){</span>
<span class="grey">                            // sets enemy_collapsed to 0.5</span>
                            this.enemy_collapsed = 0.5;
<span class="orange">                        }</span>
                    }
                }
            });

<span class="grey">            // checks if distance with the player is less than 0</span>
            if(getDistance(this, player) < 0){
<span class="grey">                // calculates and sets the final velocities after the collision</span>
                changeVelocity(this, player);
<span class="grey">                // sets player_collapsed property to 1</span>
                this.player_collapsed = 1;
<span class="grey">                // sets was_hit property to cooldown value</span>
<span class="orange">                this.was_hit = this.cooldown;
<span class="grey">                // sets cooldown property of player to this.cooldown value</span>
                player.cooldown = this.cooldown;
<span class="grey">                // checks if was_hit is less than 0</span>
                if(this.was_hit < 0){
<span class="grey">                    // increases dmg_duration by damage_duration
                    // the reason I made two properties for damage duration
                    // is because I wanted one to be kept static at all times</span>
                    this.dmg_duration += this.damage_duration;
<span class="grey">                    // sets an interval</span>
                    let interval = setInterval(()=>{
<span class="grey">                        // decreases health by this.dmg in every iteration</span>
                        health -= this.dmg;
<span class="grey">                        // prevents health from becoming less than zero</span>
                        if(health < 0){
                            health = 0;
                        }
<span class="grey">                        // checks if dmg_duration is less or equal to zero</span>
                        if(this.dmg_duration <= 0){
<span class="grey">                            // stops the interval</span>
                            clearInterval(interval);
                        }
<span class="grey">                        // decreases the dmg_duration by 1 after each iteration</span>
                        this.dmg_duration -= 1;
                    }, 200);
                }</span>
            }

<span class="grey">            // loops through the bullets array</span>
<Span class="orange">            bullets.forEach((bullet, i)=>{
<span class="grey">                // checks if the distance between the enemy and the bullet is less than 0</span>
                if(getDistance(this, bullet) < 0){
<span class="grey">                    // calculates and sets the final velocities</span>
                    changeVelocity(this, bullet);
<span class="grey">                    // makes bullet invisible</span>
                    bullet.opacity = 0;
<span class="grey">                    // sets enemy_collapsed to 4</span>
                    this.enemy_collapsed = 4;
<span class="grey">                    // sets stroke property to pink</span>
                    this.stroke = 'pink';
<span class="grey">                    // decreases health by 20</span>
                    this.health -= 20;
<span class="grey">                    // prevents health from becoming less than zero</span>
                    if(this.health < 0){
                        this.health = 0;
                    }

<span class="grey">                    // sets number of blood particles to be created</span>
                    let bloodCount = 20;
<span class="grey">                    // devides a full circle by the number of blood particles</span>
                    let angleIncrement = Math.PI * 2 / bloodCount;

<span class="grey">                    // a loop that creates the blood particles</span>
                    for(let i = 0; i < bloodCount; i++){
                        let velocity = {
                            x: Math.cos(angleIncrement * i) * Math.random() * 2,
                            y: Math.sin(angleIncrement * i) * Math.random() * 2
                        }
                        let x = this.x;
                        let y = this.y;
                        let r = this.r / 3;
                        let color = 'red';
                        bloodParticles.push(new blood(x, y, r, color, velocity));
                    }
                }
            });</span>

<span class="grey">            // checks for overlapping between the enemies</span>
            otherEnemies.forEach((enemy)=>{
                if(enemy != this){
                    if(getDistance(this, enemy) < -3){
                        changeVelocity(this, enemy);
                        this.enemy_collapsed = 2;
                        this.mass = 2;
                    }
                }
            });

<span class="grey">            // checks for overlapping between player and enemy</span>
            if(getDistance(this, player) < -3){
                changeVelocity(this, player);
                    this.enemy_collapsed = 2;
                    this.mass = 4;
            }

<span class="grey">            // creates hit boxes at the edges of the canvas</span>
            let rightWall = new wall(canvas.width, this.y)
            let leftWall = new wall(0, this.y);
            let topWall = new wall(this.x, 0);
            let bottomWall = new wall(this.x, canvas.height);

<span class="grey">            // checks if has_enter_canvas is false</span>
            if(this.has_entered_canvas == false){
<span class="grey">                // checks if particle has entered the canvas</span>
                if((this.x  - this.r > 0 && this.x + this.r < canvas.width) && 
                (this.y - this.r > 0 && this.y + this.r < canvas.height)){
<span class="grey">                    // sets has_entered_canvas to true</span>
                    this.has_entered_canvas = true;
                }
            } 

<span class="grey">            // if has_enter_canvas is true then it checks for wall collisions</span>
            else{
                if(getDistance(this, rightWall) < 0){
                    changeVelocity(this, rightWall);
                }

                if(getDistance(this, topWall) < 0){
                    changeVelocity(this, topWall);
                }

                if(getDistance(this, leftWall) < 0){
                    changeVelocity(this, leftWall);
                }

                if(getDistance(this,  bottomWall) < 0){
                    changeVelocity(this, bottomWall);
                }
            }

<span class="grey">            // updates x and y positions</span>
            this.x += this.velocity.x;
            this.y += this.velocity.y;

            this.draw();
        }
    }

<span class="grey">    // enemies generator</span>

<span class="grey">     // creates different type of enemies
    // radius, color, speed, mass, cooldown, damage_duration, damage, health</span>
<span class="orange">    let normalEnemy = [15, 'green', function(){return 0.4 + Math.random()}, 1.1, 6, 0.5, 1, 100];
    let tankEnemy = [25, 'rgba(43, 93, 50, 1)', function(){return 0.1 + Math.random()}, 2, 6, 1, 2, 400];
    let kidEnemy = [12, '#5dcc70', function(){return 1 + Math.random()}, 0.9, 6, 0.25, 0.5, 50];
    let enemyTypes = [kidEnemy, normalEnemy, normalEnemy, normalEnemy, tankEnemy];</span>

<span class="grey">    // sets an interval that spawns enemies</span>
    setInterval(()=>{
<span class="grey">        // randomly selects a type of enemy</span>
<span class="orange">        let enemy = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];</span>
        let r = <span class="orange">enemy[0]</span>;
        let x, y;

<span class="grey">        // spawns the enemy randomly outside the canvas</span>
        if(Math.random() < 0.5){
            x = (Math.random() < 0.5)? 0 - r: canvas.width + r;
            y = Math.random() * canvas.height;
        } else{
            x = Math.random() * canvas.width;
            y = (Math.random() < 0.5)? 0 - r: canvas.height + r;
        }

        let color = <span class="orange">enemy[1]</span>;
        let velocities = {x: 0, y: 0}
        let speed = <span class="orange">enemy[2]()</span>;
        let mass = <span class="orange">enemy[3]</span>;
<span class="orange">        let cooldown = enemy[4];
        let dmg_duration = enemy[5];
        let dmg = enemy[6];
        let health = enemy[7];</span>

<span class="grey">        // max enemies that can spawn</span>
        let maxEnemies = <span class="orange">20</span>;

<span class="grey">        // checks if max enemies have been spawned</span>
        if(enemies.length < maxEnemies){
<span class="grey">            // checks if game is started and active</span>
            if((isScrolledIntoView(canvas) && (pageIsViewed | pageIsViewed == 'unknown')) && health > 0){
                enemies.push(new enemyConstructor(x, y, r, color, velocities, <span class="orange">speed, mass, cooldown, dmg_duration, dmg, health</span>));
            }
        }
    }, <span class="orange">3000</span>);

<span class="orange"><span class="grey">// function that restarts the game</span>
function restart(e){
<span class="grey">    // checks if the mouse position is over the button</span>
    if((e.offsetX > canvas.width / 2 - 100 && e.offsetX < canvas.width / 2 - 100 + 200) &&
    (e.offsetY > canvas.height / 2 + 25 && e.offsetY < canvas.height / 2 + 25 + 50)){
<span class="grey">        // restores health and score variables</span>
        health = 100;
        score = 0;

<span class="grey">        // empties all arays and repositions player</span>
        enemies = [];
        bullets = [];
        bloodParticles = [];
        explosionParticles = [];
        player.x = canvas.width / 2;
        player.y = canvas.width / 2;

<span class="grey">        // draws background</span>
        c.save();
        c.fillStyle = 'black';
        c.fillRect(0, 0, Cwidth, Cheight);
        c.restore();

<span class="grey">        // updates imageData to remove blood from screen</span>
        imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    }
}</span>

<span class="grey">// function that runs again and again to animate the canvas</span>
let animate = function(){
<span class="grey">    // checks if canvas is scrolled into view and page is viewed</span>
    if((pageIsViewed == true | pageIsViewed == 'unknown') && isScrolledIntoView(canvas)){
<span class="grey">        // draws the canvas black</span>
<span class="orange">        c.save();
        c.fillStyle = 'black';
        c.fillRect(0, 0, Cwidth, Cheight);
        c.restore();
<span class="grey">        // adds the blood on the canvas</span>
        c.putImageData(imageData, 0, 0);

<span class="grey">        // checks if health is greater than zero</span>
        if(health > 0){

<span class="grey">            // updates blood</span>
            bloodParticles.forEach((blood, i)=>{
                blood.update();
                if(blood.life_time < 0){
                    bloodParticles.splice(i, 1);
                }
            });

<span class="grey">            // updates imageData after new blood has been added, before anything else is drawn</span>
            imageData = c.getImageData(0, 0, canvas.width, canvas.height);</span>

<span class="grey">            // updates bullets</span>
            bullets.forEach((bullet, i)=>{
<span class="grey">                // if bullet leaves the canvas viewport it removes the bullet</span>
                if(bullet.x - bullet.r < 0 |
                bullet.x > Cwidth - bullet.r |
                bullet.y - bullet.r < 0 |
                bullet.y > Cheight - bullet.r){
                    bullets.splice(i, 1);
                }
<span class="grey">                // if bullet's opacity is 0 it removes the bullet</span>
<span class="orange">                if(bullet.opacity == 0){
                    bullets.splice(i, 1);
                }</span>
                bullet.update();
            });

<span class="grey">            // updates the player</span>
            player.update(enemies);

<span class="grey">            // checks if there are enemies to be removed</span>
            enemies.forEach((enemy, i)=>{
<span class="grey">                // checks if health is less than zero</span>
<Span class="orange">                if(enemy.health <=0){
<span class="grey">                    // increases score</span>
                    score += 1;
<span class="grey">                    // if score is bigger than highscore updates highscore</span>
                    if(score > highscore){
                        highscore = score;
                    }

<span class="grey">                    // removes the enemy</span>
                    enemies.splice(i, 1);

<span class="grey">                    // sets number of explosion particles to be created</span>
                    let particlesCount = 30;
<span class="grey">                    // devides a full circle by the number of explosion particles</span>
                    let angleIncrement = Math.PI * 2 / particlesCount;

<span class="grey">                    // a loop that creates the explosion particles</span>
                    for(let i = 0; i < particlesCount; i++){
                        let velocity = {
                            x: Math.cos(angleIncrement * i) * Math.random() * 3,
                            y: Math.sin(angleIncrement * i) * Math.random() * 3
                        }
                        let x = enemy.x;
                        let y = enemy.y;
                        let r = enemy.r / 5;
                        let color = enemy.cl;
                        explosionParticles.push(new explosion(x, y, r, color, velocity));
                    }
                }</span>
            });

<Span class="grey">            // updates the enemies</span>
            enemies.forEach((enemy)=>{
                enemy.update(enemies, bullets);
            });

<span class="grey">            // updates the explosion particles</span>
<span class="orange">            explosionParticles.forEach((particle, i)=>{
                particle.update();
<span class="grey">                // if opacity is less or equal to zero it removes particle</span>
                if(particle.alpha <= 0){
                    explosionParticles.splice(i, 1);
                }
            });

<span class="grey">            // updates the health bars of the enemies</span>
            enemies.forEach((enemy)=>{
                enemy.drawHealthBar();
            });

<span class="grey">            // removes the click event listener that restarts the game</span>
            canvas.removeEventListener('click', restart);
        }

<span class="grey">        // if health is not greater zero then it draws the game over screen</span>
        else{
<span class="grey">            // draws enemies, bullets and player where they had lastly been</span>
            bloodParticles.forEach((blood)=>{
                blood.draw();
            });

            player.draw();

            bullets.forEach((bullet)=>{
                bullet.draw();
            });

            enemies.forEach((enemy)=>{
                enemy.draw();
            });

            explosionParticles.forEach((particle)=>{
                particle.draw();
            });

            enemies.forEach((enemy)=>{
                enemy.drawHealthBar();
            });

<span class="grey">            // draws game over screen</span>
            c.save();
            c.lineWidth = 5;
            c.fillStyle = 'white';
            c.globalAlpha = 0.4;

            c.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 100, 400, 200);
            c.globalAlpha = 1;
            c.strokeStyle = 'purple';
            c.strokeRect(canvas.width / 2 - 200, canvas.height / 2 - 100, 400, 200);

            c.font = 'normal 35px Arial';
            c.textAlign = 'center';
            c.fillStyle = 'black';
            c.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2 - 50);

            c.font = 'normal 25px Arial';
            c.fillText(`High Score: ${highscore}`, canvas.width / 2, canvas.height / 2);

            c.fillStyle = 'black';
            c.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 25, 200, 50);
            c.fillStyle = 'purple';
            c.strokeRect(canvas.width / 2 - 100, canvas.height / 2 + 25, 200, 50);

            c.fillStyle = 'purple';
            c.fillText('Play Again!', canvas.width / 2, canvas.height /2 + 60)
            c.restore();

<span class="grey">            // adds click event listener that runs the restart function</span>
            canvas.addEventListener('click', restart);
        }

        c.save();

<span class="grey">        // sets the health bar</span>
        c.fillStyle = 'red'
        c.globalAlpha = 0.6;
<span class="grey">         // it multiplies the width with (health / 100) so that
        // as the health decreases the width gets smaller</span>
        c.fillRect(canvas.width - (canvas.width / 2), 15, ((canvas.width / 2) - 20) * (health / 100), 15);
        c.globalAlpha = 1;
        c.lineWidth = 2;
        c.strokeStyle = 'purple';
        c.strokeRect(canvas.width - (canvas.width / 2), 15, (canvas.width / 2) - 20, 15);

<span class="grey">        // draws a border around the canvas</span>
        c.lineWidth = 3;
        c.strokeRect(0, 0, canvas.width, canvas.height);

<span class="grey">        // sets the kills count</span>
        c.alignText = 'left';
        c.fillStyle = 'pink';
        c.font = 'normal 25px Arial';
        c.fillText(`Kills: ${score}`, 10, 30);

        c.restore();</span>
    } 

<span class="grey">    // if page is not viewed then draws the pause screen</span>
    else{
        c.save();
<span class="orange">        c.fillStyle = 'black';
        c.fillRect(0, 0, Cwidth, Cheight);</span>
        c.font = 'normal 24px Arial';
        c.alignText = 'left';
        c.fillStyle = <span class="orange">'purple'</span>;
        c.fillText('The game is paused', 10, 30);
        c.strokeStyle = <span class="orange">'purple'</span>;
        c.lineWidth = 3;
        c.strokeRect(0, 0, canvas.width, canvas.height);
        c.restore();
    }
    requestAnimationFrame(animate);
}

<span class="grey">// begins the animation</span>
animate();

}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas29"></canvas>

<script>
    if(true){
    let canvas = document.querySelector('#canvvaas29');
    let c = canvas.getContext('2d');
    
    // sizes the canvas
    canvas.width = 600;
    canvas.height = 500;
    
    // sets the original background of the canvas before animation begins
    c.save();
    c.fillStyle = 'black';
    c.fillRect(0, 0, canvas.width, canvas.height);
    c.restore();
    // creates an imageData variable 
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
    // my particles
    let bullets = new Array();
    let enemies = new Array();
    let bloodParticles = new Array();
    let explosionParticles = new Array();
    let player;
    
    // health, score and highscore variables
    let score = 0;
    let highscore = 0;
    let health = 100;
    
    // function that checks wether element is scrolled into view or not
    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }
    
    // event that let us know whether the window is viewed or not
    let pageIsViewed = 'unknown';
    
    document.body.onmouseover = (e)=>{
            pageIsViewed = true; 
    }
    
    window.addEventListener("visibilitychange", (e)=>{
        if(pageIsViewed == true | pageIsViewed == 'unknown'){
            pageIsViewed = false;
        } else if(pageIsViewed == false){
            pageIsViewed = true;
        }
    });
    
    // functions that are used to detect collisions
    
        // constructor used to create hitboxes at the edges of the canvas 
        let wall = class{
            constructor(x, y, velocity){
                this.x = x;
                this.y = y;
                this.r = 0;
                this.velocity = {
                    x: 0,
                    y: 0
                }
                this.mass = 999;
            }
        }
    
        // gets the distance between two particles
        let getDistance = function(thisEnemy, otherEnemy){
            let Vx = thisEnemy.x - otherEnemy.x;
            let Vy = thisEnemy.y - otherEnemy.y;
            let distance = Math.hypot(Vx, Vy) - thisEnemy.r - otherEnemy.r;
            return distance;
        }
    
        // rotates the axis so that the final velocities can be calculated 
        let rotate = function(velocity, angle){
            let rotatedVelocities = {
                x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
            }
            return rotatedVelocities;
        }
    
        // calculates and sets the final velocities after the collision
        let changeVelocity = function(thisParticle, otherParticle){
            let [x1, x2] = [thisParticle.x, otherParticle.x];
            let [y1, y2] = [thisParticle.y, otherParticle.y];
            let [v1, v2] = [thisParticle.velocity, otherParticle.velocity];
            let [m1, m2] = [thisParticle.mass, otherParticle.mass];
    
            let xVelocityDiff = v1.x - v2.x;
            let yVelocityDiff = v1.y - v2.y;
            let xDist = x2 - x1;
            let yDist = y2 - y1;
    
            if(xVelocityDiff * xDist + yVelocityDiff * yDist >= 0){
                let angle = -Math.atan2(y2 - y1, x2 - x1);
    
                let rotatedV1 = rotate(v1, angle);
                let rotatedV2 = rotate(v2, angle);
    
                let rotatedV1final = {
                    x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2),
                    y: rotatedV1.y
                }
    
                let rotatedV2final = {
                    x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2),
                    y: rotatedV2.y
                }
    
                let finalV1 = rotate(rotatedV1final, -angle);
                let finalV2 = rotate(rotatedV2final, -angle);
    
                thisParticle.velocity = finalV1;
                otherParticle.velocity = finalV2;
            }
        }
    
    // code for the player 
    
    let playerMaker = class{
        constructor(x, y, r, cl, velocity, mass){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.mass = mass;
            this.collapsed = -1;
            this.cooldown = -1;
            this.dmg_duration = 0;
        }
    
        draw(){
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
        }
    
        update(enemies){
    
            // if key.up is true makes player move up and increases mass
            if(keys.up){
                this.mass = 2.2;
                this.velocity.y = -1.5;
            } 
            
            // else if key.down is true increases mass but makes player move down
            else if(keys.down){
                this.mass = 2.2;
                 this.velocity.y = 1.5;
            }
    
            // else if this.collapsed is less than zero it sets mass to 1 and velocity.y to zero
            else if(this.collapsed < 0){
                this.mass = 1;         
                this.velocity.y = 0;
            }
    
            // if key.right is true makes player move to right and increases mass
            if(keys.right){
                this.mass = 2.2;
                this.velocity.x = 1.5;
            } 
            
            // else if keys.left is true increases mass but makes player move to left
            else if(keys.left){
                this.mass = 2.2;
                this.velocity.x = -1.5;
            } 
            
            // else if this.collapsed is less than zero it sets mass to 1 and velocity.x to zero
            else if(this.collapsed < 0){
                this.velocity.x = 0;
                this.mass = 1;         
            }
    
            // decreases collapsed property
            this.collapsed -= 1;
    
            // detects collision with the enemies
            enemies.forEach((enemy)=>{
                if(getDistance(this, enemy) < 0){
                    changeVelocity(this, enemy);
                    if(this.cooldown < 0){
                        enemy.was_hit = enemy.cooldown;
                        this.cooldown = enemy.cooldown;
                        this.dmg_duration += enemy.damage_duration;
                        let interval = setInterval(()=>{
                            health -= enemy.dmg;
                            if(health < 0){
                                health = 0;
                            }
                            if(this.dmg_duration <= 0){
                                clearInterval(interval);
                            }
                            this.dmg_duration -= 1;
                        }, 200);
                    }
                }
            });
    
            this.cooldown -= 1;
    
            // checks for overlapping
            enemies.forEach((enemy)=>{
                if(getDistance(this, enemy) < -3){
                    changeVelocity(this, enemy);
                    this.collapsed = 2;
                }
            });
    
            // set hitboxes at the edges of the canvas
            let rightWall = new wall(canvas.width, this.y)
            let leftWall = new wall(0, this.y);
            let topWall = new wall(this.x, 0);
            let bottomWall = new wall(this.x, canvas.height);
    
            // detects collisions with the edges of the canvas
            if(getDistance(this, rightWall) < 0){
                changeVelocity(this, rightWall);
            }
    
            if(getDistance(this, topWall) < 0){
                changeVelocity(this, topWall);
            }
    
            if(getDistance(this, leftWall) < 0){
                changeVelocity(this, leftWall);
            }
    
            if(getDistance(this,  bottomWall) < 0){
                changeVelocity(this, bottomWall);
            }
    
            // updates x and y positions
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
        }
    }
    
    let Cwidth = canvas.width;
    let Cheight = canvas.height;
    
    // creates the player
    player = new playerMaker(Cwidth/2, Cheight/2, 15, 'orange', {x: 0, y: 0}, 1);
    
    // object that lets us know what keys are being pressed
    let keys = {
        up: false,
        right: false, 
        down: false,
        left: false
    }
    
    // event listener that updates keys object when a key is pressed
    addEventListener('keydown', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = true;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = true;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = true;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = true;
        }
    });
    
    // event listener that updates keys object when a key is released
    addEventListener('keyup', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = false;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = false;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = false;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = false;
        }
    });
    
    // code for the bullets
    
        // bullets constructor
        let bullet = class{
            constructor(x, y, r, cl, velocity, mass){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
                this.mass = mass;
                this.opacity = 1;
            }
    
            draw(){
                c.save();
                c.globalAlpha = this.opacity;
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.stroke();
                c.restore();
            }
    
            update(){
    
                // updates the x and y position
                this.x += this.velocity.x;
                this.y += this.velocity.y;
    
                this.draw();
            }
        }
    
        // bullets generator
    
        // variable that determines wether mouse is down or not
        let mousedown = false;
    
        // an object to save the mouse's position 
        let mouse = {
            x: 0,
            y: 0
        }
    
        // updates the mouse position as it moves around the canvas
        canvas.addEventListener('mousemove', (e)=>{
            mouse.x = e.offsetX;
            mouse.y = e.offsetY;
        });
    
        // event that triggers when mouse button is pushed down
        canvas.addEventListener('mousedown', (e)=>{
            // prevents default behaviour
            e.preventDefault();
    
            // sets mousedown to true
            mousedown = true;
    
            // sets an interval
            let interval = setInterval(()=>{
                let r = 3;
                let cl = 'grey'
                let x = player.x;
                let y = player.y;
                let vx = mouse.x - x;
                let vy = mouse.y - y;
    
                // gets angle and sets velocities
                let angle = Math.atan2(vy, vx);
                let velocity = {
                    x: Math.cos(angle) * 4,
                    y: Math.sin(angle) * 4
                }
    
                let mass = 3;
    
                // creates bullets if gave hasn't ended
                if(health > 0){
                    bullets.push(new bullet(x, y, r, cl, velocity, mass));
                }
            }, 200);
    
            // checks if mousedown is false to clear the interval above
            let interval2 = setInterval(()=>{
                if(mousedown == false){
                    clearInterval(interval);
                    clearInterval(interval2);
                }
            }, 1);
        });
    
        // event that triggers when mouse button is released
        window.addEventListener('mouseup', (e)=>{
            // sets mousedown to false
            mousedown = false;
        });
    
    // blood constructor
    
    let blood = class{
        constructor(x, y, r, cl, velocity){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.friction = 0.93;
            this.life_time = 1;
        }
    
        draw(){
            c.save();
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.restore();
        }
    
        update(){
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
    
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
    
            this.life_time -= 0.15;
        }
    }
    
    // explosion constructor
    
    let explosion = class{
        constructor(x, y, r, cl, velocity){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.friction = 0.99;
            this.gravity = 0.01;
            this.alpha = 1;
        }
    
        draw(){
            c.save();
            c.globalAlpha = this.alpha;
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
            c.fill();
            c.stroke();
            c.restore();
        }
    
        update(){
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
    
            this.velocity.y += this.gravity;
    
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
    
            this.alpha -= 0.01;
        }
    }
    
    // code for enemies
    
        // enemies constructor
        let enemyConstructor = class{
            constructor(x, y, r, cl, velocity, speed, mass, cooldown, damage_dur, damage, health){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
                this.speed = speed;
                this.mass = mass;
                this.original_mass = mass;
                this.player_collapsed = -1;
                this.enemy_collapsed = -1;
                this.has_entered_canvas = false;
                this.stroke = 'black';
                this.maxHealth = health;
                this.health = health;
                this.damage_duration = damage_dur;
                this.dmg_duration = 0;
                this.dmg = damage;
                this.cooldown = cooldown;
                this.was_hit = -1;
            }
    
            draw(){
                c.save();
                c.strokeStyle = this.stroke;
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.stroke();
                c.restore();
            }
    
            drawHealthBar(){
                c.fillStyle = 'red';
                c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5);
                c.fillStyle = 'green';
                c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2) * (this.health / this.maxHealth), 3.5);
                c.save();
                c.lineWidth = 2;
                c.strokeStyle = 'black';
                c.strokeRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5);  
                c.restore();
            }
    
            update(otherEnemies, bullets){
                // gets angle between enemy and player
                let vx = player.x - this.x;
                let vy = player.y - this.y;
                let angle = Math.atan2(vy, vx);
                
                // if no collisions have happened the enemy moves towarsd the player
                if(this.player_collapsed < 0 && this.enemy_collapsed < 0){
                    this.stroke = 'black';
                    // sets velocities to follow the player
                    this.velocity.x = Math.cos(angle) * this.speed;
                    this.velocity.y = Math.sin(angle) * this.speed;
                } 
                // if the enemy collapsed with the player the velocities are being decreased
                else if(this.player_collapsed > 0){
                    this.velocity.x *= 0.5;
                    this.velocity.y *= 0.5;
                } 
    
                // deacreases enemy_collapsed and player_collapsed properties
                this.enemy_collapsed -= 1;
                this.player_collapsed -= 1;
    
                // sets mass to original mass
                this.mass = this.original_mass;
    
                // collision with other enemies
                otherEnemies.forEach((enemy)=>{
                    if(enemy != this){
                        if(getDistance(this, enemy) < 0){
                            changeVelocity(this, enemy);
                            if(this.enemy_collapsed < 0.5){
                                this.enemy_collapsed = 0.5;
                            }
                        }
                    }
                });
    
                // collision with the player
                if(getDistance(this, player) < 0){
                    changeVelocity(this, player);
                    this.player_collapsed = 1;
                    if(this.was_hit < 0){
                        this.dmg_duration += this.damage_duration;
                        let interval = setInterval(()=>{
                            health -= this.dmg;
                            if(health < 0){
                                health = 0;
                            }
                            if(this.dmg_duration <= 0){
                                clearInterval(interval);
                            }
                            this.dmg_duration -= 1;
                        }, 200);
                        // sets a cooldown
                        this.was_hit = this.cooldown;
                        player.cooldown = this.cooldown;
                    }
                }
    
                // decreases cooldown
                this.was_hit -= 1;
    
                // collision with bullets
                bullets.forEach((bullet, i)=>{
                    if(getDistance(this, bullet) < 0){
                        changeVelocity(this, bullet);
                        // makes bullet invisible
                        bullet.opacity = 0;
                        this.enemy_collapsed = 4;
                        this.stroke = 'pink';
                        this.health -= 20;
                        // prevents health from becoming less than zero
                        if(this.health < 0){
                            this.health = 0;
                        }

                        // sets number of blood particles to be created  
                        let bloodCount = 20;
                        // devides a full circle by the number of blood particles
                        let angleIncrement = Math.PI * 2 / bloodCount;
    
                        // a loop that creates the blood particles
                        for(let i = 0; i < bloodCount; i++){
                            let velocity = {
                                x: Math.cos(angleIncrement * i) * Math.random() * 2,
                                y: Math.sin(angleIncrement * i) * Math.random() * 2
                            }
                            let x = this.x;
                            let y = this.y;
                            let r = this.r / 3;
                            let color = 'red';
                            bloodParticles.push(new blood(x, y, r, color, velocity));
                        }
                    }
                });
    
                // checks for overlapping between the enemies
                otherEnemies.forEach((enemy)=>{
                    if(enemy != this){
                        if(getDistance(this, enemy) < -3){
                            changeVelocity(this, enemy);
                            this.enemy_collapsed = 2;
                            this.mass = 2;
                        }
                    }
                });
    
                // checks for overlapping between player and enemy
                if(getDistance(this, player) < -3){
                    changeVelocity(this, player);
                        this.enemy_collapsed = 2;
                        this.mass = 4;
                }
    
                // creates hit boxes at the edges of the canvas
                let rightWall = new wall(canvas.width, this.y)
                let leftWall = new wall(0, this.y);
                let topWall = new wall(this.x, 0);
                let bottomWall = new wall(this.x, canvas.height);
    
                // checks if has_enter_canvas is false
                if(this.has_entered_canvas == false){
                    // checks if particle has entered the canvas
                    if((this.x  - this.r > 0 && this.x + this.r < canvas.width) && 
                    (this.y - this.r > 0 && this.y + this.r < canvas.height)){
                        // sets has_entered_canvas to true
                        this.has_entered_canvas = true;
                    }
                } 
                
                // if has_enter_canvas is true then it checks for wall collisions
                else{
                    if(getDistance(this, rightWall) < 0){
                        changeVelocity(this, rightWall);
                    }
    
                    if(getDistance(this, topWall) < 0){
                        changeVelocity(this, topWall);
                    }
    
                    if(getDistance(this, leftWall) < 0){
                        changeVelocity(this, leftWall);
                    }
    
                    if(getDistance(this,  bottomWall) < 0){
                        changeVelocity(this, bottomWall);
                    }
                }
    
                // updates x and y positions
                this.x += this.velocity.x;
                this.y += this.velocity.y;
    
                this.draw();
            }
        }
    
        // enemies generator 
    
        // creates different type of enemies
        // radius, color, speed, mass, cooldown, damage_duration, damage, health
        let normalEnemy = [15, 'green', function(){return 0.4 + Math.random()}, 1.1, 6, 0.5, 1, 100];
        let tankEnemy = [25, 'rgba(43, 93, 50, 1)', function(){return 0.1 + Math.random()}, 2, 6, 1, 2, 400];
        let kidEnemy = [12, '#5dcc70', function(){return 1 + Math.random()}, 0.9, 6, 0.25, 0.5, 50];
        let enemyTypes = [kidEnemy, normalEnemy, normalEnemy, normalEnemy, tankEnemy];
    
        // sets an interval that spawns enemies
        setInterval(()=>{
            // randomly selects e type of enemy
            let enemy = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            let r = enemy[0];
            let x, y;
    
            // spawns the enemy randomly outside the canvas
            if(Math.random() < 0.5){
                x = (Math.random() < 0.5)? 0 - r: canvas.width + r;
                y = Math.random() * canvas.height;
            } else{
                x = Math.random() * canvas.width;
                y = (Math.random() < 0.5)? 0 - r: canvas.height + r;
            }
    
            let color = enemy[1];
            let velocities = {x: 0, y: 0}
            let speed = enemy[2]();
            let mass = enemy[3];
            let cooldown = enemy[4];
            let dmg_duration = enemy[5];
            let dmg = enemy[6];
            let health = enemy[7];
    
            // max enemies that can spawn
            let maxEnemies = 20;
    
            // checks if max enemies have been spawned
            if(enemies.length < maxEnemies){
                // checks if game is started and active
                if((isScrolledIntoView(canvas) && (pageIsViewed | pageIsViewed == 'unknown')) && health > 0){
                    enemies.push(new enemyConstructor(x, y, r, color, velocities, speed, mass, cooldown, dmg_duration, dmg, health));
                }
            }
        }, 3000);
    
    // function that restarts the game
    function restart(e){
        // checks if the mouse position is over the button
        if((e.offsetX > canvas.width / 2 - 100 && e.offsetX < canvas.width / 2 - 100 + 200) &&
        (e.offsetY > canvas.height / 2 + 25 && e.offsetY < canvas.height / 2 + 25 + 50)){
            // restores health and score variables 
            health = 100;
            score = 0;
    
            // empties all arays and repositions player
            enemies = [];
            bullets = [];
            bloodParticles = [];
            explosionParticles = [];
            player.x = canvas.width / 2;
            player.y = canvas.width / 2;
    
            // draws background
            c.save();
            c.fillStyle = 'black';
            c.fillRect(0, 0, Cwidth, Cheight);
            c.restore();
    
            // updates imageData to remove blood from screen
            imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        }
    }
    
    // function that runs again and again to animate the canvas
    let animate = function(){
        // checks if canvas is scrolled into view and page is viewed
        if((pageIsViewed == true | pageIsViewed == 'unknown') && isScrolledIntoView(canvas)){
            // draws the canvas black
            c.save();
            c.fillStyle = 'black';
            c.fillRect(0, 0, Cwidth, Cheight);
            c.restore();
            // adds the blood on the canvas
            c.putImageData(imageData, 0, 0);
    
            // checks if health is greater than zero
            if(health > 0){
    
                // updates blood
                bloodParticles.forEach((blood, i)=>{
                    blood.update();
                    if(blood.life_time < 0){
                        bloodParticles.splice(i, 1);
                    }
                });
                
                // updates imageData after new blood has been added, before anything else is drawn
                imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
                // updates bullets
                bullets.forEach((bullet, i)=>{
                    // if bullet leaves the canvas viewport it removes the bullet
                    if(bullet.x - bullet.r < 0 |
                    bullet.x > Cwidth - bullet.r |
                    bullet.y - bullet.r < 0 |
                    bullet.y > Cheight - bullet.r){
                        bullets.splice(i, 1);
                    }
                    // if bullet's opacity is 0 it removes the bullet
                    if(bullet.opacity == 0){
                        bullets.splice(i, 1);
                    }
                    bullet.update();
                });
    
                // updates the player
                player.update(enemies);
    
                // an array I will use to store the 
                // indexes of the enemies I want to remove, 
                // I do this because I don't want to remove 
                // an enemy before the forEach loop is over, 
                // because if I do this creates a little flash 
                // effect to all the enemies that I don't like
                let enemiesToBeRemoved = new Array();

                // checks if there are enemies to be removed
                enemies.forEach((enemy, i)=>{
                    // checks if health is less than zero
                    if(enemy.health <=0){
                        console.log(enemy.health);
                        // increases score
                        score += 1;
                        // if score is bigger than highscore updates highscore
                        if(score > highscore){
                            highscore = score;
                        }

                        // adds the index of the enemy that passed the text into the 
                        // enemiesToBeRemoved array so that he gets removed 
                        // right after the forEeach loop has finished
                        enemiesToBeRemoved.push(i);
    
                        // sets number of explosion particles to be created
                        let particlesCount = 30;
                        // devides a full circle by the number of explosion particles
                        let angleIncrement = Math.PI * 2 / particlesCount;
    
                        // a loop that creates the explosion particles
                        for(let i = 0; i < particlesCount; i++){
                            let velocity = {
                                x: Math.cos(angleIncrement * i) * Math.random() * 3,
                                y: Math.sin(angleIncrement * i) * Math.random() * 3
                            }
                            let x = enemy.x;
                            let y = enemy.y;
                            let r = enemy.r / 5;
                            let color = enemy.cl;
                            explosionParticles.push(new explosion(x, y, r, color, velocity));
                        }
                    }
                });

                // removes the enemies that had health less than zero 
                // before when checked
                enemiesToBeRemoved.forEach((index, i)=>{
                    enemies.splice(index, 1);
                });
                
                // empties the enemiesToBeRemoved array
                enemiesToBeRemoved = [];

                // updates the enemies
                enemies.forEach((enemy)=>{
                    enemy.update(enemies, bullets);
                });
    
                // updates the explosion particles
                explosionParticles.forEach((particle, i)=>{
                    particle.update();
                    // if opacity is less or equal to zero it removes particle 
                    if(particle.alpha <= 0){
                        explosionParticles.splice(i, 1);
                    }
                });
    
                // updates the health bars of the enemies
                enemies.forEach((enemy)=>{
                    enemy.drawHealthBar();
                });
    
                // removes the click event listener that restarts the game
                canvas.removeEventListener('click', restart);
            } 
            
            // if health is not zero then it draws the game over screen
            else{
                // draws enemies, bullets and player where they had lastly been
                bloodParticles.forEach((blood)=>{
                    blood.draw();
                });
    
                player.draw();
    
                bullets.forEach((bullet)=>{
                    bullet.draw();
                });
    
                enemies.forEach((enemy)=>{
                    enemy.draw();
                });
    
                explosionParticles.forEach((particle)=>{
                    particle.draw();
                });
    
                enemies.forEach((enemy)=>{
                    enemy.drawHealthBar();
                });
    
                // draws game over screen 
                c.save();
                c.lineWidth = 5;
                c.fillStyle = 'white';
                c.globalAlpha = 0.4;
    
                c.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 100, 400, 200);
                c.globalAlpha = 1;
                c.strokeStyle = 'purple';
                c.strokeRect(canvas.width / 2 - 200, canvas.height / 2 - 100, 400, 200);
    
                c.font = 'normal 35px Arial';
                c.textAlign = 'center';
                c.fillStyle = 'black';
                c.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2 - 50);
    
                c.font = 'normal 25px Arial';
                c.fillText(`High Score: ${highscore}`, canvas.width / 2, canvas.height / 2);
    
                c.fillStyle = 'black';
                c.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 25, 200, 50);
                c.fillStyle = 'purple';
                c.strokeRect(canvas.width / 2 - 100, canvas.height / 2 + 25, 200, 50);
    
                c.fillStyle = 'purple';
                c.fillText('Play Again!', canvas.width / 2, canvas.height /2 + 60)
                c.restore();
    
                // adds click event listener that runs the restart function
                canvas.addEventListener('click', restart);
            }
    
            c.save();
    
            // sets the health bar
            c.fillStyle = 'red'
            c.globalAlpha = 0.6;
            c.fillRect(canvas.width - (canvas.width / 2), 15, ((canvas.width / 2) - 20) * (health / 100), 15);
            c.globalAlpha = 1;
            c.lineWidth = 2;
            c.strokeStyle = 'purple';
            c.strokeRect(canvas.width - (canvas.width / 2), 15, (canvas.width / 2) - 20, 15);
        
            // draws a border around the canvas
            c.lineWidth = 3;
            c.strokeRect(0, 0, canvas.width, canvas.height);
    
            // sets the kills count
            c.alignText = 'left';
            c.fillStyle = 'pink';
            c.font = 'normal 25px Arial';
            c.fillText(`Kills: ${score}`, 10, 30);
    
            c.restore();
        } 
        
        // if page is not viewed then draws the pause screen
        else{
            c.save();
            c.fillStyle = 'black';
            c.fillRect(0, 0, Cwidth, Cheight);
            c.font = 'normal 24px Arial';
            c.alignText = 'left';
            c.fillStyle = 'purple';
            c.fillText('The game is paused', 10, 30);
            c.strokeStyle = 'purple';
            c.lineWidth = 3;
            c.strokeRect(0, 0, canvas.width, canvas.height);
            c.restore();
        }
        requestAnimationFrame(animate);
    }
    
    // begins the animation
    animate();
    
    }
    </script>

<h2>What new did I add?</h2>

<p>So, as you can see I added quite few new things to the game, enough 
that this could actually be considered a finished game at this point, so what exactly did I add?
I made <Span>bullet collisions</span> so that <span>enemies can be pushed by bullets</span>
and made it so <Span>bullets turn invisible after colliding with an enemy</span> and 
then <span>removed</span>. I also created <Span>enemy health bars</Span> which 
<Span>decrease when enemy gets hit</span>, and made it so <Span>enemy is removed 
when health reaches zero</span>. After that, to make the game more interesting 
I created some <Span>effects</span>, I made it so <span>blood particles spawn when 
enemy is hit</span> and made it so <Span>the blood is redrawn over and over again on the canvas</span> 
using <span>getImageData and putImageData</span> so that I don't have to keep updating 
the <Span>blood particles</span> over and over again which would effect the performance. 
I also made it so <Span>particles of the same color with the enemy explode</span> after 
the <span>enemy dies</span>. Then I worked on the <Span>player</span>, I created 
a <Span>healthbar</span> and made it so it <Span>decreases when player is touched by an enemy</span>, 
I also created a <span>kill count</span> that <span>increases when an enemy dies</span> 
and made it so <Span>when player's health reaches 0</span> the <Span>game freezes</Span>
and a <Span>game over screen appears</span> which writes your <span>highscore</span> 
and has a <Span>button</span> that you can <Span>click to play again</span>. Lastly, 
I made <span>different type of enemies</span> that <Span>spawn randomly</span>. I also 
made some other changes, like, I changed it so instead of multiplying the <Span>enemy's velocities</span> 
with 0 every time the <Span>player</span> collids with the <span>enemy</span> it multiplies it with 0.5, and that's because
I wanted to make sure the <span>enemy</span> never completely stops moving by continiously making contact with 
the <Span>player</span>, and I also did some other stuff like, I made the <span>radius</span> of the <Span>player</span>
bigger, changed <Span>bullet's color</span> and did other decorations too.

<h2>Bullets collisions and enemy healthbars</h2>

<p>First thing I did was <Span>add a mass to the bullets</span>, then I also created
an <Span>opacity property</span> so that I can use it to <Span>set globalAlpha canvas property</span> 
and <Span>change transperency</span>. Then I made it so every time an <Span>enemy updates</span> 
it <Span>loops through all the bullets</span> and
checks if their <Span>distance is less than 0</span>, if true then 
it <span>calculates and sets the final velocities</span> and 
<Span>changes opacity property of bullets to 0</span>, it also 
sets <span>enemy_collapsed to 4</span> and that's because 
I want the <Span>enemy's velocity</span> to not 
change for a while after being hit, however if the 
<Span>enemy collided with another enemy</span> then the 
<Span>enemy_collapsed property</span> would be set to 
<span>0.5</span>, so, I had to either <Span>make a different property</span> 
to use or <span>make it so it only changes to 0.5 if it is less than 0.5</span>, 
I already have made a lot of weird properties so I chose the second trick.</p>
<p>To make sure the <Span>bullet</span> is <Span>removed after the collision</span>
I made it so it <span>checks if opacity of the property is 0 before updating it</span> 
and made it so that if true it <span>removes the bullet from the array</span>.

<p>After I added the collisions all that was left was to add the <Span>healthbars</span> and 
make it so they <span>decrease when enemies get hit</span> and make it so <Span>enemies can die</span>. For this 
I added a <Span>health property</span> to the <span>enemy</span>, which property will <Span>decrease every time the enemy is hit</span>, 
however, because I also needed a way to keep track of the <span>max health of the enemies</span> that's why I also 
created <Span>maxHealth property</span> which <span>stays static at all times</span>. So, every time a 
<span>bullet collids with the enemy</span> the <span>health is decreased by 20</span> and I made 
it so it then <Span>checks if health is less than zero</span> and <Span>set it to zero if it is</span>, 
so that it can <Span>never be less than zero</span>. So, after that I had to <Span>draw the healthbars</span>, 
the problem was I wanted to make sure that the <Span>healthbars are down always over all the enemies</span>, 
so that <Span>if one enemy is next to another he can't hide the other's healthbar</span>, to do this I created the 
<Span>drawHealthBar method</span> which I called for <Span>all enemies</span> only <span>after the enemies had already been drawn</span>. 
I made it so that the <Span>healthbar is drawn 7 pixels over the enemy</span> and 
made the <Span>width</span> be <Span>equal to enemy's radius * 2</span>, then, 
to make it <span>decrease as health decreases</span> I <Span>multiplied width with this.health / this.maxHealth</span>.
To make the <Span>enemy disappear after his health reaches 0</span>
I made it so that every time the <Span>enemies get updated</span> inside the 
<Span>animate function</span>, it <span>checks if health of the enemy is less than 0</span> 
and <Span>remove the enemy if it is</span>, however, this would create a 
<Span>weird flash effect</span> for a second, because the <Span>enemies array</span> 
could be changed before the <span>forEach loop</span> has finished, 
to fix that I made sure to <Span>remove the enemies after the loop is over</span>, 
which fixed the issue.</p>

<h2>Blood, explosion and other hit effects</h2>

<p>So, I wanted the <Span>player</span> to feel well after <Span>hitting an enemy</span>, and to do this 
I had to <Span>add effects</span>, first I created a <Span>stroke property which I set to black</span>, and made 
it so <Span>it's value is used to set the strokeStyle when drawing the enemy</span>, then I made it so the 
<Span>stroke property is set to pink after bullet hits the enemy</span> and <Span>set back to black after the enemy 
starts following the player again</span>. 

<p>After that I created the <Span>blood</span>, the <Span>constructor</span> is simple, it simple 
creates <Span>arcs</span>, has a <Span>velocity</span> and a <Span>friction</span>, I also created a
<Span>life_time property</span> so that I can use this to <span>remove the object from the bloodParticles array when not anymore needed</span>, 
which I had to do to prevent performance issues. So, the <Span>update method</span> is simple, it 
<Span>multiples velocities with friction</span>, <Span>increases x and y by velocities</span> and 
<Span>decreases life_time</span>. I then created the <Span>bloodParticles array</span>, and inside the 
<Span>animate function</span> made it <Span>loop through the array and update it's items</span> as well 
as <Span>check if life_time is less than 0</span> to <span>remove the items when not anymore needed</span>. With that, 
all that's left is to <Span>create the blood particles</span>, to do so I simple created a 
<span>loop</span> that creates <Span>20 blood particles</span> every time an <Span>enemy is hit by a bullet</span>, 
I set their <Span>radius to be 3 times smaller than the enemy</span>, their <Span>y and x to be the same with the enemy</span> 
and I <Span>set their velocities so that they move towards all directions</span>, exactly how I made the 
<Span>fireworks</span> in a <Span>previous section</span>, I recommend you check this out since I have explained 
how it works there. With that the <Span>blood would spawn</span>, however, after <Span>life_time became less than 0</span> 
the <span>blood would disappear</span>, that's why I created the <Span>imageData variable</span>, I made it so the 
<Span>blood is the first particles to be drawn on the canvas after it has been cleared at the start of each iteration</span>, 
and used <span>getImageData()</span> to <span>update the imageData variable</span>, with that, I could then simple 
use <span>putImageData(imageData, 0, 0)</span> at the <Span>start of the animate function</span> every time I <Span>cleared the canvas</span> 
to <Span>add the blood</span>, because however it would throw an <Span>error</span> in the <span>first iteration</span> 
since it would <Span>had not yet set the imageData variable</span>, I made sure I already <Span>set it once before the animate function starts looping</span>.</p>

<p>To create the <span>explosion particles</span> I used the same trick, with some changes, I added <span>gravity</span>, 
made them <Span>faster</span> and made it so their <Span>opacity decreases</span> till they <Span>become invisible</span>, 
I then made it so that <Span>if their opacity is less or equal to 0 they are removed</span>, this created 
exactly the <Span>fireworks effect</span> I had created in a previous section, I made it so the <Span>explosion particles</span>
are only created <Span>when the enemy's health is 0 or less</span>.
</p>

<h2>The different type of enemis</h2>

<p>To make the game more entartaining, I decided to create 
<Span>multiple types of enemies</span>, more specifically, I have the 
<Span>normal enemy</span>, <Span>kid enemy</span> and <Span>tank enemy</Span>, 
they all have <Span>different speed, health, radius and color</span>. To make them 
<Span>randomly be selected while generating the enemis</span> I simple <Span>added them in an array</Span>
and made it so <Span>a random array's item is selected</span> similarly to how I did that with colors in previous sections, 
to make it so the <span>normal enemies</span> have more chances to spawn, I simple <Span>added normal player multiple times in the array</span>, 
and only added <Span>tank and kid once</span>.

<h2>Player's health bar</h2>

<p>To create the <Span>player's health bar</span> 
I created a <Span>health variable</span> called 
<span>health</span>, I created the <Span>health bar</span>
similarly how I created the <Span>enemy healthbars</span>, 
however, I drew it inside the <Span>animate function</span>, I made 
it so the <Span>x of the health bar</span>  is at <Span>half of the canvas</span>, 
and the <Span>width is half the canvas - 20</span>, thus making sure it <Span>never passes the edges</span>,
then I simple <Span>multipled width with  (health / 100)</span>, assuming that <Span>100 will always be max health</span>, 
and I decorated it a little with a <Span>stroke</span> and <span>opacity</span>.</p>

<p>So, all I had to do now was to find a way to <Span>smoothly decrease the health</span> every time 
the <Span>player touches an enemy</span>, so, to do that, I created <span>three properties</span> to 
the <Span>enemy</span>, <Span>cooldown</span>, which is the <span>time</span> it takes 
till the <Span>enemy can hit you again</span>, the <Span>damage_duration</Span>, which is
<Span>how long your health will be decreasing</span>, and also the <Span>dmg property</span>, 
which is <Span>how much your health will be increased in each iteration of the interval</span>. 
After the <Span>player and enemy collid</span>, I created the <Span>was_hit property</span>, since I wanted the <Span>cooldown property to stay static at all times</span>, 
and made it so every time the <Span>enemy collids with the player</span> it <Span>sets that property to enemy's cooldown</span>, 
I also created a <Span>cooldown property for the player</span> which I also <Span>set to enemy's cooldown</span>, but I will speak about 
the <Span>player</span> later, for now let's see what happens when the <Span>enemy collids the player</span>. 
So, at first I originally have set the <Span>was_hit</span> property to <span>-1</span> and <Span>decrease it by 1 in each iteration</span>, 
when the <Span>enemy collids with the player</span> I <Span>check if was_hit is less than 0</span> and if true, I 
<Span>set this.was_hit to this.cooldown</span>, if <Span>this.cooldown is 6 for example</span> then that 
will make sure the <Span>following code will not run for at least 7 iterations</span> even if the <Span>player collids the enemy again</span>. 
I then created a <Span>dmg_duration</span>, so, I already had the 
<span>damage_duration</span>, but I also needed <Span>another property</span>
which I could <span>change</span>, and that's because after I 
set <Span>dmg_duration to damage_duration</span> I set an 
<span>interval</span>, which <span>keeps decreasing dmg_duration</span> 
after <Span>each iteration</span> and <Span>stops the interval when it reaches 0 or less</span>, 
the reason I made it that way was because I wanted the <Span>health</span> to <Span>smoothly decrease</span>,
in <span>each iteration of the interval</span> I <Span>decreased health by enemy's damage</span>, 
the <Span>enemy's damage was set to be a small number</span>, if 
I wanted the <span>enemy to do more damage</span> I could now simple 
<Span>increase damage_duration</span>, that's what the porpuse of this code was, 
to make a <Span>smooth health transition while also creating a way to change the ammount 
of health an enemy can do</span>. Since there was a chance 
that the <Span>player</span> could <span>collid first with the enemy</span> 
and the <span>enemy collision may didn't be detected</span> 
I also created a similar code inside the <span>player's update</span>,
and made it so it <Span>sets enemy's was hit property to enemy's cooldown</span>, 
so that the <Span>player does not get double damage</span>, and 
I also made it so the <Span>player's cooldown property is set to enemy's cooldown</span>
and used the <Span>enemy's damage duration to set the dmg_duration</span> 
and <Span>enemy's dmg to decrease the health</span>. Now that I think about it, 
this may be a little more complicated than needed, I could had made 
it simplier, but I wanted to make sure that the <Span>health</span> 
is <Span>decreasing smoothly</span>.

<h2>Game Over Screen</h2>

<p>All that was left now was to make it so that a
<Span>game over screen</span> appears after the 
<Span>player's health reaches zero</span>, so that's what I did, 
I think I mentioned before that I used an <Span>if statement</span> 
to check if <Span>health is greater than 0</span> before I 
<span>update the particles</span>, so then I could simple use 
an <span>else statement</span> to set what happens if it's not.
I made it so that the <Span>particles are drawn</span>, but <Span>not updated</span>, thus 
this made it seem as if the <Span>game ahd frozen</span>, then I created an 
<Span>ending screen</span> and added a <Span>click event</span> 
with a <Span>function</span>, inside that <span>restart function</span> 
I simple made it so it <Span>checks wether the click happened within a given range</span> 
and if true I made it to <Span>reset all arrays</span>, <Span>reset player's position</span>
and <Span>reset score and health variables</span>, as well as the <Span>imageData</span> 
to <Span>reset the blood</span>. To prevent the <Span>event</span> from 
<Span>triggering again after game restarts</span>, I simple made it so 
it <Span>removes the event listener</span>
if <Span>health is greater than 0</span>.
</p>

<p>After weeks of developing, I finally finished the game, I added a lot of things, sound effects, joysticks, buttons, some of the 
bugs in the previous versions were fixed, like, for example, some times enemies that were not killed would
disappear, and much much more, I'm not gonna explain the code, since it's very very huge, but here is the project anyway:
</p>

<Style>
    .canvvaas{
        display: block;
        margin: auto;
        border: 3px solid black;
    }
</Style>

<canvas class="canvvaas" id="canvvaas2222"></canvas>

<script>
if(true){

let canvass = document.querySelector('#canvvaas2222');
let canvas = canvass;
let ctx = canvass.getContext('2d');
ctx.fillStyle = "black";
ctx.fillRect(0, 0, canvass.width, canvass.height);
ctx.fillStyle = "white";
ctx.fillText("Loading...", 10, 10);

let links = {
    floorImage: "https://dl.dropbox.com/s/sbwwtp4hb95vh9i/received_2567955930173456.jpeg?dl=0",
    playerImage: "https://dl.dropbox.com/s/s5z9yhvob0nnb0n/player.svg?dl=0",
    normalMonsterImage: "https://dl.dropbox.com/s/a5aj4a4wwsrec1x/monster.svg?dl=0",
    tankMonsterImage: "https://dl.dropbox.com/s/ew3gg4lilfhrog4/monster2.svg?dl=0",
    kidMonsterImage: "https://dl.dropbox.com/s/dhgtrwv6ywl99t6/monster3.svg?dl=0",
    drugsImage: "https://dl.dropbox.com/s/efrtwcnombn1y1q/received_830343984548782.jpeg?dl=0",
    prisonImage: "https://dl.dropbox.com/s/1vy5pthnwflebz0/received_461453375143954.jpeg?dl=0",
    freedomImage: "https://dl.dropbox.com/s/kwwmoechjhk6dtp/received_836036283984327.jpeg?dl=0",
    roadImage: "https://dl.dropbox.com/s/hy27azf3yaq6pb5/received_527549271584619.jpeg?dl=0",
    shockedFace: "https://dl.dropbox.com/s/w5xwps35h5a44ku/shockedface.svg?dl=0",
    policeCar: "https://dl.dropbox.com/s/euqo05t6bxgn2ff/policecar2.svg?dl=0"
}

let image1 = new Image();
let image2 = new Image();
let image3 = new Image();
let image4 = new Image();
let image5 = new Image();
let image6 = new Image();
let image7 = new Image();
let image8 = new Image();
let image9 = new Image();
let image10 = new Image();
let image11 = new Image();

let promises = new Array();

function insertImage(image, src, link){
    promises.push(new Promise((resolve, reject)=>{
        image.crossOrigin = "Anonymous";
        image.alternative = link;      
        image.src = src;

        image.addEventListener('load', (e)=>{
            if(image.naturalWidth == 0 && image.naturalHeight == 0){
                image.src = image.alternative;
                image.addEventListener('load', (e)=>{
                    resolve();
                });
                image.addEventListener('error', (e)=>{
                    resolve();
                });
             } else{
                resolve();
            }
        });
        function error(){
            image.src = image.alternative;
            image.removeEventListener('error', error);
            image.addEventListener('load', (e)=>{
                resolve();
            });
            image.addEventListener('error', (e)=>{
                resolve();
            });
        }
        image.addEventListener('error', error);
    }));
}

insertImage(image1, './../images/grass.jpg', links.floorImage);
insertImage(image2, './../images/player.svg', links.playerImage);
insertImage(image3, './../images/monster.svg', links.normalMonsterImage);
insertImage(image4, './../images/monster2.svg', links.tankMonsterImage);
insertImage(image5, './../images/monster3.svg', links.kidMonsterImage);
insertImage(image6, './../images/drugs.jpg', links.drugsImage);
insertImage(image7, './../images/prison.jpg', links.prisonImage);
insertImage(image8, './../images/freedom.jpg', links.freedomImage);
insertImage(image9, './../images/road.jpg', links.roadImage);
insertImage(image10, './../images/shockedFace.svg', links.shockedFace);
insertImage(image11, './../images/policeCar2.svg', links.policeCar);

let soundEffectsVolume = 100;
let musicVolume = 60;

let bulletCancelTimeout;
let hitMarkerCancelTimeout;
let damageCancelTimeout;
let boomCancelTimeout;
let levelupCancelTimeout;

function playSoundEffect(audio, currentTime, id){
    try{
        if(id == 'bullet'){
            bulletCancelTimeout();
        } else if(id == 'hitmarker'){
            hitMarkerCancelTimeout();
        } else if(id == 'damage'){
            damageCancelTimeout();
        } else if(id == 'boom'){
            boomCancelTimeout();
        } else if(id == 'levelup'){
            levelupCancelTimeout();
        }
    } catch{}
    audio.currentTime = currentTime;
    audio.volume = audio.maxVolume * (soundEffectsVolume / 100);
    let timeout = setTimeout(()=>{
        audio.volume = 0;
    }, (audio.duration - currentTime) * 1000);
    if(id == 'bullet'){
        bulletCancelTimeout = function(){
            clearTimeout(timeout);
        };
    } else if(id == 'hitmarker'){
        hitMarkerCancelTimeout = function(){
            clearTimeout(timeout);
        };
    } else if(id == 'damage'){
        damageCancelTimeout = function(){
            clearTimeout(timeout);
        };
    } else if(id == 'boom'){
        boomCancelTimeout = function(){
            clearTimeout(timeout);
        };
    } else if(id == 'levelup'){
        levelupCancelTimeout = function(){
            clearTimeout(timeout);
        };
    }
}

function startSoundEffectLoop(audio){
    audio.loop = 'true';
    audio.volume = 0;
    audio.play();
}

let boomSoundEffect = new Audio("https://dl.dropbox.com/s/u7y42ulajm3gvkj/boom%20sound%20effect%20%281%29.mp3?dl=0");
boomSoundEffect.preload = "auto";
boomSoundEffect.maxVolume = 1;
boomSoundEffect.id = 'soundEffect';


let hitMarkerEffect = new Audio("https://dl.dropbox.com/s/trr9fq18cgqp5h0/hit%20marker%20sound%20effect.mp3?dl=0");
hitMarkerEffect.preload = "auto";
hitMarkerEffect.maxVolume = 0.5;
hitMarkerEffect.id = 'soundEffect';

let clickSoundEffect = new Audio("https://dl.dropbox.com/s/g21jo0ni69g6ajn/AudioCutter_Sound%20Effects%20Button%20Clicks.mp3?dl=0");
clickSoundEffect.preload = "auto";
clickSoundEffect.maxVolume = 1;
clickSoundEffect.id = 'soundEffect';

buttonSoundEffectStartTime = 0.35;

let levelUpSoundEffect = new Audio("https://dl.dropbox.com/s/h2poo1m912ot6li/levelup.mp3?dl=0");
levelUpSoundEffect.preload = "auto";
levelUpSoundEffect.maxVolume = 1;
levelUpSoundEffect.id = 'soundEffect';

let damageSoundEffect = new Audio("https://dl.dropbox.com/s/v49q5082t9bgax7/Undertale%20Sound%20Effect%20-%20Taking%20Damage.mp3?dl=0");
damageSoundEffect.preload = "auto";
damageSoundEffect.maxVolume = 1;
damageSoundEffect.id = 'soundEffect';

let damageSoundCount = 0;

function playDamageSound(audioObj, time){
    if(damageSoundCount < 1){
        damageSoundCount++
        playSoundEffect(audioObj, time);
        setTimeout(()=>{
        damageSoundCount--
        }, 500);
    }
}

let speechSoundEffect = new Audio("https://dl.dropbox.com/s/7pzasanuc5y2bld/Flowey%20Talking.mp3?dl=0");
speechSoundEffect.preload = 'auto';
speechSoundEffect.maxVolume = 0.3;
speechSoundEffect.id = 'soundEffect';

let bulletSoundEffect = new Audio("https://dl.dropbox.com/s/b0xfcjtdug2bfjp/Realistic%20Gunshot%20Sound%20Effect.mp3?dl=0");
bulletSoundEffect.preload = "auto";
bulletSoundEffect.maxVolume = 0.5;
bulletSoundEffect.id = 'soundEffect';

let swallowSoundEffect = new Audio("https://dl.dropbox.com/s/nm3nbh8vlyh2r0o/swallow%20sound%20effect.mp3?dl=0");
swallowSoundEffect.preload = "auto";
swallowSoundEffect.maxVolume = 1;
swallowSoundEffect.id = 'soundEffect';

let startScreenMusic = new Audio("https://dl.dropbox.com/s/if4soupi69wvmu6/pony%20island%20soundtrack%20-%20pony%20island%20%281%29.mp3?dl=0");
startScreenMusic.preload = 'auto';
startScreenMusic.loop = true;
startScreenMusic.maxVolume = 1;
startScreenMusic.id = 'music';

startScreenMusic.pause();

let musicState = 'ready';

startScreenMusic.addEventListener('canplaythrough', (e)=>{
    musicState = 'ready';
});

// remove it after development is finished
window.addEventListener('load', (e)=>{
    musicState = 'ready';
});

let gameplayMusic1 = new Audio("https://dl.dropbox.com/s/svho3banraimgfu/pony%20island%20soundtrack%20-%20loueys%20playhouse.mp3?dl=0");
gameplayMusic1.preload = 'auto';
gameplayMusic1.loop = true;
gameplayMusic1.maxVolume = 0.8;
gameplayMusic1.id = 'music';

gameplayMusic1.pause();

let gameOverMusic = new Audio("https://dl.dropbox.com/s/s74rtb14vjgcx7a/%28Reupload%29%20The%20End%20Of%20Evangelion%20Komm%2C%20Susser%2C%20Tod%208-Bit%20Remix.mp3?dl=0Aa")
gameOverMusic.preload = 'auto';
gameOverMusic.loop = true;
gameOverMusic.maxVolume = 1;
gameOverMusic.id = 'music';
let gameOverMusicHasStarted = false;

gameOverMusic.pause();

let goodEndingMusic = new Audio("https://dl.dropbox.com/s/96bkzhvdmnt8ccw/pony%20island%20soundtrack%20-%20hop%2C%20skip%2C%20and%20a%20neigh.mp3?dl=0")
goodEndingMusic.preload = 'auto';
goodEndingMusic.loop = true;
goodEndingMusic.maxVolume = 1;
goodEndingMusic.id = 'music';
let goodEndingMusicHasStarted = false;

goodEndingMusic.pause();

let trueEndingMusic = new Audio("https://dl.dropbox.com/s/wmy66632ci0ef40/phoenix%20wrightace%20attorney%20godots%20theme%20remastered.mp3?dl=0")
trueEndingMusic.preload = 'auto';
trueEndingMusic.loop = true;
trueEndingMusic.maxVolume = 1;
trueEndingMusic.id = 'music2';
let trueEndingMusiHasStarted = false;

trueEndingMusic.pause();

function playSound(audioObj, currentTime){
    audioObj.currentTime = currentTime;
    if(audioObj.id == 'music'){
        audioObj.volume = audioObj.maxVolume * (musicVolume / 100);
    }
    if(audioObj.id == 'soundEffect'){
        audioObj.volume = audioObj.maxVolume * (soundEffectsVolume / 100);
    }
    if(audioObj.id == 'music2'){
        audioObj.volume = 1;
    }
    try{
    audioObj.play();
    }catch{}
}

function updateMusicVolume(){
    startScreenMusic.volume = startScreenMusic.maxVolume * (musicVolume / 100);
    gameplayMusic1.volume = gameplayMusic1.maxVolume * (musicVolume / 100);
    trueEndingMusic.volume = trueEndingMusic.maxVolume * (musicVolume / 100);
}

Promise.all(promises).then((image)=>{
    let c = canvas.getContext('2d');

    // puts focus on the window
    window.focus();
    
    // sizes the canvas
    canvas.width = 600;
    canvas.height = 500;
    
    // sets the original background of the canvas before animation begins
    canvas.style.backgroundImage = `url(${image1.src})`;
    c.clearRect(0, 0, canvas.width, canvas.height);
    // creates an imageData variable 
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

    // my particles
    let bullets = new Array();
    let enemies = new Array();
    let bloodParticles = new Array();
    let explosionParticles = new Array();
    let player;
    let expsExplosion = new Array();
    
    // other variables
    let score = 0;
    let highscore = 0;
    let health = 100;
    let exps = 0;
    let maxExps = 100;
    let level = 0;
    let wave = 0;
    let pause = false;
    let hasStarted = false;
    let optionsOpened = false;
    let blood_effect = true;
    let explosion_effect = true;
    let level_up_effect = true;
    let enemiesLeft = wave * 5;
    let hasEnteredTheGame = false;
    let creditsOpened = false;
    let endingScene = 0;
    let opacity = 0;
    let opacityIncrement = 0.001
    let enterGameOpacity = 0;
    let skipinstructions = false;

    // variables that are used to rotate stuff
    let angleIncrement = 0;
    let buttonsIncrement = 0;

    // dialogs variables
    let dialogState;
    let dialogCount = 0;
    
    // object that lets us know what keys are being pressed
    let keys = {
       up: false,
       right: false, 
       down: false,
       left: false
    }
    
    // function that checks wether element is scrolled into view or not
    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= -el.width / 2) && (elemBottom <= window.innerHeight + el.width / 2);
        return isVisible;
    }
    
    // event that triggers whenever visibility of page changes
    window.addEventListener("visibilitychange", (e)=>{
        if(health > 0){
            pause = true;
        }
        keys.right = false;
        keys.left = false;
        keys.down = false;
        keys.up = false;
        try{
            pauseDialogInterval();
        }catch{}
    });
    
    // functions that are used to detect collisions
    
        // constructor used to create hitboxes at the edges of the canvas
        let wall = class{
            constructor(x, y, velocity){
                this.x = x;
                this.y = y;
                this.r = 0;
                this.velocity = {
                    x: 0,
                    y: 0
                }
                this.mass = 999;
            }
        }
    
        // gets the distance between two particles
        let getDistance = function(thisEnemy, otherEnemy){
            let Vx = thisEnemy.x - otherEnemy.x;
            let Vy = thisEnemy.y - otherEnemy.y;
            let distance = Math.hypot(Vx, Vy) - thisEnemy.r - otherEnemy.r;
            return distance;
        }
    
        // rotates the axis so that the final velocities can be calculated 
        let rotate = function(velocity, angle){
            let rotatedVelocities = {
                x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
            }
            return rotatedVelocities;
        }
    
        // calculates and sets the final velocities after the collision
        let changeVelocity = function(thisParticle, otherParticle){
            let [x1, x2] = [thisParticle.x, otherParticle.x];
            let [y1, y2] = [thisParticle.y, otherParticle.y];
            let [v1, v2] = [thisParticle.velocity, otherParticle.velocity];
            let [m1, m2] = [thisParticle.mass, otherParticle.mass];
    
            let xVelocityDiff = v1.x - v2.x;
            let yVelocityDiff = v1.y - v2.y;
            let xDist = x2 - x1;
            let yDist = y2 - y1;
    
            if(xVelocityDiff * xDist + yVelocityDiff * yDist >= 0){
                let angle = -Math.atan2(y2 - y1, x2 - x1);
    
                let rotatedV1 = rotate(v1, angle);
                let rotatedV2 = rotate(v2, angle);
    
                let rotatedV1final = {
                    x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2),
                    y: rotatedV1.y
                }
    
                let rotatedV2final = {
                    x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2),
                    y: rotatedV2.y
                }
    
                let finalV1 = rotate(rotatedV1final, -angle);
                let finalV2 = rotate(rotatedV2final, -angle);
    
                thisParticle.velocity = finalV1;
                otherParticle.velocity = finalV2;
            }
        }
    
    // code for the player  
    let playerMaker = class{
        constructor(x, y, r, cl, velocity, mass){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.mass = mass;
            this.collapsed = -1;
            this.dmg_duration = 0;
            this.maxSpeed = 1.7;
        }
    
        draw(){
            c.strokeStyle = "black";
            c.fillStyle = this.cl;
            c.lineWidth = 1;
            c.globalAlpha = 1;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.stroke();
            let aspectRatio = image2.naturalWidth / image2.naturalHeight;
            if(endingScene == 2){
                c.drawImage(image10, this.x - this.r, this.y - this.r, this.r * 2, (this.r * 2) / aspectRatio);
            } else{
                c.drawImage(image2, this.x - this.r, this.y - this.r, this.r * 2, (this.r * 2) / aspectRatio);
            }
            c.lineWidth = 1;
            c.setTransform(1,0,0,1,0,0)
        }
    
        update(enemies){
    
            // if key.up is true makes player move up and increases mass
            if(keys.up){
                this.mass = 2.2;
                this.velocity.y = -this.maxSpeed;
            } 
    
            // else if key.down is true increases mass but makes player move down
            else if(keys.down){
                this.mass = 2.2;
                 this.velocity.y = this.maxSpeed;
            }
    
            // else if this.collapsed is less than zero it sets mass to 1 and velocity.y to zero
            else if(this.collapsed < 0 && joyStickActive != true){
                this.mass = 1;         
                this.velocity.y = 0;
            }
    
            // if key.right is true makes player move to right and increases mass
            if(keys.right){
                this.mass = 2.2;
                this.velocity.x = this.maxSpeed;
            } 
    
            // else if keys.left is true increases mass but makes player move to left
            else if(keys.left){
                this.mass = 2.2;
                this.velocity.x = -this.maxSpeed;
            } 
    
            // else if this.collapsed is less than zero it sets mass to 1 and velocity.x to zero
            else if(this.collapsed < 0 && joyStickActive != true){
                //this.velocity.x = 0;
                this.mass = 1;         
            }
    
            if(joyStickActive){
                this.mass = 2.2;
            }

            if(dialogCount == 2){
                if(dialogState == 'finished'){
                    if(this.velocity.x != 0 || this.velocity.y != 0){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "That's great! Doesn't it feel nice moving around? Doesn't it make you feel free? It took me quite some time to make the player moveable, but at the end it was worth it, wasn't it?", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 3;
                    }
                }
            }
    
            // decreases collapsed property
            this.collapsed -= 1;
    
            // loops through all the enemies
            enemies.forEach((enemy)=>{
                // checks if distance is less than zero
                if(getDistance(this, enemy) < 0){
                    // checks wether the player is moving or not
                    if(this.mass != 2.2){
                        // if he is not moving, then his mass shouldn't 
                        // be 2.2, so it calculates the final velocities 
                        // of the player and enemy and sets them
                        changeVelocity(this, enemy);
                    }
    
                    // checks if enemy's cooldown is less than zero
                    if(enemy.was_hit < 0){
                        playDamageSound(damageSoundEffect, 0.4);

                        // sets was_hit property of enemy to enemy's cooldown
                        enemy.was_hit = enemy.cooldown;
                        // increases dmg_duration property of player
                        this.dmg_duration += enemy.damage_duration;
                        // sets an interval
                        let interval = setInterval(()=>{
                            //decreases health by enemy's damage in each iteration
                            health -= enemy.dmg;
                            // prevents health from becoming less than zero
                            if(health < 0){
                                health = 0;
                            }
                            // checks if the dmg_duration is less or equal to 0
                            if(this.dmg_duration <= 0){
                                // stops the interval
                                clearInterval(interval);
                            }
                            // decreases dmg_duration by 1 after each iteration of the iinterval
                            this.dmg_duration -= 1;
                        }, 200);
                    }
                }
            });
    
            // checks for overlapping
            enemies.forEach((enemy)=>{
                if(getDistance(this, enemy) < -3){
                    changeVelocity(this, enemy);
                    this.collapsed = 2;
                }
            });
    
            // set hitboxes at the edges of the canvas
            let rightWall = new wall(canvas.width, this.y)
            let leftWall = new wall(0, this.y);
            let topWall = new wall(this.x, 0);
            let bottomWall = new wall(this.x, canvas.height);
    
            // detects collisions with the edges of the canvas
            if(getDistance(this, rightWall) < 0){
                changeVelocity(this, rightWall);
            }
    
            if(getDistance(this, topWall) < 0){
                changeVelocity(this, topWall);
            }
    
            if(getDistance(this, leftWall) < 0){
                changeVelocity(this, leftWall);
            }
    
            if(getDistance(this,  bottomWall) < 0){
                changeVelocity(this, bottomWall);
            }
    
            // updates x and y positions
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
        }
    }
    
    // creates the player
    player = new playerMaker(canvas.width/2, canvas.height/2, (canvas.width * (5 /100) < 20)? canvas.width * (5 / 100): 20, 'orange', {x: 0, y: 0}, 1);
    
    // event listener that updates keys object when a key is pressed
    addEventListener('keydown', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = true;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = true;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = true;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = true;
        }
    });
    
    // event listener that updates keys object when a key is released
    addEventListener('keyup', (e)=>{
        if(e.keyCode == 37 || e.keyCode == 65){
            keys.left = false;
        } 
        if(e.keyCode == 39 || e.keyCode == 68){
            keys.right = false;
        } 
        if(e.keyCode == 38 || e.keyCode == 87){
            keys.up = false;
        }
        if(e.keyCode == 40 || e.keyCode == 83){
            keys.down = false;
        }
    });
    
    // code for the bullets
    
        // bullets constructor
        let bullet = class{
            constructor(x, y, r, cl, velocity, mass){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
                this.mass = mass;
                this.opacity = 1;
            }
    
            draw(){
                c.globalAlpha = this.opacity;
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.stroke();
                c.setTransform(1,0,0,1,0,0)
            }
    
            update(){
    
                // updates the x and y position
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                if(dialogCount == 4){
                if(dialogState == 'finished'){
                    dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "To pause the game either click the pause button or press esc, from there you can access the options screen, and turn off some effects for better performance or change the volume settings.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 8;
                }
            }
    
                this.draw();
            }
        }
    
        // bullets generator
    
        // variable that determines wether mouse is down or not
        let mousedown = false;
    
        // an object to save the mouse's position 
        let mouse = {
            x: 0,
            y: 0
        }
    
        // updates the mouse position as it moves around the canvas
        canvas.addEventListener('mousemove', (e)=>{
            mouse.x = e.offsetX;
            mouse.y = e.offsetY;
        });
    
        let stopShootInterval;
    
        // function that starts shooting bullets when called
        function shoot(e){
            // prevents default behaviour
            e.preventDefault();
            window.focus();

            // sets mousedown to true
            if(mousedown == false){
                mousedown = true
                // sets an interval
                let interval = setInterval(()=>{
                    let r = 3;
                    let cl = 'black'
                    let x = player.x;
                    let y = player.y;
                    let vx = mouse.x - x;
                    let vy = mouse.y - y;
    
                    // calculates the angle between the player and the mouse
                    let angle = Math.atan2(vy, vx);
    
                    // if shootJoyStick is used then it calculates the angle 
                    // between the joyStick and the touch dragging it instead
                    if(shootJoyStickActive){
                        angle = shootJoyStick.angle;
                    }
    
                    let velocity = {
                        x: Math.cos(angle) * 5,
                        y: Math.sin(angle) * 5
                    }

                    let mass = 3;

                    // creates bullets if gave hasn't ended
                    if(((health > 0 && pause == false) && hasStarted) && (endingScene == false)){
                        playSoundEffect(bulletSoundEffect, 0.3, 'bullet');
                        bullets.push(new bullet(x, y, r, cl, velocity, mass));
                    }
                }, 300);

                try{
                    stopShootInterval();
                } catch{}
    
                stopShootInterval = function(){
                    clearInterval(interval);
                }
            }
        } 
    
        // runs the shoot function when mouse is pushed down
        canvas.addEventListener('mousedown', shoot);
    
        // event that triggers when mouse button is released
        window.addEventListener('mouseup', (e)=>{
            // prevents default behaviour
            e.preventDefault();
            // sets mousedown to false
            mousedown = false;
            try{
                stopShootInterval();
            } catch{}
        });
    
    // joystick constructor
    let joyStickConstructor = class{
        constructor(x, y, r, id){
            this.x = x;
            this.y = y;
            this.r = r;
            this.id = id;
            this.x2 = x;
            this.y2 = y;
            this.distance = {
                x: 0,
                y: 0
            }
            this.angle = 0;
        }
        // draws the joystick
        draw(){    
            // draws the joystick's container
            c.fillStyle = 'grey';
            c.globalAlpha = 0.3;
            c.lineWidth = 1;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2); 
            c.fill();
            c.globalAlpha = 1;
            c.stroke();
    
            // draws the joystick
            if(this.id == 'shoot'){
                c.fillStyle = 'red';
            }
    
            c.beginPath();
            c.arc(this.x2,this.y2, this.r/2, 0, Math.PI*3);
            c.fill();
            c.stroke();
    
            if(this.id == 'shoot'){
                c.textAlign = "center";
                c.textBaseLine = "middle";
                c.font = 'normal 13px Arial';
                c.fillStyle = "white";
                c.fillText('Shoot', this.x2, this.y2 + 2);
            }
            
            if(this.id == 'move'){
                c.textAlign = "center";
                c.textBaseLine = "middle";
                c.font = 'normal 13px Arial';
                c.fillStyle = "white";
                c.fillText('Move', this.x2, this.y2 + 2);
            }

            c.setTransform(1,0,0,1,0,0)
        }
        update(player){
            // checks if the horizontal distance between touch and 
            // the center of the joystick is greater than this.r / 1.2
            if(this.distance.x > this.r / 1.2){
                // if true then sets distance.x to this.r / 1.2
                this.distance.x = this.r / 1.2;
            }
    
            // checks if the vertical distance between the center of the joystick and the 
            // touch is greater than this.r / 1.2
            if(this.distance.y > this.r / 1.2){
                // if true sets this.distance to this.r / 1.2
                this.distance.y = this.r / 1.2;
            }
    
            if(this.id == "move"){
                // sets the x velocity of the player to be his max speed multipled by the distance 
                // the touch and the center of the joystick devided by this.r / 1.2, the max distance
                // value that can be returned is equal to this.r / 1.2, so if joystick is dragged
                // all the way to the right then the x velocity of the player is set to his max speed
                player.velocity.x = (player.maxSpeed * this.distance.x / (this.r / 1.2)) * Math.cos(this.angle);
                // does the same thing for the y velocity of the player, but with the vertical 
                // distance between the touch and the center of the joystick instead
                player.velocity.y = (player.maxSpeed * this.distance.y / (this.r / 1.2)) * Math.sin(this.angle);
            }
    
            // changes the x2 to the center of the container + 
            // Math.cos(angle) multiplied by the horizontal distance 
            this.x2 = this.x + Math.cos(this.angle) * this.distance.x;
            // changes the y2 to the center of the container + 
            // Math.sin(angle) multiplied by the vertical distance 
            this.y2 = this.y + Math.sin(this.angle) * this.distance.y;
            // draws the joystick
            this.draw();
        }
    }
    
    // creates the move joystick
    let r = 50; 
    let y = canvas.height - r - 20;
    let x = r + 30;
    
    let joyStick = new joyStickConstructor(x,y,r, 'move');
    
    // creates the shoot joystick
    let y2 = canvas.height - r - 20;
    let x2 = canvas.width - r - 30;
    
    let shootJoyStick = new joyStickConstructor(x2,y2,r, 'shoot');
    
    function repositionJoySticks(){
        shootJoyStick.y = canvas.height - r - 20;
        joyStick.y = canvas.height - r - 20;
        shootJoyStick.x = canvas.width - r - 30;;
        joyStick.x = r + 30;
    }
        
    
    // variables that will let us know wether joysticks are in use
    let shootJoyStickActive = false;
    let joyStickActive = false;
    
    // variables that will keep track of the touch which drags each joystick
    let touchIndex;
    let touchIndex2;
    
    // variables that will keep track of the position of the touches 
    let touchPosition = null;
    let touchPosition2 = null;
    
    // function that returns true if touch passed 
    // as it's parameter was made over the move joystick
    function touchedMoveJoystick(touch){
        return touch.clientX > joyStick.x - joyStick.r && 
        touch.clientX < joyStick.x + joyStick.r && 
        touch.clientY > joyStick.y - joyStick.r && 
        touch.clientY < joyStick.y + joyStick.r;
    } 
    
    // function that returns true if touch passed
    // as it's parameter was made over the shoot joystick
    function touchedShootJoystick(touch){
        return touch.clientX > shootJoyStick.x - shootJoyStick.r && 
        touch.clientX < shootJoyStick.x + shootJoyStick.r && 
        touch.clientY > shootJoyStick.y - shootJoyStick.r && 
        touch.clientY < shootJoyStick.y + shootJoyStick.r;
    }
    
    // event that triggers when touch starts
    canvas.addEventListener("touchstart", (e)=>{
        // prevents mouse events from triggering
        if(e.cancelable){
        e.preventDefault();
        }
    
        // gets position of the canvas
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
    
    
        // makes an array of the touches
        let touchArray = Array.from(e.touches);
    
        // loops through each touch object
        touchArray.forEach((touch, i)=>{
            // calculates the offset from the edges 
            // of the canvas and the clientY / clientX
            let touchOnCanvas = {
                clientX: touch.clientX - left,
                clientY: touch.clientY - top
            }
    
            // checks if touch was made over move joystick
            if(touchedMoveJoystick(touchOnCanvas)){
                // if true sets joyStickActive to true 
                // touchIndex to the index of the touch 
                // and touchPosition to touch.clientX
                joyStickActive = true;
                touchIndex = i;
                touchPosition = touchOnCanvas.clientX;
                // adds no-scroll class to the body
                document.body.classList.add('no-scroll');
            } 
            // checks if the touch was made over the shoot joyatick
            else if(touchedShootJoystick(touchOnCanvas)){
                // checks wether player is already shooting 
                if(shootJoyStickActive != true){
                    // if he is not then it runs the shoot function 
                    shoot(e);
                }
                // sets shootJoyStickActive to true,
                // touchIndex2 to touch's index and
                // touchPosition2 to touch.clientX
                shootJoyStickActive = true;
                touchIndex2 = i;
                touchPosition2 = touchOnCanvas.clientX; 
                // adds no-scroll class to the body
                document.body.classList.add('no-scroll');
                // sets mousedown to true
                mousedown = true;
                }
        });
    });
    
    // triggers again and again as touch moves around the screen
    canvas.addEventListener('touchmove', (e)=>{
        // prevents mouse events from triggering
        if(e.cancelable){
        e.preventDefault();
        }
    
        // gets position of the canvas
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
    
        // creates an array of all the touches
        let touchArray = Array.from(e.touches); 
    
        // checks if move joystick is active
        if(joyStickActive){
            // if true loops through all the touches
            touchArray.forEach((touch, i)=>{
                // calculates the offset from the edges 
                // of the canvas and the clientY / clientX
                let touchOnCanvas = {
                    clientX: touch.clientX - left,
                    clientY: touch.clientY - top
                }
    
                // checks wether the distance between the 
                // touch and the touchPosition set previously
                // is smaller than the radiusX formed by the
                // finger plush 10 
                if(Math.abs((touchOnCanvas.clientX - touchPosition)) < touch.radiusX + 10){
                    // if true sets touchIndex to the index of
                    // the touch which passed the test
                    touchIndex = i;
                }
            });
    
            // tries the following code, since there is 
            // a chance an error may occured if touch 
            // cancelled for whatever reason or something
            // else happened
            try{
                // calculates the offset from the edges 
                // of the canvas and the clientY / clientX
                let touchOnCanvas = {
                    clientX: e.touches[touchIndex].clientX - left,
                    clientY: e.touches[touchIndex].clientY - top
                }
                // sets touchPosition to the new clientX 
                touchPosition = touchOnCanvas.clientX;  
                // gets horizontal distance between the 
                // center of the joystick and the touch
                let vx = touchOnCanvas.clientX - joyStick.x;
                // gets vertical distance between the 
                // center of the joystick and the touch
                let vy = touchOnCanvas.clientY - joyStick.y;
                // sets the distance.x and distance.y of 
                // joystick object to the distances 
                // calculated above, but makes sure they 
                // are given as positive values, direction
                // does not matter since we will 
                // rotate the joyStick 
                joyStick.distance.x = Math.abs(vx);
                joyStick.distance.y = Math.abs(vy);
                // calculates the angle formed by the 
                // center of the joystick and the touch
                let angle = Math.atan2(vy, vx);
                // sets joystick.angle to the angle
                // we calculated above
                joyStick.angle = angle;
            } 
            // if the code above throws an error
            // this code deactivates the joystick
            // and resets the variables 
            catch{
                joyStickActive = false;
                joyStick.distance.x = 0;
                joyStick.distance.y = 0;
                joyStick.angle = 0;
                touchPosition = 0;
                touchIndex = -1;
                // checks if both joysticks have been deactivated
                if(joyStickActive != true && shootJoyStickActive != true){
                    // removes no-scroll class from the body
                    document.body.classList.remove('no-scroll');
                }
            }
        } 
    
        // checks if shootJoyStickActive is true
        if(shootJoyStickActive){
            // if true loops through all the touches
            touchArray.forEach((touch, i)=>{
                // calculates the offset from the edges 
                // of the canvas and the clientY / clientX
                let touchOnCanvas = {
                    clientX: touch.clientX - left,
                    clientY: touch.clientY - top
                }
                // checks if the distance between the
                // touch.clientX and the touchPosition2 
                // that we set earlier is smaler than the 
                // radiusX formed by the finger plush 10
                if(Math.abs((touchOnCanvas.clientX - touchPosition2)) < touch.radiusX + 10){
                    // if true sets touchIndex to the index of
                    // the touch which passed the test
                    touchIndex2 = i;
                }
            });
    
            // tries the following code, which may throw
            // errors under certain situations
            try{
                // calculates the offset from the edges 
                // of the canvas and the clientY / clientX
                let touchOnCanvas = {
                    clientX: e.touches[touchIndex2].clientX - left,
                    clientY: e.touches[touchIndex2].clientY - top
                }
                // updates touchPosition2 to new 
                // touch's position 
                touchPosition2 = touchOnCanvas.clientX;
                // calculates horizontal and
                // vertical distances between the 
                // center of the shoot joystick and
                // the touch
                let vx = touchOnCanvas.clientX - shootJoyStick.x;
                let vy = touchOnCanvas.clientY - shootJoyStick.y;
                // sets the distance.x and distance.y 
                // of the shoot joystick to the distances
                // calculated above but makes sure we 
                // set them as positive values because 
                // we don't want a direction, since we 
                // will later use the angle to rotate it
                shootJoyStick.distance.x = Math.abs(vx);
                shootJoyStick.distance.y = Math.abs(vy);
                // calculates the angle of the vector
                let angle = Math.atan2(vy, vx);
                // sets the angle of the shootJoyStick to
                // the angle calculated above
                shootJoyStick.angle = angle;
            } 
    
            // if code above threw an error this 
            // diactivates the shoot joystick and 
            // resets the variables 
            catch{
                shootJoyStickActive = false;
                shootJoyStick.distance.x = 0;
                shootJoyStick.distance.y = 0;
                shootJoyStick.angle = 0;
                touchPosition2 = 0;
                touchIndex2 = -1;
                mousedown = false;
                try{
                    stopShootInterval();
                } catch{}
                // checks if both joysticks have been deactivated
                if(joyStickActive != true && shootJoyStickActive != true){
                    // removes no-scroll class from the body
                    document.body.classList.remove('no-scroll');
                }
            }
        } 
    });

    // this function is used for touchend and touchcancel
    let endContactWithJoyStick = function(e){
        // prevents mouse events from triggering
        if(e.cancelable){
        e.preventDefault();
        }
    
        // gets position of the canvas
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
    
        // calculates the offset from the edges 
        // of the canvas and the clientY / clientX
        let touchOnCanvas = {
            clientX: e.changedTouches[0].clientX - left,
            clientY: e.changedTouches[0].clientY - top
        }
    
        // checks if the distance between the touchPosition and the position of the 
        // touch that ended were less than the radiusX formed by the finger plush 10
        if(Math.abs((touchOnCanvas.clientX - touchPosition)) < e.changedTouches[0].radiusX){ 
            // if true it deactivates the move
            // joyStick and resets the 
            // variables linked to it
            joyStickActive = false;
            joyStick.distance.x = 0;
            joyStick.distance.y = 0;
            joyStick.angle = 0;
            touchPosition = 0;
            touchIndex = -1;
        }
    
        // checks if the distance between the 
        // touchPosition2 and the position of the 
        // touch that ended were less than the
        // radiusX formed by the finger plush 10
        if(Math.abs((touchOnCanvas.clientX - touchPosition2)) < e.changedTouches[0].radiusX){
            // if true it deactivates the shoot
            // joyStick and resets the variables
            // linked to it
            shootJoyStickActive = false;
            shootJoyStick.distance.x = 0;
            shootJoyStick.distance.y = 0;
            shootJoyStick.angle = 0;
            touchPosition2 = 0;
            touchIndex2 = -1;
            mousedown = false;
            try{
            stopShootInterval();
            } catch{}
        } 
        
        // checks if both joysticks have been deactivated
        if(joyStickActive != true && shootJoyStickActive != true){
            // removes no-scroll class from the body
            document.body.classList.remove('no-scroll');
        }
    }
    
    // triggers when a touch ends
    canvas.addEventListener('touchend', endContactWithJoyStick);

    // triggers if a touch is for some reason cancelled
    canvas.addEventListener('touchcancel', endContactWithJoyStick);
    
    // blood constructor
    
    let blood = class{
        constructor(x, y, r, cl, velocity){
            this.y = y;
            this.x = x;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.friction = 0.93;
            this.life_time = 1;
        }
    
        draw(){
            c.fillStyle = this.cl;
            c.beginPath();
            c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            c.fill();
            c.setTransform(1,0,0,1,0,0)
        }
    
        update(){
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
    
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
    
            this.life_time -= 0.15;
        }
    }
    
    // explosion constructor
    
    let explosion = class{
        constructor(x, y, r, cl, velocity, id){
            this.x = x;
            this.y = y;
            this.r = r;
            this.cl = cl;
            this.velocity = velocity;
            this.friction = 0.99;
            this.gravity = 0.01;
            this.alpha = 1;
            this.id = id;
            this.text;
            this.iteration = 1;
            this.increment;
            this.textColor;
        }
    
        draw(){
            c.globalAlpha = this.alpha;
            c.fillStyle = this.cl;
            if(this.id == 'exps'){
                this.increment += 0.01;
                let array = ['Congratulations!', 'Level up!', 'Good Job!', 'YOU ARE SO COOL!'];
                if(this.iteration == 1){
                    this.text = array[Math.floor(Math.random() * array.length)];
                    this.textColor = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 1)`;
                }
                c.fillStyle = this.textColor;
                c.font = 'normal 15px Arial';
                c.textAlign = 'center';
                c.fillText(this.text, this.x, this.y);
            }else{
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.fill();
                c.stroke();
            }
            c.globalAlpha = 1;
            c.setTransform(1,0,0,1,0,0)
        }
    
        update(){
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
    
            if(this.id != "exps"){
                this.velocity.y += this.gravity;
            } else{
                this.velocity.y += 0.001;
            }
    
            this.x += this.velocity.x;
            this.y += this.velocity.y;
    
            this.draw();
    
            this.alpha -= 0.01;
            this.iteration++
        }
    }
     
    // code for dialogs
    
        // text wrapper
        function wrapText(text, x, y, maxWidth, lineHeight, stls){
            let words = text.split(' ');
            let line = '';
            let lines = new Array();
            c.font = stls.font;
            if(stls.stroke.inUse){
                c.lineWidth = stls.stroke.width;
            }
            words.forEach((word)=>{
                let testLine = line + word;
                let testWidth = c.measureText(testLine).width;
                if(testWidth > maxWidth){
                    lines.push({line: line, y: y});
                    y += lineHeight;
                    line = word + ' ';
                } else{
                    line += word + ' ';
                }
            });
            c.setTransform(1,0,0,1,0,0);
            lines.push({line: line, y: y});
            return lines;
        }
    
        let dialog = new Array();
        let dialogStyles;
    
        // dialog generator
    
        //addDialog({text: text, color: color, font: font},
        //{inUse: stroke.inUse, color: stroke.color, width: stroke.width },
        //x, y, maxWidth, lineHeight, speed);
    
        let stopDialogInterval;
        let pauseDialogInterval;
        let startDialogInterval;
        let interval;

        function addDialog(text, stroke, x, y, maxWidth, lineHeight, speed){
            c.fillStyle = text.color;
            c.font = text.font;
            c.textAlign = 'left';
            if(stroke.inUse){
                c.strokeStyle = stroke.color;
                c.lineWidth = stroke.width;
            }
            c.setTransform(1,0,0,1,0,0);
            dialogStyles = {
                fillStyle: text.color,
                font: text.font,
                stroke: {
                    inUse: stroke.inUse,
                    width: stroke.width,
                    color: stroke.color
                }                    
            }
            let txt = text.text;
            let lines = wrapText(txt, x, y, maxWidth, lineHeight, 
            {font: text.font, stroke: {inUse: stroke.inUse, width: stroke.width}});
            let letters = new Array();
            let letterIndex = 0;
            let lineIndex = 0;
            lines.forEach((line)=>{
                let characters = new Array();
                for(let i = 0; i < line.line.length; i++){
                    characters.push({letter: line.line[i], x: x, y: line.y});
                }
                letters.push(characters);
            });

            let addLetters = function(){
                try{
                    if(speechSoundEffect.volume == 0){
                        speechSoundEffect.currentTime = 2;
                        speechSoundEffect.volume = speechSoundEffect.maxVolume * (soundEffectsVolume / 100);
                    }
                    if(speechSoundEffect.currentTime > speechSoundEffect.duration - 1){
                        speechSoundEffect.currentTime = 2;
                    }
                    dialog[lineIndex] = {text: dialog[lineIndex].text + letters[lineIndex][letterIndex].letter, x: x, y: letters[lineIndex][letterIndex].y};
                } catch{
                    dialog[lineIndex] = {text: letters[lineIndex][letterIndex].letter, x: x, y: letters[lineIndex][letterIndex].y};
                }
                letterIndex++
                if(letterIndex > letters[lineIndex].length - 1){
                    lineIndex += 1;
                    letterIndex = 0;
                }
                if(lineIndex >= letters.length){
                    clearInterval(interval);
                    dialogState = 'finished';
                    speechSoundEffect.volume = 0;
                    speechSoundEffect.currentTime = 0;
                }
            }

            interval = setInterval(addLetters, speed);
            stopDialogInterval = function(){
                clearInterval(interval);
                dialogState = 'stopped';
                speechSoundEffect.volume = 0;
                speechSoundEffect.currentTime = 0;
                dialog = [];
            }
            pauseDialogInterval = function(){
                clearInterval(interval);
                speechSoundEffect.volume = 0;
                speechSoundEffect.currentTime = 0;
            }
            startDialogInterval = function(){
                speechSoundEffect.currentTime = 0;
                interval = setInterval(addLetters, 60);
            }
        }
    
        function drawDialog(angleIncrement){
            dialog.forEach((line)=>{
                c.fillStyle = dialogStyles.fillStyle;
                c.font = dialogStyles.font;
                c.textAlign = 'left';
                if(dialogStyles.stroke.inUse){
                    c.strokeStyle = dialogStyles.stroke.color;
                    c.lineWidth = dialogStyles.stroke.width;
                }

                let x = Math.cos(angleIncrement * 0.25) * 3;
                let y = Math.sin(angleIncrement * 0.25) * 0;

                c.fillText(line.text, line.x + x, line.y + y);
                if(dialogStyles.stroke.inUse){
                    c.strokeText(line.text, line.x + x, line.y + y);
                }
                c.setTransform(1,0,0,1,0,0);
            });
        }
    
        // enemies constructor
        let enemyConstructor = class{
            constructor(x, y, r, cl, velocity, speed, mass, cooldown, damage_dur, damage, health, img){
                this.x = x;
                this.y = y;
                this.r = r;
                this.cl = cl;
                this.velocity = velocity;
                this.speed = speed;
                this.mass = mass;
                this.original_mass = mass;
                this.player_collapsed = -1;
                this.enemy_collapsed = -1;
                this.has_entered_canvas = false;
                this.stroke = 2;
                this.maxHealth = health;
                this.health = health;
                this.damage_duration = damage_dur;
                this.dmg_duration = 0;
                this.dmg = damage;
                this.cooldown = cooldown;
                this.was_hit = -1;
                this.image = img;
            }
    
            draw(){
                c.strokeStyle = 'black';
                c.globalAlpha = 1;
                c.fillStyle = this.cl;
                c.lineWidth = this.stroke;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                c.fill();
                c.stroke();
                if(this.image.id == 'image3'){
                    let aspectRatio = this.image.image.naturalWidth / this.image.image.naturalHeight;
                    c.drawImage(this.image.image, this.x - this.r + 4, this.y - this.r + 5, this.r * 1.5, (this.r * 1.5) / aspectRatio);
                }
                if(this.image.id == 'image4'){
                    let aspectRatio = this.image.image.naturalWidth / this.image.image.naturalHeight;
                    c.drawImage(this.image.image, this.x - this.r + 6, this.y - this.r + 9, this.r * 1.5, (this.r * 1.5) / aspectRatio);
                }
                if(this.image.id == 'image5'){
                    let aspectRatio = this.image.image.naturalWidth / this.image.image.naturalHeight;
                    c.drawImage(this.image.image, this.x - this.r + 5, this.y - this.r + 4, this.r * 1.5, (this.r * 1.5) / aspectRatio);
                }
                c.lineWidth = 1;
                c.setTransform(1,0,0,1,0,0)
            }
    
            drawHealthBar(){
                c.globalAlpha = 1;
                c.fillStyle = 'red';
                // draws red layer of health
                c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5);
                c.fillStyle = 'green';
                // draws green layer of health, the width is multiplied by (this.health / this.maxHealth) 
                // so that it decreases as this.health gets smaller and smaller till it reaches zero
                c.fillRect(this.x - this.r, this.y - this.r - 7, (this.r * 2) * (this.health / this.maxHealth), 3.5);
                c.lineWidth = 2;
                c.strokeStyle = 'black';
                // draws a border around the healthbar
                c.strokeRect(this.x - this.r, this.y - this.r - 7, (this.r * 2), 3.5); 
                c.lineWidth = 1; 
                c.setTransform(1,0,0,1,0,0)
            }
    
            update(otherEnemies, bullets){
                // gets angle between enemy and player
                let vx = player.x - this.x;
                let vy = player.y - this.y;
                let angle = Math.atan2(vy, vx);
                
                // if no collisions have happened the enemy moves towards the player
                if(this.player_collapsed < 0 && this.enemy_collapsed < 0){
                    // sets stroke to black
                    this.stroke = 2;
                    // sets velocities to follow the player
                    this.velocity.x = Math.cos(angle) * this.speed;
                    this.velocity.y = Math.sin(angle) * this.speed;
                } 
                // if the enemy collapsed with the player the velocities are being decreased
                else if(this.player_collapsed > 0){
                    this.velocity.x *= 0.5;
                    this.velocity.y *= 0.5;
                } 
    
                // deacreases enemy_collapsed and player_collapsed properties
                this.enemy_collapsed -= 1;
                this.player_collapsed -= 1;
                // decreases cooldown
                this.was_hit -= 0.7;
                // sets mass to original mass
                this.mass = this.original_mass;
    
                // loops through all the enemies
                otherEnemies.forEach((enemy)=>{
                    // prevents this from running the code on it self
                    if(enemy != this){
                        // checks if collision
                        if(getDistance(this, enemy) < 0){
                            // calculates and sets final velocities
                            changeVelocity(this, enemy);
                            // checks if enemy_collapsed is less than 0.2, that's because
                            // when enemy collapses with a bullet I set enemy_collapsed to 
                            // 4, so I don't want it to be set back to 0.5, and I didn't want 
                            // to create a different variable for bullet collisions since it isn't needed
                            if(this.enemy_collapsed < 0.2){
                                // sets enemy_collapsed to 0.5
                                this.enemy_collapsed = 0.5;
                            }
                        }
                    }
                });
    
                // checks if distance with the player is less than 0
                if(getDistance(this, player) < 0){
                    // calculates and sets the final velocities after the collision
                    changeVelocity(this, player);
                    // sets player_collapsed property to 1
                    this.player_collapsed = 1;
                    // checks if was_hit is less than 0
                    if(this.was_hit < 0){
                        playDamageSound(damageSoundEffect, 0.4);

                        // sets was_hit property to cooldown value
                        this.was_hit = this.cooldown;
                        // increases dmg_duration by damage_duration
                        // the reason I made two properties for damage duration
                        // is because I wanted one to be kept static at all times
                        this.dmg_duration += this.damage_duration;
                        // sets an interval
                        let interval = setInterval(()=>{
                            // decreases health by this.dmg in every iteration
                            health -= this.dmg;
                            // prevents health from becoming less than zero
                            if(health < 0){
                                health = 0;
                            }
                            // checks if dmg_duration is less or equal to zero
                            if(this.dmg_duration <= 0){
                                // stops the interval
                                clearInterval(interval);
                            }
                            // decreases the dmg_duration by 1 after each iteration
                            this.dmg_duration -= 1;
                        }, 200);
                    }
                }
    
                // loops through the bullets array
                bullets.forEach((bullet, i)=>{
                    // checks if the distance between the enemy and the bullet is less than 0
                    if(getDistance(this, bullet) < 0){
                        playSoundEffect(hitMarkerEffect, 0.85, 'hitmarker');

                        // calculates and sets the final velocities
                        changeVelocity(this, bullet);
                        // makes bullet invisible
                        bullet.opacity = 0;
                        // sets enemy_collapsed to 4
                        this.enemy_collapsed = 4;
                        // sets stroke property to pink
                        this.stroke = 1;
                        // decreases health by 20
                        this.health -= 20;

                        // prevents health from being less than 0
                        if(this.health < 0){
                            this.health = 0;
                        }
    
                        exps += 10;
    
                        if(exps >= maxExps){
                            exps = 0;
                            level++
                            maxExps += 20;
    
                            // checks if level_up_effect is true
                            if(level_up_effect){
                                // sets number of explosion particles to be created
                                let particlesCount = 10;
                                // devides a full circle by the number of explosion particles
                                let angleIncrement = Math.PI * 2 / particlesCount;
                                let xIncrement = ((canvas.width / 2) - 20) / particlesCount;
    
                                // a loop that creates the explosion particles
                                for(let i = 0; i < particlesCount; i++){
                                    let velocity = {
                                        x: Math.cos(angleIncrement * i) * Math.random() * 3,
                                        y: Math.sin(angleIncrement * i) * Math.random() * 3
                                    }
                                    let x = player.x;
                                    let y = player.y;
                                    let r = 5;
                                    let color = "pink";
                                    playSoundEffect(levelUpSoundEffect, 0, 'levelup');
                                    expsExplosion.push(new explosion(x, y, r, color, velocity, 'exps'));
                                }
                            }
                        }
    
                        // checks if blood effect is true
                        if(blood_effect){
                            // sets number of blood particles to be created  
                            let bloodCount = 20;
                            // devides a full circle by the number of blood particles
                            let angleIncrement = Math.PI * 2 / bloodCount;
    
                            // loop that creates the blood particles
                            for(let i = 0; i < bloodCount; i++){
                                let velocity = {
                                    x: Math.cos(angleIncrement * i) * Math.random() * 2,
                                    y: Math.sin(angleIncrement * i) * Math.random() * 2
                                }
                                let x = this.x;
                                let y = this.y;
                                let r = this.r / 3;
                                let color = this.cl;
                                bloodParticles.push(new blood(x, y, r, color, velocity));
                            }
                        }
                    }
                });
    
                // checks for overlapping between the enemies
                otherEnemies.forEach((enemy)=>{
                    if(enemy != this){
                        if(getDistance(this, enemy) < -3){
                            changeVelocity(this, enemy);
                            this.enemy_collapsed = 2;
                            this.mass = 2;
                        }
                    }
                });
    
                // checks for overlapping between player and enemy
                if(getDistance(this, player) < -3){
                    changeVelocity(this, player);
                        this.enemy_collapsed = 2;
                        this.mass = 4;
                }
    
                // creates hit boxes at the edges of the canvas
                let rightWall = new wall(canvas.width, this.y)
                let leftWall = new wall(0, this.y);
                let topWall = new wall(this.x, 0);
                let bottomWall = new wall(this.x, canvas.height);
    
                // checks if has_enter_canvas is false
                if(this.has_entered_canvas == false){
                    // checks if particle has entered the canvas
                    if((this.x  - this.r > 0 && this.x + this.r < canvas.width) && 
                    (this.y - this.r > 0 && this.y + this.r < canvas.height)){
                        // sets has_entered_canvas to true
                        this.has_entered_canvas = true;
                    }
                } 
    
                // if has_enter_canvas is true then it checks for wall collisions
                else{
                    if(getDistance(this, rightWall) < 0){
                        changeVelocity(this, rightWall);
                    }
    
                    if(getDistance(this, topWall) < 0){
                        changeVelocity(this, topWall);
                    }
    
                    if(getDistance(this, leftWall) < 0){
                        changeVelocity(this, leftWall);
                    }
    
                    if(getDistance(this,  bottomWall) < 0){
                        changeVelocity(this, bottomWall);
                    }
                }
    
                // updates x and y positions
                this.x += this.velocity.x;
                this.y += this.velocity.y;
    
                this.draw();
            }
        }

        // enemies generator
    
        // this will be set to be a function 
        // that stops the interval which spawns the enemies,
        // I needed to precreate it here so that it is in the
        // global scope, so that it can be used outside the function
        let stopSpawnInterval;
    
        function spawnEnemies(){
            // creates different type of enemies
            // radius, color, speed, mass, cooldown, damage_duration, damage, health
            let normalEnemy = [(canvas.width * (5 /100) < 20)? canvas.width * (5 / 100): 20, function(){return `hsl(${Math.random() * 360}, 50%, 50%`}, function(){return 1}, 1.1, 6, 0.5, 1, 100, {id: 'image3', image: image3}];
            let tankEnemy = [(canvas.width * (7 /100) < 30)? canvas.width * (7 / 100): 30, function(){return `hsl(${Math.random() * 360}, 50%, 50%`}, function(){return 0.2}, 2, 6, 1, 2, 400, {id: 'image4', image: image4}];
            let kidEnemy = [(canvas.width * (4 /100) < 17)? canvas.width * (4 / 100): 17, function(){return `hsl(${Math.random() * 360}, 50%, 50%`}, function(){return 2}, 1, 6, 0.5, 1, 50, {id: 'image5', image: image5}];
            let enemyTypes = [];
    
            // max enemies that can spawn
            let maxEnemies = wave * 5;
    
            // keeps track of enemies that have been spawned
            let enemiesSpawned = 0;

            let speed = 4000;

            if(wave == 0){
                enemyTypes = [normalEnemy];
            }
            if(wave == 1){
                for(let i = 0; i < 5; i++){
                    enemyTypes.push(normalEnemy);
                }
                enemyTypes.push(normalEnemy);
            }
            if(wave == 2){
                for(let i = 0; i < 10; i++){
                    enemyTypes.push(normalEnemy);
                }
                enemyTypes.push(normalEnemy);
            }
            if(wave == 3){
                for(let i = 0; i < 10; i++){
                    enemyTypes.push(kidEnemy);
                }
                maxEnemies = 10;
                enemyTypes.push(normalEnemy);
            }
            if(wave == 4){
                for(let i = 0; i < 2; i ++){
                    enemyTypes.push(kidEnemy, kidEnemy, kidEnemy, kidEnemy, kidEnemy);
                    enemyTypes.push(normalEnemy, normalEnemy, normalEnemy, normalEnemy, normalEnemy);
                }
                maxEnemies = 15;
                enemyTypes.push(normalEnemy);
            }
            if(wave == 5){
                for(let i = 0; i < 5; i++){
                    enemyTypes.push(kidEnemy, normalEnemy, kidEnemy, kidEnemy, normalEnemy);
                }
                maxEnemies = 20;
                enemyTypes.push(normalEnemy);
            }
            if(wave == 6){
                for(let i = 0; i < 4; i++){
                    enemyTypes.push(kidEnemy, normalEnemy, kidEnemy, kidEnemy, normalEnemy);
                }
                enemyTypes.push(normalEnemy);
                maxEnemies = 20;
            }
            if(wave == 7){
                for(let i = 0; i < 5; i++){
                    enemyTypes.push(tankEnemy);
                }
                enemyTypes.push(normalEnemy);
                maxEnemies = 5;
            }
            if(wave == 8){
                for(let i = 0; i < 4; i++){
                    enemyTypes.push(normalEnemy, normalEnemy, kidEnemy, tankEnemy, normalEnemy);
                }
                enemyTypes.push(normalEnemy);
                maxEnemies = 20;
            }
            if(wave == 9){
                for(let i = 0; i < 3; i++){
                    enemyTypes.push(normalEnemy, kidEnemy, kidEnemy, kidEnemy, tankEnemy);
                }
                enemyTypes.push(normalEnemy);
                maxEnemies = 15;
            }
            if(wave == 10){
                for(let i = 0; i < 4; i++){
                    enemyTypes.push(normalEnemy, kidEnemy, kidEnemy, tankEnemy, tankEnemy);
                }
                speed = 2000;
                enemyTypes.push(normalEnemy);
                maxEnemies = 20;
            }

            // sets an interval that spawns enemies
            let interval = setInterval(()=>{
                let enemy = enemyTypes[enemiesSpawned];
                let r = enemy[0];
                let x, y;

                // spawns the enemy randomly outside the canvas
                if(Math.random() < 0.5){
                    x = (Math.random() < 0.5)? 0 - r: canvas.width + r;
                    y = Math.random() * canvas.height;
                } else{
                    x = Math.random() * canvas.width;
                    y = (Math.random() < 0.5)? 0 - r: canvas.height + r;
                }
    
                let color = enemy[1]();
                let velocities = {x: 0, y: 0}
                let speed = enemy[2]();
                let mass = enemy[3];
                let cooldown = enemy[4];
                let dmg_duration = enemy[5];
                let dmg = enemy[6];
                let enemy_health = enemy[7];
                let enemy_image = enemy[8];
    
                // checks if max enemies have been spawned 
                if(enemiesSpawned < maxEnemies){
                    // checks if game has started and is active
                    if((health > 0 && pause == false) && hasStarted){
                        enemies.push(new enemyConstructor(x, y, r, color, velocities, speed, mass, cooldown, dmg_duration, dmg, enemy_health, enemy_image));
                        enemiesSpawned++;
                    }
                } else{
                    clearInterval(interval);
                }
            }, speed);
    
            stopSpawnInterval = function(){
                clearInterval(interval);
            }
        }
    
    // an object I will use to keep track of touch position
    let touch = {
        x: 0,
        y: 0
    }
    
    // triggers every time the canvas is touched
    canvas.addEventListener('touchstart', (e)=>{
        // prevents mouse events from triggering
        e.preventDefault();
        // gets position of the canvas
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
    
        // calculates the offset between the canvas and the touch and
        // sets it for touch.x and touch.y
        touch.x = e.touches[0].clientX - left;
        touch.y = e.touches[0].clientY - top;
    });
    
    // triggers every time a touch is moved over the canvas
    canvas.addEventListener('touchmove', (e)=>{
        // gets the position of the canvas
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
    
        // calculates the offset between the canvas and the touch and
        // sets it for touch.x and touch.y
        touch.x = e.touches[0].clientX - left;
        touch.y = e.touches[0].clientY - top;
    });
    
    // button constructor
    let button = class{
        constructor(x, y, width, height, color, stroke, text, id, animation){
            this.x = x;
            this.y = y;
            this.center = {
                x: this.x,
                y: this.y
            }
            this.extraWidth = width;
            this.extraHeight = height;
            this.color = color;
            this.stroke = stroke;
            this.text = text;
            this.id = id;
            this.rectX;
            this.rectY;
            this.rectWidth;
            this.rectHeight;
            this.mouseOver = false;
            this.originalFont = text.font;
            this.originalText = this.text.text;
            this.animation = animation;
            this.textIncrement = 0;
            this.textSize = parseFloat(this.text.font.match(/\d+/));
        }
        draw(){
            c.font = this.text.font;
            c.textAlign = 'center';
    
            c.fillStyle = this.color;
            c.fillRect(this.rectX, this.rectY, this.rectWidth, this.rectHeight);
            if(this.stroke.inUse){
                c.strokeStyle = this.stroke.color;
                c.lineWidth = this.stroke.width;
                c.strokeRect(this.rectX, this.rectY, this.rectWidth, this.rectHeight);
            }

            c.fillStyle = this.text.color;
            c.fillText(this.text.text, this.x, this.y);
    
            if(this.text.strokeInUse){
                c.strokeStyle = this.text.strokeColor;
                c.lineWidth = this.text.strokeWidth;
                c.strokeText(this.text.text, this.x, this.y);
            }
            c.setTransform(1,0,0,1,0,0)
        }
        update(){
            c.font = this.text.font;
            c.textAlign = 'center';
    
            if(this.id == 'bloodEffect'){
                this.text.text = this.originalText + ` ${blood_effect}`;
            }
            if(this.id == 'explosionEffect'){
                this.text.text = this.originalText + ` ${explosion_effect}`;
            }
            if(this.id == 'levelUpEffect'){
                this.text.text = this.originalText + ` ${level_up_effect}`;
            }
    
            let measuredText = c.measureText(this.text.text);
            c.textAlign = 'left';
            c.font = '';

            this.rectX = this.x - measuredText.actualBoundingBoxLeft - this.extraWidth;
            this.rectY = this.y - measuredText.actualBoundingBoxAscent - this.extraHeight;
            this.rectWidth = measuredText.width + this.extraWidth * 2;
            this.rectHeight = measuredText.actualBoundingBoxAscent + measuredText.actualBoundingBoxDescent + this.extraHeight * 2;
    
            if(this.animation){
                this.x = this.center.x + Math.cos(buttonsIncrement) * 10;
                this.y = this.center.y + Math.sin(buttonsIncrement) * 5;
            }
    
            // makes sure the following code does not run for pausedGame button
            if(this.id != 'pausedGame' && this.id != 'title'){
                // checks if mouse or touch is over the button
                if((mouse.x > this.rectX && mouse.x < this.rectX + this.rectWidth) && (mouse.y > this.rectY && mouse.y < this.rectY + this.rectHeight) ||
                (touch.x > this.rectX && touch.x < this.rectX + this.rectWidth) && (touch.y > this.rectY && touch.y < this.rectY + this.rectHeight)){
                    // if true sets mouseOver to true and changes stroke and text color
                    this.textIncrement += 1;
                    if(this.textIncrement > 5){
                        this.textIncrement = 5;
                    }
                    this.mouseOver = true;
                    let size = parseFloat(this.originalFont.match(/\d+/));
                    this.text.font = this.text.font.replace(/\d+/, size + this.textIncrement);
                } else{
                    // else resets mouseOver to false and stroke and text colors back to their original
                    this.mouseOver = false;
                    let size = parseFloat(this.originalFont.match(/\d+/));
                    this.textIncrement -= 1;
                    if(this.textIncrement < 0){
                        this.textIncrement = 0;
                    }
                    this.text.font = this.text.font.replace(/\d+/, size + this.textIncrement)
                }
            }
    
            this.draw();
        }
    }
    
    let OptionsButton, leaveButton, resumeButton, pausedGameTitle, enterGame, levelEffect, explosionEffect, bloodEffect, backButton, title, credits, optionsBut2, startButton;

    function createButtons(){
        // pauseScreen buttons
        pausedGameTitle = new button(canvas.width/2, canvas.height/2 - 120, (canvas.width - canvas.width * (93 / 100) < 30)? canvas.width - canvas.width * (93 / 100): 30,
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgba(255, 255, 255, 0)', {
            inUse: false
        }, {
            text: 'The game has been paused',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 40)? canvas.width - canvas.width * (94 / 100): 40}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 2
        }, 'pausedGame', true);

        leaveButton = new button(canvas.width/2, canvas.height/2 + 80, (canvas.width - canvas.width * (93 / 100) < 30)? canvas.width - canvas.width * (93 / 100): 30, 
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'pink', {
            inUse: true,
            color: 'black',
            width: 3
        }, {
            text: 'RESTART GAME',
            color: 'lightgreen',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'black',
            strokeWidth: 1
        }, 'restart', true);

        c.font = `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`;
        c.lineWidth = 1;
        let leaveButtonMeasurement = c.measureText('RESTART GAME').width;
        let resumeButtonMeasurement = c.measureText('Resume').width;
        let optionsButtonMeasurement = c.measureText('Options').width;

        resumeButton = new button(canvas.width/2, canvas.height/2, 
        leaveButton.extraWidth + Math.abs((resumeButtonMeasurement - leaveButtonMeasurement) / 2), 
        leaveButton.extraHeight, 'lightgreen', {
            inUse: true,
            color: 'black',
            width: 3
        }, {
            text: 'Resume',
            color: 'lightblue',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'black',
            strokeWidth: 1
        }, 'resume', true);
        
        OptionsButton = new button(canvas.width/2, canvas.height/2 + 160, 
        leaveButton.extraWidth + Math.abs((optionsButtonMeasurement - leaveButtonMeasurement) / 2), 
        leaveButton.extraHeight, 'lightblue', {
            inUse: true,
            color: 'black',
            width: 3
        }, {
            text: 'Options',
            color: 'pink',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'black',
            strokeWidth: 1
        }, 'options', true);

        // buttons for the home screen
        startButton = new button(canvas.width/2, canvas.height / 1.7, 
        (canvas.width - canvas.width * (93 / 100) < 30)? canvas.width - canvas.width * (93 / 100): 30, (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'NEW GAME',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'startGame', true);

        c.font = startButton.text.font;
        c.lineWidth = 1;
        let startButtonMeasuredText = c.measureText(startButton.text.text);
        let optionsButton2MeasuredText = c.measureText('options');
        let creditsMeasuredText = c.measureText('credits');

        optionsButton2 = new button(canvas.width/2, startButton.y + startButton.extraHeight * 2 + startButton.textSize + 10, 
        startButton.extraWidth + ((startButtonMeasuredText.width - optionsButton2MeasuredText.width) / 2), (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'OPTIONS',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'options', true);

        credits = new button(canvas.width/2, optionsButton2.y + optionsButton2.extraHeight * 2 + optionsButton2.textSize + 10, 
        startButton.extraWidth + ((startButtonMeasuredText.width - creditsMeasuredText.width) / 2), (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'CREDITS',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'credits', true);

        title = new button(canvas.width/2, canvas.height * (25 / 100), 0, 0, 'rgba(0, 0, 0, 0)', {
            inUse: false
        }, {
            text: 'DON\'T DO DRUGS',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (89 / 100) < 60)? canvas.width - canvas.width * (89 / 100): 60}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 3
        }, 'title', true);
        
        // options screen buttons 

        backButton = new button(canvas.width/2, canvas.height * (20 / 100), (canvas.width - canvas.width * (89 / 100) < 20)? canvas.width - canvas.width * (89 / 100): 20, 
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'BACK',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'back', true);

        explosionEffect = new button(canvas.width/2, backButton.y + backButton.extraHeight * 2 + backButton.textSize + 20, (canvas.width - canvas.width * (89 / 100) < 20)? canvas.width - canvas.width * (89 / 100): 20,
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'EXPLOSION-EFFECT =',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'explosionEffect', true);

        levelEffect = new button(canvas.width/2, explosionEffect.y + explosionEffect.extraHeight * 2 + explosionEffect.textSize + 20, (canvas.width - canvas.width * (93 / 100) < 20)? canvas.width - canvas.width * (89 / 100): 20, 
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'LEVEL-UP-EFFECT =',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'levelUpEffect', true);
        
        // other buttons

        enterGame = new button(canvas.width/2, canvas.height/2, canvas.width - canvas.width * (98 / 100), 20, 'rgb(197, 60, 261)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'Click here to enter the game',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (96 / 100) < 25)? canvas.width - canvas.width * (96 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'enterGame', true);

        pauseButton = new button(canvas.width * (73 / 100), canvas.height * (19 / 100), canvas.width - canvas.width * (98 / 100), 5, 'rgba(197, 60, 261, 0.2)', {
            inUse: true,
            color: 'rgb(30, 33, 63)',
            width: 3
        }, {
            text: 'Pause the game',
            color: 'yellow',
            font: `normal ${(canvas.width - canvas.width * (96 / 100) < 25)? canvas.width - canvas.width * (96 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'rgb(30, 33, 63)',
            strokeWidth: 1
        }, 'enterGame', false);

        gameOverTitle = new button(canvas.width/2, canvas.height * (40 / 100), 0, 0, 'rgba(0, 0, 0, 0)', {
            inUse: false
        }, {
            text: 'GAME OVER!',
            color: 'red',
            font: `normal ${(canvas.width - canvas.width * (89 / 100) < 60)? canvas.width - canvas.width * (89 / 100): 60}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'black',
            strokeWidth: 3
        }, 'title', true);

        endingLeaveButton = new button(canvas.width/2, canvas.height / 2 + player.r + 40 + (((canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20) * 2), (canvas.width - canvas.width * (93 / 100) < 30)? canvas.width - canvas.width * (93 / 100): 30, 
        (canvas.height - canvas.height * (93 / 100) < 20)? canvas.height - canvas.height * (93 / 100): 20, 'gray', {
            inUse: true,
            color: 'black',
            width: 3
        }, {
            text: 'RESTART GAME',
            color: 'red',
            font: `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`,
            strokeInUse: true, 
            strokeColor: 'black',
            strokeWidth: 1
        }, 'restart', true);
    }

    createButtons();

    // volume bars constructor

    let volumeBar = class{
        constructor(text, x, y, width, height, color, percentage, id){
            this.text = text;
            this.x = x;
            this.y = y;
            this.originalPosition = {x: this.x, y: this.y};
            this.width = width;
            this.height = height;
            this.color = color;
            this.percentage = percentage;
            this.mouseOver = false;
            this.mouseDown = false;
            this.id = id;
        }
        draw(){
            c.save();
            c.strokeStyle = this.color.strokeStyle;
            c.lineWidth = 3;
            c.fillStyle = 'black';
            c.fillRect(this.x, this.y, this.width, this.height);
            c.fillStyle = this.color.fillStyle; 
            c.fillRect(this.x, this.y, this.width * (this.percentage / 100), this.height);
            c.strokeRect(this.x, this.y, this.width, this.height);
            c.lineWidth = 1;
            c.font = `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`;
            c.textAlign = 'left';
            c.textBaseline = "middle";
            c.fillStyle = this.text.color;
            c.strokeStyle = this.text.strokeColor;
            c.fillText(this.text.text, this.x + 5, this.y + (this.height / 2));
            c.strokeText(this.text.text, this.x + 5, this.y + (this.height / 2));
            let textWidth = c.measureText(this.percentage + '%').width;
            c.fillText(this.percentage + '%', this.x + this.width - textWidth - 5, this.y + (this.height / 2));
            c.strokeText(this.percentage + '%', this.x + this.width - textWidth - 5, this.y + (this.height / 2));
            c.restore();
        }
        update(){
            this.x = this.originalPosition.x + Math.cos(buttonsIncrement) * 10;
            this.y = this.originalPosition.y + Math.sin(buttonsIncrement) * 5;

            if((mouse.x > this.x && mouse.x < this.x + this.width) && (mouse.y > this.y && mouse.y < this.y + this.height)){
                this.mouseOver = true;
            } else {
                this.mouseOver = false;
            }

            if(this.mouseDown){
                let distance = mouse.x - this.x;
                if(distance > this.width){
                    distance = this.width;
                }
                if(distance < 0){
                    distance = 0;
                }
                if(this.id == 'music'){
                    musicVolume = Math.floor(100 * (distance / this.width));
                    this.percentage = musicVolume;
                    updateMusicVolume();
                }
                if(this.id == 'soundEffects'){
                    soundEffectsVolume = Math.floor(100 * (distance / this.width));
                    this.percentage = soundEffectsVolume;
                }
            }

            this.increment += 0.01;
            this.draw();
        }
    }

    let musicVlmBar, soundsVlmBar;

    function createVolumeBars(){
        c.save();
        c.font = `normal ${(canvas.width - canvas.width * (94 / 100) < 25)? canvas.width - canvas.width * (94 / 100): 25}px Luckiest Guy`;
        let levelEffectMeasuredText = c.measureText(levelEffect.text.text + ' = tru');
        c.restore();

        musicVlmBar = new volumeBar({text: 'Music Volume', color: 'yellow', strokeColor: 'rgb(30, 33, 63)'}, 
        levelEffect.x - (levelEffectMeasuredText.width / 2) - levelEffect.extraWidth, levelEffect.y + levelEffect.extraHeight + levelEffect.textSize, levelEffectMeasuredText.width + levelEffect.extraWidth * 2 + 1, levelEffectMeasuredText.actualBoundingBoxAscent + 20,
        {fillStyle: 'rgb(197, 60, 261)', strokeStyle: 'rgb(30, 33, 63)'}, 
        musicVolume, 'music');

        soundsVlmBar = new volumeBar({text: 'Sounds Volume', color: 'yellow', strokeColor: 'rgb(30, 33, 63)'}, 
        levelEffect.x - (levelEffectMeasuredText.width / 2) - levelEffect.extraWidth, levelEffect.y + levelEffect.extraHeight * 2 + levelEffect.textSize * 3 - 5, levelEffectMeasuredText.width + levelEffect.extraWidth * 2, levelEffectMeasuredText.actualBoundingBoxAscent + 20,
        {fillStyle: 'rgb(197, 60, 261)', strokeStyle: 'rgb(30, 33, 63)'}, 
        soundEffectsVolume, 'soundEffects');
    }

    createVolumeBars();

    // function that restarts the game
    function restart(e){
        // restores health and score variables 
        health = 100;
        score = 0;
    
        // empties all arays and repositions player
        enemies = [];
        bullets = [];
        bloodParticles = [];
        explosionParticles = [];
        player.x = canvas.width / 2;
        player.y = canvas.width / 2;
        level = 0;
        if(skipinstructions){
            wave = 1;
            enemiesLeft = 5;
            dialogCount = 10;
        } else{
            wave = 0;
            enemiesLeft = 0;
            dialogCount = 0;
        }
        exps = 0;
        maxExps = 100;
        pause = false;
        expsExplosion = [];
        try{
            stopSpawnInterval();
        } catch{};
        spawnEnemies();
        try{
            stopDialogInterval();
        } catch{}
        startDialogInterval = '';

       
        if(skipinstructions == false){
        dialogState = 'onprogress';
        addDialog({text: "Hello and welcome to my game! My name is Karak10 and this is the first game I have ever created. If I coded this correctly, clicking your screen should make the next dialog appear.", 
        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
        {inUse: true, color: 'black', width: 1 },
        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
        }

        endingScene = 0;
        opacity = 0;
        opacityIncrement = 0.001;

        policeCars.forEach((policeCar)=>{
            policeCar.x = policeCar.originalPosition.x;
            policeCar.y = policeCar.originalPosition.y;
            policeCar.angle = policeCar.originalPosition.angle;
            policeCar.lastAngle = policeCar.originalPosition.angle;
            policeCar.state = 'rotating';
            policeCar.num = 0;
        })

        // draws background
        c.clearRect(0, 0, canvas.width, canvas.height);
    
        // updates imageData to remove blood from screen
        imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    }
    
    // function that updates the particles
    function updateParticles(){
    
    if(health < 100){
        health += 0.01;
    } else{
        health = 100;
    }

        // updates blood
        bloodParticles.forEach((blood, i)=>{
            blood.update();
            if(blood.life_time < 0){
                bloodParticles.splice(i, 1);
            }
        });
    
        // updates imageData after new blood has been added, before anything else is drawn
        imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
        // updates bullets
        bullets.forEach((bullet, i)=>{
            // if bullet leaves the canvas viewport it removes the bullet
            if(bullet.x - bullet.r < 0 |
            bullet.x > canvas.width - bullet.r |
            bullet.y - bullet.r < 0 |
            bullet.y > canvas.height - bullet.r){
                bullets.splice(i, 1);
            }
            // if bullet's opacity is 0 it removes the bullet
            if(bullet.opacity == 0){
                bullets.splice(i, 1);
            }
            bullet.update();
        });
    
        // updates the player
        player.update(enemies);
    
        // checks if there are enemies to be removed
        enemies.forEach((enemy, i)=>{
            // checks if health is less than zero
            if(enemy.health <=0){
                // increases score
                score += 1;
                // if score is bigger than highscore updates highscore
                if(score > highscore){
                    highscore = score;
                }
    
                // removes the enemy
                enemies.splice(i, 1);
                // decreases the enemiesLeft variable
                enemiesLeft -= 1;
    
                // checks if explosion_effect is true
                if(explosion_effect){
                    // sets number of explosion particles to be created
                    let particlesCount = 30;
                    // devides a full circle by the number of explosion particles
                    let angleIncrement = Math.PI * 2 / particlesCount;
    
                    // a loop that creates the explosion particles
                    for(let i = 0; i < particlesCount; i++){
                        let velocity = {
                            x: Math.cos(angleIncrement * i) * Math.random() * 3,
                            y: Math.sin(angleIncrement * i) * Math.random() * 3
                        }
                        let x = enemy.x;
                        let y = enemy.y;
                        let r = enemy.r / 5;
                        let color = enemy.cl;
                        playSoundEffect(boomSoundEffect, 0, 'boom');
                        explosionParticles.push(new explosion(x, y, r, color, velocity, 'death-explosion'));
                    }
                }
                if(enemiesLeft == 0){
                    if(wave == 1){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Great job, you are really good at it, those are the normal type of.... um... \"monsters\"... that you will be facing throughout the game, I have created two more types though, to make the game a little bit more entertaining.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 11;
                    }
                    else if(wave == 2){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Very well, you are doing pretty good, so I think it is time to add another enemey to the game, to make the waves a little bit more challenging.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 15;
                    }
                    else if(wave == 3){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "They weren't too hard, were they? They do are easy the truth is, but they can be annoying, especially when more enemies are around, so try getting rid of them as early as you can.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 19;
                    }
                    else if(wave == 4){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Done already? That's just like you, always gets the job done, quickly and clean, you should be given a raise or something, sadly, I have no money to give you, but we can become friend if you want this.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 21;
                    }
                    else if(wave == 5){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Another wave has been cleared, five waves left, I don't know if this will motivate you to continue, but yes, there is an actual ending, in fact, there are three different endings that exist currently in the game, will you get the good ending though?", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 23;
                    }
                    else if(wave == 6){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "It seems it now is a great time to add one more and last type of monster to the game, the 'tank monster'.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 26;
                    }
                    else if(wave == 7){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Did you like the new monster? Those should raise the difficulity of the waves a little, we have no time to waste though, the end is near, click your screen so that the next wave begins and we will speak more after you clear it.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 29
                    }
                    else if(wave == 8){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "There isn't much time left, you gotta finish those two waves quickly, since we are friends I will make the next wave a little bit easier, it's too late to turn back now, you have to finish what you started.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 31
                    }
                    else if(wave == 9){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "You reached the final wave, you really are patient to go through all those waves and kill all those monsters, I'm glad you didn't give up and stay till the end, it makes me really happy.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                        dialogCount = 33
                    }
                    else if(wave == 10){
                        dialogState = 'onprogress';
                        dialog = [];
                        addDialog({text: "Everything is over now, you did a great job, you really did, however, I'm afraid we have no much time left to celebrate your victory.", 
                        color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                        {inUse: true, color: 'black', width: 1 },
                        canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 60);
                        dialogCount = 36
                        gameplayMusic1.pause();
                    }
                }
            }
        });
    
        // updates the enemies
        enemies.forEach((enemy)=>{
            enemy.update(enemies, bullets);
        });
    
        // updates the explosion particles
        explosionParticles.forEach((particle, i)=>{
            particle.update();
            // if opacity is less or equal to zero it removes particle 
            if(particle.alpha <= 0){
                explosionParticles.splice(i, 1);
            }
        });
    
        // updates the health bars of the enemies
        enemies.forEach((enemy)=>{
            enemy.drawHealthBar();
        });
    
        // updates the exps explosion particles
        expsExplosion.forEach((particle, i)=>{
            particle.update();
            // if opacity is less or equal to zero it removes particle 
            if(particle.alpha <= 0){
                expsExplosion.splice(i, 1);
            }
        });
    
        // updates the joysticks
        joyStick.update(player);
        shootJoyStick.update();
    
        // removes the click event listener that restarts the game
        canvas.removeEventListener('click', restart);
    }
    
    // function that draws the particles
    function drawParticles(){
        // updates blood
        bloodParticles.forEach((blood, i)=>{
            blood.update();
            if(blood.life_time < 0){
                bloodParticles.splice(i, 1);
            }
        });
    
        // updates imageData after new blood has been added, before anything else is drawn
        imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
        // draws bullets
        bullets.forEach((bullet, i)=>{
            bullet.draw();
        });
    
        // draws the player
        player.draw();

        // draws the enemies
        enemies.forEach((enemy)=>{
            enemy.draw();
        });

        // draws the explosion particles
        explosionParticles.forEach((particle, i)=>{
            particle.draw();
        });

        // draws the health bars of the enemies
        enemies.forEach((enemy)=>{
            enemy.drawHealthBar();
        });
    
        // draws the exps explosion particles
        expsExplosion.forEach((particle, i)=>{
            particle.draw();
        });
    
        // draws the joysticks
        joyStick.draw();
        shootJoyStick.draw();
    }

    // function that creates game over screen 
    function gameOver(){
        try{
        pauseDialogInterval();
        }catch{}
        gameplayMusic1.pause();
        if(level > 0 || exps > 0){
            if(gameOverMusicHasStarted == false){
                gameOverMusic.currentTime = 0;
                gameOverMusic.volume = 1;
                gameOverMusicHasStarted = true;
            }
            pauseButton.mouseOver = false;
            c.fillStyle = 'black';
            c.fillRect(0, 0, canvas.width, canvas.height);
            let aspectRatio = image7.naturalWidth / image7.naturalHeight;
            c.drawImage(image7, 0, 0, canvas.width, canvas.height / aspectRatio);
            c.fillStyle = 'yellow';
            c.strokeStyle = 'black';
            c.lineWidth = 2;
            c.font = `normal ${(canvas.width - canvas.width * (89 / 100) < 60)? canvas.width - canvas.width * (89 / 100): 60}px Luckiest Guy`;
            c.textAlign = 'center';
            let ttxt = 'GAME OVER!';
            c.fillText(ttxt, canvas.width / 2, canvas.height * (40 / 100))
            c.strokeText(ttxt, canvas.width / 2, canvas.height * (40 / 100));
            leaveButton.update();
        } else{
            if(goodEndingMusicHasStarted == false){
                goodEndingMusic.currentTime = 0;
                goodEndingMusic.volume = 1;
                goodEndingMusicHasStarted = true;
            }
            c.fillStyle = 'black';
            c.fillRect(0, 0, canvas.width, canvas.height);
            let aspectRatio = image8.naturalWidth / image8.naturalHeight;
            c.drawImage(image8, 0, 0, canvas.width, canvas.height / aspectRatio);
            c.fillStyle = 'yellow';
            c.strokeStyle = 'black';
            c.lineWidth = 2;
            c.font = `normal ${(canvas.width - canvas.width * (89 / 100) < 60)? canvas.width - canvas.width * (89 / 100): 60}px Luckiest Guy`;
            c.textAlign = 'center';
            let ttxt = 'GAME OVER?';
            c.fillText(ttxt, canvas.width / 2, canvas.height * (40 / 100))
            c.strokeText(ttxt, canvas.width / 2, canvas.height * (40 / 100));
            leaveButton.update();
        }
    }
    
    // function that draws the player h ealthbar, the
    // exps bar and the kills, level, wave counter
    function healthbarAndScores(){    
        c.textAlign = 'left';
        c.font = 'normal 15px Arial';
    
        // creates exps bar
        c.fillStyle = 'grey'
        c.fillRect(canvas.width - (canvas.width / 2), 15, ((canvas.width / 2) - 20), 20);
        c.fillStyle = 'lightblue';
        // it multiplies the width with (exps / 100) so that
        // as the exps increase the width gets bigger  
        c.fillRect(canvas.width / 2, 15, ((canvas.width / 2) - 20) * (exps / maxExps), 20);
        c.globalAlpha = 1;
        c.fillStyle = 'black';
        c.fillText('Exps', canvas.width / 2 + 2, 30);
        c.lineWidth = 2;
        c.strokeStyle = 'black';
        c.strokeRect(canvas.width / 2, 15, (canvas.width / 2) - 20, 20);
    
        // creates the health bar
        c.fillStyle = 'grey'
        c.fillRect(canvas.width / 2, 40, ((canvas.width / 2) - 20), 20);
        c.fillStyle = 'lightgreen';
        // it multiplies the width with (health / 100) so that
        // as the health decreases the width gets smaller  
        c.fillRect(canvas.width / 2, 40, ((canvas.width / 2) - 20) * (health / 100), 20);
        c.globalAlpha = 1;
        c.fillStyle = 'black';
        c.fillText('Health', canvas.width / 2 + 2, 56);
        c.lineWidth = 2;
        c.strokeStyle = 'black';
        c.strokeRect(canvas.width - (canvas.width / 2), 40, (canvas.width / 2) - 20, 20);
    
        c.alignText = 'left';
        c.strokeStyle = 'rgb(30, 33, 63)';
        c.lineWidth = 2;
        let spaceInBetween = 5;
        c.font = `normal ${(canvas.width * (3 / 100) < 40 && canvas.width * (4 / 100) > 20)? canvas.width * (4 / 100):(canvas.width * (3 / 100) <= 20)? 20: 40}px Luckiest Guy`;
        c.fillStyle = 'yellow';
        c.fillText(`Level: ${level}`, 15, 40);
        c.strokeText(`Level: ${level}`, 15, 40);
        let levelMeasureText = c.measureText(`Level: ${level}`);
        c.fillStyle = 'coral';
        c.fillText(`Kills: ${score}`, 15, 40 + levelMeasureText.actualBoundingBoxAscent + spaceInBetween);
        c.strokeText(`Kills: ${score}`, 15, 40 + levelMeasureText.actualBoundingBoxAscent + spaceInBetween);
        let y1 = 40 + levelMeasureText.actualBoundingBoxAscent + spaceInBetween;
        let killMeasureText = c.measureText(`Kills: ${score}`);
        c.fillStyle = 'lightblue';
        c.fillText(`Wave: ${wave}`, 15, y1 + killMeasureText.actualBoundingBoxAscent + spaceInBetween);
        c.strokeText(`Wave: ${wave}`, 15, y1 + killMeasureText.actualBoundingBoxAscent + spaceInBetween)
        let y2 = y1 + killMeasureText.actualBoundingBoxAscent + spaceInBetween;
        let waveMeasureText = c.measureText(`Wave: ${wave}`);
        c.fillStyle = 'pink';
        c.fillText(`Enemies: ${enemiesLeft}`, 15, y2 + waveMeasureText.actualBoundingBoxAscent + spaceInBetween);
        c.strokeText(`Enemies: ${enemiesLeft}`, 15, y2 + waveMeasureText.actualBoundingBoxAscent + spaceInBetween)

        pauseButton.y = y2 + pauseButton.extraWidth;
        if(endingScene){
            pauseButton.draw();
        } else{
            pauseButton.update();
        }

        c.setTransform(1,0,0,1,0,0);
    }

    // function that draws the background of the home screen
    function background(){
        function laser(x, y, width, height, angle){
            c.save();
            c.translate(x, y);
            c.rotate(angle);
            c.beginPath();
            c.moveTo(-width, -height);
            c.lineTo(-25, 0);
            c.lineTo(25, 0);
            c.lineTo(width, -height);
            c.closePath();
            c.fill();
            c.restore();
        }
        angleIncrement += 0.001
        c.fillStyle = 'rgb(177, 40, 241)';
        c.fillRect(0, -100, canvas.width, canvas.height + 100);
        c.lineWidth = 1;
        c.fillStyle = 'rgb(206, 118, 172)';
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI * 2) + angleIncrement);
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI) + angleIncrement);
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI / 3) + angleIncrement);
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI - Math.PI / 3) + angleIncrement);
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI + Math.PI / 3) + angleIncrement);
        laser(canvas.width/2, canvas.height/2, 100, canvas.height, (Math.PI * 2 - Math.PI / 3) + angleIncrement);
    
        c.fillStyle = 'yellow';
        c.beginPath();
        c.arc(canvas.width/2, canvas.height/2 + 40, 130, 0, Math.PI * 2);
        c.fill();
    
        c.fillStyle = 'rgb(148, 224, 77)';
        c.beginPath();
        c.arc(100, canvas.height + 200, 400, 0, Math.PI * 2);
        c.fill();
    
        c.fillStyle = 'rgb(108, 161, 59)';
        c.beginPath();
        c.arc(100, canvas.height + 240, 400, 0, Math.PI * 2);
        c.fill();
    
        c.fillStyle = 'rgb(148, 224, 77)';
        c.beginPath();
        c.arc(canvas.width - 50, canvas.height + 230, 400, 0, Math.PI * 2);
        c.fill();
    
        c.fillStyle = 'rgb(108, 161, 59)';
        c.beginPath();
        c.arc(canvas.width - 55, canvas.height + 260, 400, 0, Math.PI * 2);
        c.fill();
        c.setTransform(1,0,0,1,0,0);
    }

    // function that draws the pause screen
    function pauseScreen(){
        background();
    
        resumeButton.update();
        leaveButton.update();
        OptionsButton.update();
        pausedGameTitle.update();
        c.setTransform(1,0,0,1,0,0);
    }

    // function that draws the start screen
    function startScreen(){
        background();
        title.update();
    
        startButton.update();
        optionsButton2.update();
        credits.update();
    
        c.setTransform(1,0,0,1,0,0);
    }

    // function that draws the options screen
    function optionsScreen(){
        background();
        explosionEffect.update();
        levelEffect.update();
        backButton.update();
        musicVlmBar.update();
        soundsVlmBar.update();
        c.setTransform(1,0,0,1,0,0);
    } 

    // function that checks if the mouse is hovered over any 
    // of the buttons, or any of the buttons is touched
    function checkForButtonClicks(){
        if(endingLeaveButton.mouseOver){
            alert("What's done can't be undone - William Shakespeare");
        }
        // checks if mouseOver property of leaveButton is true
        if(leaveButton.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            playSound(startScreenMusic, 0);
            gameplayMusic1.pause();
            gameOverMusicHasStarted = false;
            gameOverMusic.volume = 0;
            goodEndingMusicHasStarted = false;
            goodEndingMusic.volume = 0;
            speechSoundEffect.volume = 0;
            // if true then sets hasStarted, paused,
            // and leaveButton.mouseOver to false
            hasStarted = false;
            paused = false;
            leaveButton.mouseOver = false;
        }
        // checks if mouseOver property of resumeButton is true
        if(resumeButton.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            // if true then sets pause 
            // and resumeButton.mouseOver to false
            pause = false;
            resumeButton.mouseOver = false;
            try{
                try{
                    if(dialogState != 'finished'){
                        startDialogInterval();
                    }
                }catch{}
            }catch{}
        }
        // checks if mouseOver property of startButton is true
        if(startButton.mouseOver && enterGameOpacity < 0.3){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            playSound(gameplayMusic1, 0);
            startScreenMusic.pause();
            // if true it restarts the game and 
            // sets hasStarted to true, pause and 
            // startButton.mouseOver to false
            restart();
            hasStarted = true;
            pause = false;
            startButton.mouseOver = false;
        }
        // checks if mouseOver property of optionsButton2 is true
        if(optionsButton2.mouseOver && enterGameOpacity < 0.3){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            // if true it sets optionsOpened to true
            // and optionsButton2.mouseOver to false
            optionsOpened = true;
            optionsButton2.mouseOver = false;
        }
        // checks if mouseOver property of backButton is true
        if(backButton.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            creditsOpened = false;
            optionsOpened = false;
            backButton.mouseOver = false;
        }
        // checks if mouseOver property of explosionEffect button is true
        if(explosionEffect.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            // if true checks if explosion_effect is true or false, and 
            // sets it to opposite of what it currently is
            if(explosion_effect){
                explosion_effect = false;
            } else{
                explosion_effect = true;
            }
            // and then it sets mouseOver property to false
            explosionEffect.mouseOver = false;
        }
        // checks if mouseOver property of levelEffect button is true
        if(levelEffect.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            // if true checks if level_up_effect is true or false, and 
            // sets it to opposite of what it currently is
            if(level_up_effect){
                level_up_effect = false;
            } else{
                level_up_effect = true;
            }
            // and then it sets mouseOver property to false
            levelEffect.mouseOver = false;
        }
        if(OptionsButton.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            optionsOpened = true;
            OptionsButton.mouseOver = false;
        }
        if(enterGame.mouseOver){
            playSound(swallowSoundEffect, 0.3);
            playSound(startScreenMusic, 0);
            startSoundEffectLoop(bulletSoundEffect);
            startSoundEffectLoop(hitMarkerEffect);
            startSoundEffectLoop(boomSoundEffect);
            startSoundEffectLoop(damageSoundEffect);
            startSoundEffectLoop(gameOverMusic);
            startSoundEffectLoop(goodEndingMusic);
            startSoundEffectLoop(levelUpSoundEffect);
            startSoundEffectLoop(speechSoundEffect);
            enterGameOpacity = 1;
            swallowSoundEffect.addEventListener('ended', (e)=>{
                hasEnteredTheGame = true;
                enterGame.mouseOver = false;
            });
            enterGame.mouseOver = false;
            createButtons();
            createVolumeBars();
        }
        if(pauseButton.mouseOver){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            pause = true;
            pauseButton.mouseOver = false;
        }
        if(credits.mouseOver && enterGameOpacity < 0.3){
            playSound(clickSoundEffect, buttonSoundEffectStartTime);
            credits.mouseOver = false;
            creditsOpened = true;
        }
    }

    function checkForDialogs(){
        if((dialogState == 'finished' && pause == false) && health > 0 && pauseButton.mouseOver == false){
            if(dialogCount == 0){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Very well, it seems like everything works as expected, please, try moving around, you can use the arrow keys on your keyboard or the \"move\" joystick if you are using a touch screen.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 2;
            }
            else if(dialogCount == 3){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Wanna know another trick? You can actually shoot bullets too, to do that either click and hold your mouse button where you want to shoot or use the \"shoot\" joystick.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 4;
            }
            
            else if(dialogCount == 8){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "I'm only gonna give you 10 waves, complete these and the game will be finished, click your screen when you are ready and the first wave will begin.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 9;
            }
            else if(dialogCount == 9){
                dialogCount = 10;
                dialog = [];
                wave = 1;
                spawnEnemies();
                enemiesLeft = wave * 5;
                skipinstructions = true;
            }
            else if(dialogCount == 11){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Those monsters aren't very hard to kill, let too many gather together however and they could get dangerous, I don't really think they will be a problem for you, just be careful and have fun.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 12;
            }
            else if(dialogCount == 12){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Click your screen when you are ready for the second wave.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 13;
            }
            else if(dialogCount == 13){
                dialogCount = 14;
                dialog = [];
                wave = 2;
                spawnEnemies();
                enemiesLeft = wave * 5;
            }
            else if(dialogCount == 15){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "The new type of enemy you will face, is the, umm... 'kid monsters'... Do not let their appearence trick you though, they may look cute but they can be very dangerous, they do have less health, but they also run faster and are harder to hit, since they are small, be careful with those monsters.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 16;
            }
            else if(dialogCount == 16){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "When you are ready to meet those new enemies, click your screen and the wave will begin, good luck.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 17;
            }
            else if(dialogCount == 17){
                dialogCount = 18;
                dialog = [];
                wave = 3;
                spawnEnemies();
                enemiesLeft = 10;
            }
            else if(dialogCount == 19){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Let's continue, click your screen and the next wave will begin, there is no time to waste, those monsters aren't gonna get killed on their own.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 19.5;
            }
            else if(dialogCount == 19.5){
                dialog = [];
                dialogCount = 20;
                wave = 4;
                spawnEnemies();
                enemiesLeft = 15;
            }
            else if(dialogCount == 21){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "You are getting closer to the end, it will take a while, I will introduce you to one more monster later, for now let's just have fun, killing monsters, gaining exps, isn't that how people get entertained now days?", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 21.1;
            }
            else if(dialogCount == 21.1){
               dialogState = 'onprogress';
               dialog = [];
               addDialog({text: "Anyway, see you later, have fun, and remember, when you are touched by monsters you lose health, so keep your distance.", 
               color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
               {inUse: true, color: 'black', width: 1 },
               canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
               dialogCount = 21.2;
            }
            else if(dialogCount == 21.2){
                dialog = [];
                dialogCount = 22;
                wave = 5;
                spawnEnemies();
                enemiesLeft = 20;
            }
            else if(dialogCount == 23){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Anyway, in order to finish the game you gotta continue with the next wave, and kill some more monsters, when you are ready click your screen, and the next wave will begin.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 24;
            }
            else if(dialogCount == 24){
                dialog = [];
                dialogCount = 25;
                wave = 6;
                spawnEnemies();
                enemiesLeft = 20;
            }
            else if(dialogCount == 26){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "This monster is bigger, has way more health than normal enemies, does more damage if it touches you, but also moves slower. They can be annoying, because they take a lot of effort to kill, but they really aren't too hard, when you are ready to face them click your screen.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 27;
            }
            else if(dialogCount == 27){
                dialog = [];
                dialogCount = 28;
                wave = 7;
                spawnEnemies();
                enemiesLeft = 5;
            }
            else if(dialogCount == 29){
                dialog = [];
                dialogCount = 30;
                wave = 8;
                spawnEnemies();
                enemiesLeft = 20;
            }
            else if(dialogCount == 31){
                dialog = [];
                dialogCount = 32;
                wave = 9;
                spawnEnemies();
                enemiesLeft = 15;
            }
            else if(dialogCount == 33){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "Let's do this now, let's beat the last wave, this will be a little bit more challenging since it is the last, the enemies will spawn much faster, so be careful.", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 50);
                dialogCount = 34;
            }
            else if(dialogCount == 34){
                dialog = [];
                dialogCount = 35;
                wave = 10;
                spawnEnemies();
                enemiesLeft = 20;
            }
            else if(dialogCount == 36){
                dialogState = 'onprogress';
                dialog = [];
                addDialog({text: "It was nice to meet you, dear friend, but it is now time to wake up, you cannot keep running away from reality any longer, it is your responsibility to see the world how it truly is, how you made it be, I am sorry..", 
                color: 'white', font: `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`},
                {inUse: true, color: 'black', width: 1 },
                canvas.width * (10 / 100), canvas.height * (35 / 100), canvas.width * (80 / 100), 24, 60);
                dialogCount = 37;
            }
            else if(dialogCount == 37){
                if(trueEndingMusiHasStarted == false){
                    playSound(trueEndingMusic, 0);
                    trueEndingMusiHasStarted = true;
                }
                dialogCount = 38;
                endingScene = 1;
                stopSpawnInterval();
            }
        }
    }

    // triggers when canvas is clicked
    canvas.addEventListener('click', (e)=>{
        // runs the checkForButtonClicks function I wrote above
        checkForDialogs();
        checkForButtonClicks();
    });
    
    // triggers when a touch ends
    canvas.addEventListener('touchend', (e)=>{
        // prevents mouse events from triggering
        e.preventDefault();
        // runs the checkForButtonClicks function I wrote above
        checkForButtonClicks();
        checkForDialogs();
        // resets touch.x and touch.y values to zero
        touch.x = 0;
        touch.y = 0;
    });
    
    canvas.addEventListener('mousedown', (e)=>{
        if(musicVlmBar.mouseOver){
            musicVlmBar.mouseDown = true;
        }
        if(soundsVlmBar.mouseOver){
            soundsVlmBar.mouseDown = true;
        }
    });

    window.addEventListener('mouseup', (e)=>{
        soundsVlmBar.mouseDown = false;
        musicVlmBar.mouseDown = false;
    });

    // pauses the game when esc is pressed
    window.addEventListener('keyup', (e)=>{
        if(health > 0){
            if(e.keyCode == 27){
                if(pause){
                    // if options screen is open
                    // then it closes options screen
                    if(optionsOpened || creditsOpened){
                        optionsOpened = false;
                        creditsOpened = false;
                    } 
                    // else is closes pause screen
                    else{
                        try{
                            if(dialogState != 'finished'){
                                startDialogInterval();
                            }
                        }catch{}
                        pause = false;
                    }
                } else{
                    try{
                    pauseDialogInterval();
                    }catch{}
                    optionsOpened = false;
                    pause = true;
                }
            }
        }
    });

    // touch events for the volume bars

    let musicTouchIndex;
    let musicTouchIsActive = false;
    let musicTouchPosition = 0;

    let SoundEffectsTouchIndex;
    let SoundEffectsTouchIsActive = false;
    let SoundEffectsTouchPosition = 0;

    let isOverVolume = function(touch, volumeObject){
        if(optionsOpened == true){
            if((touch.clientX > volumeObject.x && touch.clientX < volumeObject.x + volumeObject.width) &&
            (touch.clientY > volumeObject.y && touch.clientY < volumeObject.y + volumeObject.height)){
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    canvas.addEventListener('touchstart', (e)=>{
        if(e.cancelable){
        e.preventDefault();
        }
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
        let touches = Array.from(e.touches);
        touches.forEach((touch, i) =>{
            let touchOnCanvas = {
                clientX: touch.clientX - left,
                clientY: touch.clientY - top
            }
            if(isOverVolume(touchOnCanvas, musicVlmBar)){
                musicTouchIndex = i;
                musicTouchIsActive = true;
                musicTouchPosition = touchOnCanvas.clientX;
                let distance = touchOnCanvas.clientX - musicVlmBar.x;
                if(distance > musicVlmBar.width){
                    distance = musicVlmBar.width;
                }
                if(distance < 0){
                    distance = 0;
                }  
                musicVolume = Math.floor(100 * (distance / musicVlmBar.width));
                musicVlmBar.percentage = musicVolume;
                updateMusicVolume();
            }
            if(isOverVolume(touchOnCanvas, soundsVlmBar)){
                SoundEffectsTouchIndex = i;
                SoundEffectsTouchIsActive = true;
                SoundEffectsTouchPosition = touchOnCanvas.clientX;
                let distance = touchOnCanvas.clientX - soundsVlmBar.x;
                if(distance > soundsVlmBar.width){
                    distance = musicVlmBar.width;
                }
                if(distance < 0){
                    distance = 0;
                }
                soundEffectsVolume = Math.floor(100 * (distance / soundsVlmBar.width));
                soundsVlmBar.percentage = soundEffectsVolume;
            }
        });
    });

    canvas.addEventListener('touchmove', (e)=>{
        if(e.cancelable){
        e.preventDefault();
        }
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
        let touches = Array.from(e.touches);
        touches.forEach((touch, i)=>{
            let touchOnCanvas = {
                clientX: touch.clientX - left,
                clientY: touch.clientY - top
            }
            if(musicTouchIsActive){
                if(Math.abs(musicTouchPosition - touchOnCanvas.x) < touch.radiusX + 10){
                    musicTouchIndex = i;
                }
            }
            if(SoundEffectsTouchIsActive){
                if(Math.abs(musicTouchPosition - touchOnCanvas.x) < touch.radiusX + 10){
                    SoundEffectsTouchIndex = i;
                }
            }
        });
        if(musicTouchIsActive){
            try{
                let touchOnCanvas = {
                    clientX: e.touches[musicTouchIndex].clientX - left,
                    clientY: e.touches[musicTouchIndex].clientY - top
                }
                musicTouchPosition = touchOnCanvas.clientX;
                let distance = touchOnCanvas.clientX - musicVlmBar.x;
                if(distance > musicVlmBar.width){
                    distance = musicVlmBar.width;
                }
                if(distance < 0){
                    distance = 0;
                }  
                musicVolume = Math.floor(100 * (distance / musicVlmBar.width));
                musicVlmBar.percentage = musicVolume;
                updateMusicVolume();
            } catch{}
        }
        if(SoundEffectsTouchIsActive){
            try{
                let touchOnCanvas = {
                    clientX: e.touches[SoundEffectsTouchIndex].clientX - left,
                    clientY: e.touches[SoundEffectsTouchIndex].clientY - top
                }
                SoundEffectsTouchPosition = touchOnCanvas.clientX;
                let distance = touchOnCanvas.clientX - soundsVlmBar.x;
                if(distance > soundsVlmBar.width){
                    distance = musicVlmBar.width;
                }
                if(distance < 0){
                    distance = 0;
                }
                soundEffectsVolume = Math.floor(100 * (distance / soundsVlmBar.width));
                soundsVlmBar.percentage = soundEffectsVolume;
            } catch{}
        }
    });

    canvas.addEventListener('touchend', (e)=>{
        if(e.cancelable){
        e.preventDefault();
        }
        let box = canvas.getBoundingClientRect();
        let left = box.left;
        let top = box.top;
        let touches = Array.from(e.changedTouches);
        touches.forEach((touch, i)=>{
            let touchOnCanvas = {
                clientX: touch.clientX - left,
                clientY: touch.clientY - top
            }
            if(musicTouchIsActive){
                if(Math.abs(musicTouchPosition - touchOnCanvas.clientX) < touch.radiusX + 10){
                    musicTouchIsActive = false;
                }
            }
            if(SoundEffectsTouchIsActive){
                if(Math.abs(SoundEffectsTouchPosition - touchOnCanvas.clientX) < touch.radiusX + 10){
                    SoundEffectsTouchIsActive = false;
                }
            }
        });
    });

    // this function is used to set 
    // mouseOver properties of paused 
    // screen buttons to false
    function resetPausedButtons(){
        leaveButton.mouseOver = false;
        resumeButton.mouseOver = false;
        OptionsButton.mouseOver = false;
    }
    
    // this function is used to set 
    // mouseOver properties of start
    // screen buttons to false
    function resetStartScreenButtons(){
        startButton.mouseOver = false;
        optionsButton2.mouseOver = false;
        credits.mouseOver = false;
    }
    
    // this function is used to set 
    // mouseOver properties of options
    // screen buttons to false
    function resetOptionsButtons(){
        explosionEffect.mouseOver = false;
        levelEffect.mouseOver = false;
        backButton.mouseOver = false;
    }

    // police car constructor for the ending scene
    let policeCar = class{
        constructor(x, y, width, height, destinations, speed, angle){
            this.x = x;
            this.y = y;
            this.originalPosition = {x: x, y: y, angle: angle};
            this.width = width;
            this.height = height;
            this.destinations = destinations;
            this.speed = speed;
            this.num = 0;
            this.hasFinished = false;
            this.angle = angle;
            this.lastAngle = angle;
            this.state = 'rotating';
        }
        draw(){
            c.save();
            c.fillStyle = 'black';
            c.translate(this.x, this.y);
            let radians = this.angle * Math.PI / 180;
            c.rotate(radians);
            let aspectRatio = image11.naturalWidth / image11.naturalHeight;
            let width = (player.r * 2) * 5;
            let height = width / aspectRatio;
            c.drawImage(image11, -(width / 2), -(height / 2), width, height); 
            c.restore();
        }
        update(){
            if(this.state != 'finished'){
                let [x1, y1] = [this.x, this.y];
                let [x2, y2] = [this.destinations[this.num].x, this.destinations[this.num].y];
                let [vX, vY] = [x2 - x1, y2 - y1];
                let λ = (vY) / (vX);
                let radians = Math.atan2(vY, vX);
                let degrees = radians * 180 / Math.PI;
                let distance = Math.hypot(vY, vX);
                let clockWiseDifference;
                let counterClockWiseDifference;
                if(this.lastAngle < 0){
                    if(this.lastAngle > degrees){
                        clockWiseDifference = 360 + degrees - this.lastAngle;
                        counterClockWiseDifference = (360 + this.lastAngle) - (360 + degrees);
                    } else{
                        clockWiseDifference = degrees + Math.abs(this.lastAngle);
                        counterClockWiseDifference = 360 + this.lastAngle - degrees;
                    }
                } else if(this.lastAngle > 0){
                    if(this.lastAngle > degrees){
                        clockWiseDifference = 360 - this.lastAngle + degrees;
                        counterClockWiseDifference = 360 - degrees - (360 - this.lastAngle);
                    } else{
                        clockWiseDifference = degrees - this.lastAngle;
                        counterClockWiseDifference = this.lastAngle + 360 - degrees;
                    }
                } else if(this.lastAngle == 0){
                    if(0 > degrees){
                        clockWiseDifference = 360 + degrees;
                        counterClockWiseDifference = Math.abs(degrees);
                    } else{
                        clockWiseDifference = degrees;
                        counterClockWiseDifference = 360 - degrees;
                    }
                }
                if(distance > 0){
                    if(clockWiseDifference < counterClockWiseDifference){
                        if(this.lastAngle < 0){
                            let finishCondition;
                            if(degrees < 0){
                                finishCondition = Math.abs(this.lastAngle - degrees) < 1;
                            } else{
                                finishCondition = Math.abs(degrees - this.lastAngle) < 1;
                            }
                            if(finishCondition){
                                this.state = 'ready';
                            } else {
                                this.angle += 0.5;
                                this.lastAngle += 0.5;
                            }
                        } else if(this.lastAngle >= 0){
                            let finishCondition;
                            if(degrees < 0){
                                finishCondition = Math.abs(this.lastAngle - (360 + degrees)) < 1;
                            } else{
                                finishCondition = Math.abs(this.lastAngle - degrees) < 1;
                            }
                            if(finishCondition){
                                this.state = 'ready';
                            } else {
                                this.angle += 0.5;
                                this.lastAngle += 0.5;
                            }
                        }
                    } else{
                        if(this.lastAngle < 0){
                            if(Math.abs(360 + this.lastAngle) - degrees < 1){
                                this.state = 'ready';
                            } else {
                                this.angle -= 0.5;
                                this.lastAngle -= 0.5;
                            }
                        } else {
                            if(Math.abs(this.lastAngle - degrees) < 1){
                                this.state = 'ready';
                            } else {
                                this.angle -= 0.5;
                                this.lastAngle -= 0.5;
                            }
                        }
                    }
                    if(this.state == 'ready'){
                        if(Math.abs(vX) > Math.abs(vY)){
                            if(vX > 0){
                                this.x += this.speed;
                                if(this.x > this.destinations[this.num].x){
                                    this.x = this.destinations[this.num].x
                                }
                            } else{
                                this.x -= this.speed;
                                if(this.x < this.destinations[this.num].x){
                                    this.x = this.destinations[this.num].x;
                                }
                            }
                            this.y = λ * (this.x - x1) + y1;
                        } else{
                            if(vY > 0){
                                this.y += this.speed;
                                if(this.y > this.destinations[this.num].y){
                                    this.y = this.destinations[this.num].y;
                                }
                            } else{
                                this.y -= this.speed;
                                if(this.y < this.destinations[this.num].y){
                                    this.y = this.destinations[this.num].y;
                                }
                            }
                            this.x = (this.y / λ) + x1 - (y1 / λ);
                        }
                    }
                } else{
                    if(this.destinations.length - 1 == this.num){
                        this.x = this.x;
                        this.y = this.y;
                        this.angle = this.angle;
                        this.state = 'finished';
                    } else{
                        this.num += 1;
                        this.state = 'rotating';
                        if(this.lastAngle > 360){
                            this.lastAngle = this.lastAngle - 360;
                            this.angle = this.angle - 360;
                        }
                        if(this.lastAngle < -360){
                            this.lastAngle = this.lastAngle + 360;
                            this.angle = this.angle + 360;
                        }
                    }
                }
            }
            this.draw();
        }
    }

    let carAspectRatio = image11.naturalWidth / image11.naturalHeight;
    let carWidth = (player.r * 2) * 5;
    let carHeight = carWidth / carAspectRatio;

    let policeCar1 = new policeCar(-500, 50, 50, 20, [{x: canvas.width / 2 - (((player.r * 2) * 5) / 2) + 100, y: canvas.height / 2 - ((player.r * 2) + 70)}], 3, 0);

    let policeCar2 = new policeCar(canvas.width + 500, canvas.height + 50, 50, 20, [{x: canvas.width / 2 + (((player.r * 2) * 5) / 2) - 100, y: canvas.height / 2 + ((player.r * 2) + 100)}], 3, - 170);

    let policeCar3 = new policeCar(50, canvas.height + 100, 50, 20, [{x: (canvas.width / 2) - 100, y: canvas.height / 2}], 3, -25);

    let policeCar4 = new policeCar(canvas.width + 50, -90, 50, 20, [{x: (canvas.width / 2) + 100, y: canvas.height / 2 + 30}], 3, 170);

    let policeCar5 = new policeCar(50, canvas.height + 300, 50, 20, [{x: policeCar3.destinations[0].x - carHeight - 10, y: canvas.height / 2 + 30}], 3, 170);

    let policeCar6 = new policeCar(-500, canvas.height, 50, 20, [{x: policeCar2.destinations[0].x - carWidth, y: policeCar5.destinations[0].y + (carWidth / 2) + 60}], 3, 170);

    let policeCar7 = new policeCar(canvas.width + 400, canvas.height + 400, 50, 20, [{x: policeCar2.destinations[0].x + carWidth, y: policeCar2.destinations[0].y + 20}], 3, 170);

    let policeCar8 = new policeCar(canvas.width + 20, -800, 50, 20, [{x: policeCar4.destinations[0].x + (carHeight) + 30, y: policeCar7.destinations[0].y - (carWidth / 2) - 50}], 3, 170);

    let policeCar9 = new policeCar(canvas.width + 1800, 60, 50, 20, [{x: policeCar1.destinations[0].x + carWidth, y: policeCar8.destinations[0].y - carWidth}], 3, 170);

    let policeCar10 = new policeCar(-1800, 500, 50, 20, [{x: policeCar5.destinations[0].x, y: policeCar5.destinations[0].y - carWidth}], 3, -30);

    let policeCars = [policeCar1, policeCar2, policeCar3, policeCar4, policeCar5, policeCar6, policeCar7, policeCar8, policeCar9, policeCar10];

    let endingSceneData;

    // function that runs again and again to animate the canvas
    let animate = function(){
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.globalAlpha = 1;
        if(hasEnteredTheGame){
            if(enterGameOpacity > 0){
                enterGameOpacity -= 0.006;
                if(enterGameOpacity < 0){
                    enterGameOpacity = 0;
                }
            }
            if(hasStarted){
                // checks if canvas is scrolled into view,
                // and if not then pauses the game
                if(isScrolledIntoView(canvas) == false){
                    pause = true;
                }
    
                // checks game is not paused
                if(pause == false || endingScene){
                    // sets all mouseOver properties of 
                    // paused screen buttons to false
                    resetPausedButtons();
                    // resets mouseOver properties of 
                    // options screen buttons to false
                    resetOptionsButtons();
                    // checks if health is greater than zero
                    if(health > 0){
                        // clears the canvas
                        c.clearRect(0, 0, canvas.width, canvas.height);
    
                        // adds the blood on the canvas if blood_effect is true
                        if(blood_effect){
                            c.putImageData(imageData, 0, 0);
                        }

                        if(endingScene > 0){
                            if(endingScene == 2){
                                c.globalAlpha = 1;
                                c.putImageData(imageData, 0,0);
                                player.draw();
                                if(opacity == 0){
                                    policeCars.forEach((policeCar)=>{
                                        policeCar.update();
                                    });
                                    if(policeCar10.state == 'finished'){
                                       endingSceneData = c.getImageData(0, 0, canvas.width, canvas.height);
                                       opacityIncrement = Math.abs(opacityIncrement);
                                       endingScene = 3;
                                       dialog = [];
                                    }
                                }
                            } else if(endingScene == 3){
                                c.putImageData(endingSceneData, 0, 0);
                                opacity += opacityIncrement;
                                if(opacity >= 1){
                                    opacity = 1;
                                }
                                c.globalAlpha = opacity;
                                gameOverTitle.update();
                                endingLeaveButton.update();
                            } else{
                                drawParticles();
                                healthbarAndScores();
                            }
                            if(endingScene != 3){
                                c.fillStyle = 'black';
                                c.globalAlpha = opacity;
                                c.fillRect(0, 0, canvas.width, canvas.height);
                                if(opacity <= 1){
                                    opacity += opacityIncrement;
                                    if(opacityIncrement > 0){
                                        c.globalAlpha = 1;
                                    } 
                                    if(opacity <= 0){
                                        opacity = 0;
                                    }
                                } else if(opacity > 1){
                                    opacityIncrement = (opacityIncrement < 0)? opacityIncrement: -1 * opacityIncrement;
                                    opacity += opacityIncrement;
                                    endingScene = 2;
                                    player.x = canvas.width / 2;
                                    player.y = canvas.height / 2;
                                    canvas.style.backgroundImage = `url(${image9.src})`;
                                    // makes blood red
                                    for(let i = 3; i < imageData.data.length; i += 4){
                                        if((imageData.data[i] / 255) < 1){
                                            imageData.data[i] = 0;
                                        } else{
                                            imageData.data[i] = 140;
                                            imageData.data[i - 1] = 0;
                                            imageData.data[i - 2] = 0;
                                            imageData.data[i - 3] = 255;
                                        }
                                    }
                                }
                            }       
                        } else{
                            updateParticles();
                            healthbarAndScores();
                        }

                        if(dialog.length > 0){
                        angleIncrement += 0.1;
                        drawDialog(angleIncrement);
                        }
                    } 
                    // if health is not greater zero then it draws the game over screen
                    else{
                        gameOver();
                    }
                }
                // if page is not viewed then draws the pause screen
                else{
                    pauseButton.mouseOver = false;
                    // checks if optionsOpened is true
                    if(optionsOpened){
                        // resets the mouseOver property of 
                        // paused screen buttons to false
                        resetPausedButtons();
                        // draws the options screen
                        optionsScreen();
                    } 
                    // else if optionsOpened isn't true 
                    else{
                        // resets the mouseOver property of 
                        // options screen buttons to false
                        resetOptionsButtons();
                        // draws the pause screen
                        pauseScreen();
                        try{
                        pauseDialogInterval();
                        }catch{}
                    }
                }
            } 
            else {
                // sets all mouseOver properties of 
                // paused screen buttons to false
                resetPausedButtons();
                if(optionsOpened){
                    // sets all mouseOver properties of 
                    // start screen buttons to false
                    resetStartScreenButtons();
                    optionsScreen();
                } else if(creditsOpened){
                    resetStartScreenButtons();
                    background();
                    c.textAlign = 'left';
                    let lineHeight;
                    c.font = `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`;
                    let ttxt = 'The game was made by me, Karak10, however, I do not own any of the music or sound effects, and most of the images also are not mine. I am not an artist, just a programmer, and this project took me weeks to make, so I hope you enjoy it. Lastly, I am not hiding that this game is indeed inspired by Pony Island, so there are a lot of similarities you may notice.';
                    let lines = wrapText(ttxt, canvas.width * (10 / 100), canvas.height * (40 / 100), canvas.width * (80 / 100), 20,
                    {font: `normal px${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20} Luckiest Guy`, stroke: {inUse: true, width: 1}});
                    lines.forEach((line)=>{
                        lineHeight = line.y;
                    });
                    c.lineWidth = 3;
                    c.fillStyle = 'rgb(177, 40, 241)';
                    c.strokeStyle = 'black';
                    c.fillRect(canvas.width * (10 / 100) - 20, canvas.height * (40 / 100) - ((canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20) - 20, canvas.width * (80 / 100) + 40, lineHeight - canvas.height * (40 / 100) + 55);
                    c.strokeRect(canvas.width * (10 / 100) - 20, canvas.height * (40 / 100) - ((canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20) - 20, canvas.width * (80 / 100) + 40, lineHeight - canvas.height * (40 / 100) + 55);
                    c.fillStyle = 'yellow';
                    c.lineWidth = 1;
                    lines.forEach((line)=>{
                        c.fillText(line.line, canvas.width * (10 / 100), line.y)
                        c.strokeText(line.line, canvas.width * (10 / 100), line.y);
                    });
                    backButton.update();
                } else {
                    // sets all mouseOver properties of 
                    // options screen buttons to false
                    resetOptionsButtons();
                    startScreen();
                } 
            }
        } else {
            c.fillStyle = 'black';
            c.globalAlpha = 1;

            let aspectRatio = image6.naturalWidth / image6.naturalHeight;
            if(canvas.height * aspectRatio > canvas.width){
                let difference = (canvas.height * aspectRatio) - canvas.width;
                c.drawImage(image6, - (difference / 2), 0, canvas.height * aspectRatio, canvas.height);
            } else if(canvas.height * aspectRatio < canvas.width){
                let difference = (canvas.width / aspectRatio) - canvas.height;
                c.drawImage(image6, 0, 0, canvas.width, (canvas.width / aspectRatio) - (difference / 2));
            } else{
                c.drawImage(image6, 0, 0, canvas.height * aspectRatio, canvas.height);
            }
            if(musicState == 'ready'){
                if(enterGameOpacity == 0){
                    enterGame.update();                
                }
            } else {
                c.textAlign = 'left';
                c.fillStyle = 'yellow';
                c.strokeStyle = 'black';
                c.lineWidth = 2;
                c.font = `normal ${(canvas.width * (3 / 100) < 20 && canvas.width * (3 / 100) > 15)? canvas.width * (3 / 100):(canvas.width * (3/ 100) <= 15)? 15: 20}px Luckiest Guy`;
                let ttxt = 'The game will be ready to play soon, please wait while the sources are loading...';
                let lines = wrapText(ttxt, canvas.width * (10 / 100), canvas.height/2 - 20, canvas.width * (80 / 100), 20,
                {font: 'normal 20px Luckiest Guy', stroke: {inUse: true, width: 1}});
                lines.forEach((line)=>{
                    c.fillText(line.line, canvas.width * (10 / 100), line.y)
                    c.strokeText(line.line, canvas.width * (10 / 100), line.y);
                });
            }
        }
        c.fillStyle = 'black';
        c.globalAlpha = enterGameOpacity;
        c.fillRect(0, 0, canvas.width, canvas.height);
        c.setTransform(1,0,0,1,0,0);
        buttonsIncrement += 0.01;
        requestAnimationFrame(animate);
    }
    
    // begins the animation
    animate()

});

}
</script>


</article>

<hr>

<article id="twentyseven">
<header>
<h1>Pixels rain</h1>

<p>So, in this section, and probably the following sections as well, we will
work some more with the pixel array, and create some projects to get better
at using it.
</p>

<p>The project we will create in this section will be a lot of particles, who will
move around the screen, vertically, however, I want to make it so that those particles
move slower when passing from bright parts of the canvas, and slower when not.
So, basically, we need to make a code that will give us each pixel's position
on the canvas with the calculated brightness it has, to measure the brightness we
will borrow an equation from google, basically, we could simply add up the red,
green and blue values of the pixel and devide the outcome by 3, however, because
the way that human eyes see brightness is complicated, even tho this simple
equation would work, it wouldn't be perfect, that's why we are gonna borrow that
other more advanced equation I found online. For now however, let's just
begin by making the basic structure of our project, let's create the moving particles,
and we will work on the pixels array later.
</p>

<p class='left'>JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvvvaas1');
let c = canvas.getContext('2d');

let image = new Image();
image.src = './../images/cyberpunk.png';

image.addEventListener('load', (e)=>{
    let aspectRatio = image.naturalWidth / image.naturalHeight;
    let height = 500;
    canvas.width = height * aspectRatio;
    canvas.height = height;
    c.drawImage(image, 0, 0, canvas.width, canvas.height);

    let particle = class{
        constructor(){
            this.x = Math.random() * canvas.width;
            this.y = 0;
            this.size = Math.random() * 1.5 + 1;
            this.speed = 0;
            this.velocity = Math.random() * 3.5;
        }
        draw(){
            c.fillStyle = 'white';
            c.beginPath();
            c.arc(this.x, this.y, this.size, 0, Math.PI * 2)
            c.fill();
        }
        update(){
            this.y += this.velocity;
            if(this.y + (this.size / 2) >= canvas.height){
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
            this.draw();
        }
    }

    let particles = new Array();

    let init = function(){
        particles = [];
        for(let i = 0; i < 3000; i++){
            particles.push(new particle);
        }
    }

    init();

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.globalAlpha = 1;
            c.globalAlpha = 0.5;
            c.drawImage(image, 0, 0, canvas.width, canvas.height);
            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
});</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvvaas1"></canvas>

<script>
let canvas = document.getElementById('canvvvaas1');
let c = canvas.getContext('2d');

let image = new Image();
image.src = './../images/cyberpunk.png';

image.addEventListener('load', (e)=>{
    let aspectRatio = image.naturalWidth / image.naturalHeight;
    let height = 500;
    canvas.width = height * aspectRatio;
    canvas.height = height;
    c.drawImage(image, 0, 0, canvas.width, canvas.height);

    let particle = class{
        constructor(){
            this.x = Math.random() * canvas.width;
            this.y = 0;
            this.size = Math.random() * 1.5 + 1;
            this.speed = 0;
            this.velocity = Math.random() * 3.5;
        }
        draw(){
            c.fillStyle = 'white';
            c.beginPath();
            c.arc(this.x, this.y, this.size, 0, Math.PI * 2)
            c.fill();
        }
        update(){
            this.y += this.velocity;
            if(this.y + (this.size / 2) >= canvas.height){
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
            this.draw();
        }
    }

    let particles = new Array();

    let init = function(){
        particles = [];
        for(let i = 0; i < 3000; i++){
            particles.push(new particle);
        }
    }

    init();

    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.globalAlpha = 1;
            c.globalAlpha = 0.5;
            c.drawImage(image, 0, 0, canvas.width, canvas.height);
            particles.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
});
</script>

<p>I think the code above is fairly simple, there isn't much to explain, what we have to
do now is create an array, from which we will be able to select an (x, y) coordinate and
get the brightness of the selected pixel, if we can do that then it will be easy to
use the value we get to edit the speed of the particles.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvvvaas2');
let c = canvas.getContext('2d');

let image = new Image();
image.src = './../images/cyberpunk.png';

image.addEventListener('load', (e)=>{
    let aspectRatio = image.naturalWidth / image.naturalHeight;
    let height = 500;
    canvas.width = image.naturalWidth;
    canvas.height = image.naturalHeight;
    c.drawImage(image, 0, 0, canvas.width, canvas.height);

    let calculateRelativeBrightness = function(red, green, blue){
        return Math.sqrt(
            (red * red) * 0.299 + 
            (green * green) * 0.587 + 
            (blue * blue) * 0.114) / 100;
    }

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;

    let mappedImage = [];

    for(let y = 0; y < canvas.height; y++){
        let row = [];
        for(let x = 0; x < canvas.width; x++){
            let red = data[(x + y * canvas.width) * 4];
            let green = data[(x + y * canvas.width) * 4 + 1];
            let blue = data[(x + y * canvas.width) * 4 + 2];
            let brightness = calculateRelativeBrightness(red, green, blue);
            let clr = (red + green + blue) / 3;
            let cell = [brightness, clr];
            row.push(cell);
        }
        mappedImage.push(row);
    }

    let particle = class{
        constructor(){
            this.x = Math.random() * canvas.width;
            this.y = 0;
            this.size = Math.random() * 1.5 + 1;
            this.speed = 0;
            this.velocity = Math.random() * 0.5;
            this.position = {
                x: Math.floor(this.x),
                y: Math.floor(this.y)
            }
            this.cl;
        }
        draw(){
            c.fillStyle = `rgb(${this.cl}, ${this.cl}, ${this.cl})`;
            c.beginPath();
            c.arc(this.x, this.y, this.size, 0, Math.PI * 2)
            c.fill();
        }
        update(){
            this.position = {
                x: Math.floor(this.x),
                y: Math.floor(this.y)
            }

            if(this.position.y > canvas.height - 1){
                this.position.y = canvas.height - 1;
            }

            this.speed = mappedImage[this.position.y][this.position.x][0];
            let movement = (3 - this.speed) + this.velocity;
            this.cl = mappedImage[this.position.y][this.position.x][1];

            if(mappedImage[this.position.y][this.position.x][1] == 0){
                this.cl = '20'; 
            }

            this.y += movement;

            this.draw();
        }
    }

    let particles = new Array();

    let init = function(){
        particles = [];
        for(let i = 0; i < 6000; i++){
            particles.push(new particle);
        }
    }

    init();

    
    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.fillStyle = 'black';
            c.globalAlpha = 1;
            c.globalAlpha = 0.5;
            c.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle, i)=>{
                if(particle.y > canvas.height){
                    particles.splice(i, 1);
                };
            })
            particles.forEach((particle)=>{
                particle.update();
            });
            if(particles.length == 0){
                init();
            }
        }
        requestAnimationFrame(animate);
    }

    animate();
});</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvvaas2"></canvas>

<script>
if(true){
let canvas = document.getElementById('canvvvaas2');
let c = canvas.getContext('2d');

let image = new Image();
image.src = './../images/cyberpunk.png';

image.addEventListener('load', (e)=>{
    let aspectRatio = image.naturalWidth / image.naturalHeight;
    let height = 500;
    canvas.width = image.naturalWidth;
    canvas.height = image.naturalHeight;
    c.drawImage(image, 0, 0, canvas.width, canvas.height);

    let calculateRelativeBrightness = function(red, green, blue){
        return Math.sqrt(
            (red * red) * 0.299 + 
            (green * green) * 0.587 + 
            (blue * blue) * 0.114) / 100;
    }

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;

    let mappedImage = [];

    for(let y = 0; y < canvas.height; y++){
        let row = [];
        for(let x = 0; x < canvas.width; x++){
            let red = data[(x + y * canvas.width) * 4];
            let green = data[(x + y * canvas.width) * 4 + 1];
            let blue = data[(x + y * canvas.width) * 4 + 2];
            let brightness = calculateRelativeBrightness(red, green, blue);
            let clr = (red + green + blue) / 3;
            let cell = [brightness, clr];
            row.push(cell);
        }
        mappedImage.push(row);
    }

    let particle = class{
        constructor(){
            this.x = Math.random() * canvas.width;
            this.y = 0;
            this.size = Math.random() * 1.5 + 1;
            this.speed = 0;
            this.velocity = Math.random() * 0.5;
            this.position = {
                x: Math.floor(this.x),
                y: Math.floor(this.y)
            }
            this.cl;
        }
        draw(){
            c.fillStyle = `rgb(${this.cl}, ${this.cl}, ${this.cl})`;
            c.beginPath();
            c.arc(this.x, this.y, this.size, 0, Math.PI * 2)
            c.fill();
        }
        update(){
            this.position = {
                x: Math.floor(this.x),
                y: Math.floor(this.y)
            }

            if(this.position.y > canvas.height - 1){
                this.position.y = canvas.height - 1;
            }

            this.speed = mappedImage[this.position.y][this.position.x][0];
            let movement = (3 - this.speed) + this.velocity;
            this.cl = mappedImage[this.position.y][this.position.x][1];

            if(mappedImage[this.position.y][this.position.x][1] == 0){
                this.cl = '20'; 
            }

            this.y += movement;

            this.draw();
        }
    }

    let particles = new Array();

    let init = function(){
        particles = [];
        for(let i = 0; i < 6000; i++){
            particles.push(new particle);
        }
    }

    init();

    
    function isScrolledIntoView(el) {
        var rect = el.getBoundingClientRect();
        var elemTop = rect.top;
        var elemBottom = rect.bottom;
        var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.fillStyle = 'black';
            c.globalAlpha = 1;
            c.globalAlpha = 0.5;
            c.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle, i)=>{
                if(particle.y > canvas.height){
                    particles.splice(i, 1);
                };
            })
            particles.forEach((particle)=>{
                particle.update();
            });
            if(particles.length == 0){
                init();
            }
        }
        requestAnimationFrame(animate);
    }

    animate();
});
}
</script>

<p>So, first thing I did was create a mappedImage array, there I wanted to
store all the pixels of the image, in a way so that I can easily access them and
get their brightness value and grayscale color, to do that I used
for loops to loop through the pixels, I made a loop that will be repeated as many times
as the height of the canvas, and inside that loop I created a row array, then
I made another loop inside this loop which loops as many times as
the width of the canvas, and in this loop I use the current x and y values
to find the red, green and blue values of the pixel of that specific
(x, y) position, calculate it;s brightness and grayscale color and push it in the
row array. To find the pixel of specific (x, y) coordinates inside the
imageData.data array I used the
formula I spoke about before earlier this page, which is (x + y * canvas.width) * 4, this
will always give you the red value of the pixel on the (x, y) coordinates you give it. After
the each row has been filled with values of the pixels contained inside it the row
is pushed into the mappedImage, so at the end, to access those values you can simple
write mappedImage[y][x][num], the last array contains the brightness and grayscale color,
it doesn't have to be an array, you could make it be an object as well,
but it's easier to just put a number and get the value, so the first item of the array
is brightness and the second is the color. 
</p>

<p>So, the next thing I did was create this.position property in the particle constructor,
since velocity can be a float number, this.x and this.y of the particle will not always be real numbers,
so, in such cases using float numbers in the mappedImage array would throw an error, to fix this
I keep this.x and this.y stored in this.position, but I floor the numbers, and use
those values in mappedImage instead. The speed is set to be equal to the brightness,
which at max is around 3, then I make a movement variable which is set to be (3 - this.speed) + this.velocity, that's because,
I want the particles to move slower on bright areas, and I achieve this by doing 3 - this.speed, then I
add this.velocity only so that the particles keep some randomness in their movement, and
so they can't stop moving if an array has max brightness. I also created this.cl property which is
used to fill the particles and is set to be the grayscale color taked from mappedImage, if
it equals to 0 I make sure it is set to 20, so that no particles are completely black.
</p>

<p>Lastly, I made it so that when a particle leaves the canvas it gets removed,
and made it so that when the array has been cleared init function is ran again so another set
of particles appear.
</header>
</article>

<hr>

<article id="twentyeight">
<header><h1>Pixels that move when hovered over</h1></header>
<p>In this section I will try and build one more canvas project, one I consider to be a little bit more hard to gasp than the rest,
and that's because we are gonna use both pixel manupulation and other cool math tricks to achieve a really cool effect, 
that will make particles, forming text, moving away from your mouse, with physics being applied to them so that it doesn't look weird.
The project doesn't need to necessarily be made with text, you can actually add that effect to any kind of shape you like,
and you could also try other cool stuff with this, such as applying color to the particles and other stuff.
</p>

<p>To begin, the first thing we are gonna need to do, is make a constructor that will create particles, and make it so
those particles move away from the cursor and return to their original position when cursor is away from them. It may seem
simple but it will be a little harder to do, since I want to make it so that those particles move faster the closer
they are to the mouse, and decrease their velocity as they move away from the mouse. This effect of course should also work
for touch screens, but that isn't an issue, except if you want multi-touches to be supported, then this could get a little harder.
</p>

<p>Since I want my projects to be as cool as possible, I will do try to add multi-touches to the project, so that
particles don't only react to one touch, but all touches that are happening on the screen. Let's get started then,
by creating the simple structure of the code.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass1');
let c = canvas.getContext('2d');
canvas.style.backgroundColor = 'black';

canvas.width = 500;
canvas.height = 300;

let distanceRadius = 50;

let mouse = {
    x: undefined,
    y: undefined
}

let touches = new Array();

window.addEventListener('mousemove', (e)=>{
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    mouse = {
        x: e.clientX - x,
        y: e.clientY - y
    }
});

function setTouches(e){
    touches = [];
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    for(let i = 0; i < e.touches.length; i++){
        touches.push({
            x: e.touches[i].clientX - x,
            y: e.touches[i].clientY - y,
        });
    }
}

function resetTouches(e){
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

window.addEventListener('touchstart', setTouches);
window.addEventListener('touchmove', setTouches);
window.addEventListener('touchend', resetTouches);
window.addEventListener('touchcancel', resetTouches);

let particlesArray = [];

let particleConstructor = class{
    constructor(x, y, size, color){
        this.x = x;
        this.y = y;
        this.originalX = this.x;
        this.originalY = this.y;
        this.size = size;
        this.color = color;
    }
    draw(){
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        c.fill();
    }
}

let init = function(){
    particlesArray = [];
    for(let i = 0; i < 500; i ++){
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        let size = 3;
        let color = 'white';
        particlesArray.push(new particleConstructor(x, y, size, color));
    }
}

init();

function isScrolledIntoView(el) {
    let rect = el.getBoundingClientRect();
    let elemTop = rect.top;
    let elemBottom = rect.bottom;
    let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particlesArray.forEach((particle)=>{
            particle.draw();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="ccaannvvaass1"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass1');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        canvas.width = 500;
        canvas.height = 300;

        let distanceRadius = 50;

        let mouse = {
            x: undefined,
            y: undefined
        }

        let touches = new Array();

        window.addEventListener('mousemove', (e)=>{
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            mouse = {
                x: e.clientX - x,
                y: e.clientY - y
            }
        });

        function setTouches(e){
            touches = [];
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            for(let i = 0; i < e.touches.length; i++){
                touches.push({
                    x: e.touches[i].clientX - x,
                    y: e.touches[i].clientY - y,
                });
            }
        }
    
        function resetTouches(e){
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            touches.forEach((touch, i)=>{
                if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
                    touches.splice(i, 1);
                }     
            });
        }

        window.addEventListener('touchstart', setTouches);
        window.addEventListener('touchmove', setTouches);
        window.addEventListener('touchend', resetTouches);
        window.addEventListener('touchcancel', resetTouches);

        let particlesArray = [];

        let particleConstructor = class{
            constructor(x, y, size, color){
                this.x = x;
                this.y = y;
                this.originalX = this.x;
                this.originalY = this.y;
                this.size = size;
                this.color = color;
            }
            draw(){
                c.fillStyle = this.color;
                c.beginPath();
                c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                c.fill();
            }
        }

        let init = function(){
            particlesArray = [];
            for(let i = 0; i < 500; i ++){
                let x = Math.random() * canvas.width;
                let y = Math.random() * canvas.height;
                let size = 3;
                let color = 'white';
                particlesArray.push(new particleConstructor(x, y, size, color));
            }
        }

        init();

        function isScrolledIntoView(el) {
            let rect = el.getBoundingClientRect();
            let elemTop = rect.top;
            let elemBottom = rect.bottom;
            let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach((particle)=>{
                    particle.draw();
                });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>Alright, so, I added a few nice things to the code that may be helpful in the future, I created an object which keeps track of
the mouse position of the client, and also an array which is supposed keep track of touches if the client is using a touchscreen.
So, I don't really know if my way of keeping track of touches is the best, it's something I had came up with in the past when
I had tried to create two joysticks and I wanted to make them work seperately, basically, I needed a way to keep track of which touch is which,
the joysticks actually needed some more complexity in the code, now I only really care about which touch is which when a touch ends, I could
had actually just made it so when a touch ends the whole touches array is reseted, however, if you were double touching for example,
and took off one of your fingers, then that would clear the touches array and if the other finger stayed still without moving
then the array wouldn't be updated, that's why I wanted to make it so I check what of the touches has ended and only remove this
specific one from the array. To do that, since I already keep track of the touches positions, all I had to really do was to
calculate the difference of the clientX of the touch that ended and the clientX of the other touches, and then see which has a smaller difference
and remove this, usually the difference is exactly 0 if it's the same touch, but that's probably because I'm using google dev tool
on my laptop now and the touch radius always stays the same, if it changes then the difference could be a little bigger.
</p>

<Style>
    .orange{
        background: lightcoral;
    }
</Style>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass2');
let c = canvas.getContext('2d');
canvas.style.backgroundColor = 'black';

canvas.width = 500;
canvas.height = 300;

let distanceRadius = 50;

let mouse = {
    x: undefined,
    y: undefined
}

let touches = new Array();

canvas.addEventListener('mousemove', (e)=>{
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    mouse = {
        x: e.clientX - x,
        y: e.clientY - y
    }
});

function setTouches(e){
    touches = [];
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    for(let i = 0; i < e.touches.length; i++){
        touches.push({
            x: e.touches[i].clientX - x,
            y: e.touches[i].clientY - y,
        });
    }
}

function resetTouches(e){
<span class="orange">     if (e.cancelable) {
        e.preventDefault();
    }</span>
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}
function resetTouches(e){

    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

canvas.addEventListener('touchstart', setTouches);
canvas.addEventListener('touchmove', setTouches);
canvas.addEventListener('touchend', resetTouches);
canvas.addEventListener('touchcancel', resetTouches);

let particlesArray = [];

let particleConstructor = class{
    constructor(x, y, size, color){
        this.x = x;
        this.y = y;
        this.originalX = this.x;
        this.originalY = this.y;
        this.size = size;
        this.color = color;
    }
    draw(){
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        c.fill();
    }
<span class="orange">    update(){
       let dx = mouse.x - this.x;
       let dy = mouse.y - this.y;
       let mouseDistance = Math.hypot(dx, dy);
       let touchesDistances = new Array();
       let minTouchDistance;
       if(touches.length > 0){
           touches.forEach((touch)=>{
               let x = touch.x - this.x;
               let y = touch.y - this.y;
               touchesDistances.push(Math.hypot(x, y));
           });
           minTouchDistance = Math.min.apply(Math, touchesDistances);
       } else {
           minTouchDistance = Number.POSITIVE_INFINITY;
       }
       if(mouseDistance < distanceRadius || minTouchDistance < distanceRadius){
           this.size = 10;
       } else {
           this.size = 3;
       }
       this.draw();
    }</span>
}

let init = function(){
    particlesArray = [];
    for(let i = 0; i < 500; i ++){
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        let size = 3;
        let color = 'white';
        particlesArray.push(new particleConstructor(x, y, size, color));
    }
}

init();

function isScrolledIntoView(el) {
    let rect = el.getBoundingClientRect();
    let elemTop = rect.top;
    let elemBottom = rect.bottom;
    let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particlesArray.forEach((particle)=>{
<span class="orange">            particle.update();</span>
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="ccaannvvaass2"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass2');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        canvas.width = 500;
        canvas.height = 300;

        let distanceRadius = 50;

        let mouse = {
            x: undefined,
            y: undefined
        }

        let touches = new Array();

        canvas.addEventListener('mousemove', (e)=>{
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            mouse = {
                x: e.clientX - x,
                y: e.clientY - y
            }
        });

        function setTouches(e){
            touches = [];
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            for(let i = 0; i < e.touches.length; i++){
                touches.push({
                    x: e.touches[i].clientX - x,
                    y: e.touches[i].clientY - y,
                });
            }
        }
    
        function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

        canvas.addEventListener('touchstart', setTouches);
        canvas.addEventListener('touchmove', setTouches);
        canvas.addEventListener('touchend', resetTouches);
        canvas.addEventListener('touchcancel', resetTouches);

        let particlesArray = [];

        let particleConstructor = class{
            constructor(x, y, size, color){
                this.x = x;
                this.y = y;
                this.originalX = this.x;
                this.originalY = this.y;
                this.size = size;
                this.color = color;
            }
            draw(){
                c.fillStyle = this.color;
                c.beginPath();
                c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                c.fill();
            }
            update(){
               let dx = mouse.x - this.x;
               let dy = mouse.y - this.y;
               let mouseDistance = Math.hypot(dx, dy);
               let touchesDistances = new Array();
               let minTouchDistance;
               if(touches.length > 0){
                   touches.forEach((touch)=>{
                       let x = touch.x - this.x;
                       let y = touch.y - this.y;
                       touchesDistances.push(Math.hypot(x, y));
                   });
                   minTouchDistance = Math.min.apply(Math, touchesDistances);
               } else {
                   minTouchDistance = Number.POSITIVE_INFINITY;
               }
               if(mouseDistance < distanceRadius || minTouchDistance < distanceRadius){
                   this.size = 10;
               } else {
                   this.size = 3;
               }
               this.draw();
            }
        }

        let init = function(){
            particlesArray = [];
            for(let i = 0; i < 500; i ++){
                let x = Math.random() * canvas.width;
                let y = Math.random() * canvas.height;
                let size = 3;
                let color = 'white';
                particlesArray.push(new particleConstructor(x, y, size, color));
            }
        }

        init();

        function isScrolledIntoView(el) {
            let rect = el.getBoundingClientRect();
            let elemTop = rect.top;
            let elemBottom = rect.bottom;
            let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>Next thing I needed was an update method, in which I will
be doing all the calculations and perform all the needed changes to the particles
before drawing them. I calculated the distance from the mouse and the particles, and also
did the same for the touches, however, I only really care about the touch that is closer
to the particle, and so I made it so that every time a particle updates it only keeps
track of the distance it has between the touch closer to it, as it moves away from that touch
if it gets closer to another touch then the touch it runs away from will change, to the new touch being closer.
I made it so that the particles size change when mouse or touch is near the particles, just so that
I can test wether or not the code I have written so far works. After this, I realised there was a bug,
basically when using a touch screen if you click on the screen the mousemove event can trigger, and that
could create problems, because of that I used e.preventDefault() method, but added this method inside
an if else statement that first checks if e.cancelable is true, since when scrolling
the browser usually doesn't allow the preventDefault method to run and it throws an error, or that's
what I think is happening at least.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass3');
let c = canvas.getContext('2d');
canvas.style.backgroundColor = 'black';

canvas.width = 500;
canvas.height = 300;

let distanceRadius = 50;

let mouse = {
    x: undefined,
    y: undefined
}

let touches = new Array();

canvas.addEventListener('mousemove', (e)=>{
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    mouse = {
        x: e.clientX - x,
        y: e.clientY - y
    }
});

function setTouches(e){
    touches = [];
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    for(let i = 0; i < e.touches.length; i++){
        touches.push({
            x: e.touches[i].clientX - x,
            y: e.touches[i].clientY - y,
        });
    }
}

function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

canvas.addEventListener('touchstart', setTouches);
canvas.addEventListener('touchmove', setTouches);
canvas.addEventListener('touchend', resetTouches);
canvas.addEventListener('touchcancel', resetTouches);

let particlesArray = [];

let particleConstructor = class{
    constructor(x, y, size, color){
        this.x = x;
        this.y = y;
        this.originalX = this.x;
        this.originalY = this.y;
        this.size = size;
        this.color = color;
<span class="orange">        this.velocity = (Math.random() * 30) + 1;</span>
    }
    draw(){
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        c.fill();
    }
    update(){
       let dx = mouse.x - this.x;
       let dy = mouse.y - this.y;
       let mouseDistance = Math.hypot(dx, dy);
<span class="orange">       let mouseDifference = {
           dx: dx,
           dy: dy
       }</span>
       let touchesDistances = new Array();
       let minTouchDistance;
<span class="orange">       let minTouchDifference;</span>
       if(touches.length > 0){
           touches.forEach((touch)=>{
               let x = touch.x - this.x;
               let y = touch.y - this.y;
               touchesDistances.push(Math.hypot(x, y));
           });
           minTouchDistance = Math.min.apply(Math, touchesDistances);
<span class="orange">           let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
           minTouchDifference = {
               dx: touches[minTouchIndex].x - this.x, 
               dy: touches[minTouchIndex].y - this.y
           }</span>
       } <span class="orange">else {
            minTouchDistance = Number.NEGATIVE_INFINITY;
        }

        let returnParticles = ()=>{
        if(this.x != this.originalX){
            let dx = this.x - this.originalX;
                 this.x -= dx / 20;
             }
             if(this.y != this.originalY){
                 let dy = this.y - this.originalY;
                 this.y -= dy / 20;
             }
         }

        if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
             let moveParticle = (distance, difference)=>{
                 let angle = Math.atan2(difference.dy, difference.dx);
                 let forceDirectionX = Math.cos(angle);
                 let forceDirectionY = Math.sin(angle);
                 let maxDistance = distanceRadius;
                 let force = (maxDistance - distance) / maxDistance;
                 let directionX = forceDirectionX * force * this.velocity;
                 let directionY = forceDirectionY * force * this.velocity;
                 this.x -= directionX;
                 this.y -= directionY;
             }
             if(mouseDistance < distanceRadius){
                 moveParticle(mouseDistance, mouseDifference);
             }
             if(Math.abs(minTouchDistance) < distanceRadius){
                 moveParticle(minTouchDistance, minTouchDifference);
             }
        } else if(mouseDistance > distanceRadius + 5){
             returnParticles();
        } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
             returnParticles();
        }</span>

       this.draw();
    }
}

let init = function(){
    particlesArray = [];
    for(let i = 0; i < 500; i ++){
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        let size = 3;
        let color = 'white';
        particlesArray.push(new particleConstructor(x, y, size, color));
    }
}

init();

function isScrolledIntoView(el) {
    let rect = el.getBoundingClientRect();
    let elemTop = rect.top;
    let elemBottom = rect.bottom;
    let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particlesArray.forEach((particle)=>{
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="ccaannvvaass3"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass3');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        canvas.width = 500;
        canvas.height = 300;

        let distanceRadius = 50;

        let mouse = {
            x: undefined,
            y: undefined
        }

        let touches = new Array();

        window.addEventListener('mousemove', (e)=>{
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            mouse = {
                x: e.clientX - x,
                y: e.clientY - y
            }
        });

        function setTouches(e){
            touches = [];
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            for(let i = 0; i < e.touches.length; i++){
                touches.push({
                    x: e.touches[i].clientX - x,
                    y: e.touches[i].clientY - y,
                });
            }
        }
    
        function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

        canvas.addEventListener('touchstart', setTouches);
        canvas.addEventListener('touchmove', setTouches);
        canvas.addEventListener('touchend', resetTouches);
        canvas.addEventListener('touchcancel', resetTouches);

        let particlesArray = [];

        let particleConstructor = class{
            constructor(x, y, size, color){
                this.x = x;
                this.y = y;
                this.originalX = this.x;
                this.originalY = this.y;
                this.size = size;
                this.color = color;
                this.velocity = (Math.random() * 30) + 1;
            }
            draw(){
                c.fillStyle = this.color;
                c.beginPath();
                c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                c.fill();
            }
            update(){
               let dx = mouse.x - this.x;
               let dy = mouse.y - this.y;
               let mouseDistance = Math.hypot(dx, dy);
               let mouseDifference = {
                   dx: dx,
                   dy: dy
               }
               let touchesDistances = new Array();
               let minTouchDistance;
               let minTouchDifference;
               if(touches.length > 0){
                   touches.forEach((touch)=>{
                       let x = touch.x - this.x;
                       let y = touch.y - this.y;
                       touchesDistances.push(Math.hypot(x, y));
                   });
                   minTouchDistance = Math.min.apply(Math, touchesDistances);
                   let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
                   minTouchDifference = {
                       dx: touches[minTouchIndex].x - this.x, 
                       dy: touches[minTouchIndex].y - this.y
                   }
               } else {
                   minTouchDistance = Number.NEGATIVE_INFINITY;
               }

               let returnParticles = ()=>{
               if(this.x != this.originalX){
                   let dx = this.x - this.originalX;
                        this.x -= dx / 20;
                    }
                    if(this.y != this.originalY){
                        let dy = this.y - this.originalY;
                        this.y -= dy / 20;
                    }
                }

               if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                    let moveParticle = (distance, difference)=>{
                        let angle = Math.atan2(difference.dy, difference.dx);
                        let forceDirectionX = Math.cos(angle);
                        let forceDirectionY = Math.sin(angle);
                        let maxDistance = distanceRadius;
                        let force = (maxDistance - distance) / maxDistance;
                        let directionX = forceDirectionX * force * this.velocity;
                        let directionY = forceDirectionY * force * this.velocity;
                        this.x -= directionX;
                        this.y -= directionY;
                    }
                    if(mouseDistance < distanceRadius){
                        moveParticle(mouseDistance, mouseDifference);
                    }
                    if(Math.abs(minTouchDistance) < distanceRadius){
                        moveParticle(minTouchDistance, minTouchDifference);
                    }
               } else if(mouseDistance > distanceRadius + 5){
                    returnParticles();
               } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                    returnParticles();
               }

               this.draw();
            }
        }

        let init = function(){
            particlesArray = [];
            for(let i = 0; i < 500; i ++){
                let x = Math.random() * canvas.width;
                let y = Math.random() * canvas.height;
                let size = 3;
                let color = 'white';
                particlesArray.push(new particleConstructor(x, y, size, color));
            }
        }

        init();

        function isScrolledIntoView(el) {
            let rect = el.getBoundingClientRect();
            let elemTop = rect.top;
            let elemBottom = rect.bottom;
            let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>So, I think this part of the code is probably the hardest to understand in this project,
but I will try to explain it as good as I can. Let's focus on the calculations made inside moveParticle function
for now, and understand what they do. Firstly, I got the angle of the given vector, by using the
Math.atan2(dy, dx) method, this returns the angle of the vector in radians, by using this angle,
I then created forceDirectionX and forceDirectionY, I have actually talked about this in previous projects too,
but by using Math.cos() and Math.sin() you can create circular motions, they return numbers between -1 and 1, so,
if we use the angle we calculated inside Math.cos() and Math.sin(), the pair of x and y valocities we get, if used
together will make the particle move on the angle of the vector, so, by simple
adding forceDirectionX and forceDirectionY to our x and y properties we would make the particles move towards
the mouse. The thing is, we do not want the particles to move towards the mouse, we want them to move away from the mouse,
so instead of adding those forceDirection properties to our x and y properties I substracted them.
</p>

<p>So, with this I have explained half of the calculations made in the code, you could actually leave it just with the forceDirection properties
alone and it would work, but I wanted to add some physics to the particles, I wanted to make it so the further away the particles
are from the mouse the slower they get. To do that, I created the force variable, which is
(maxDistance - distance) / maxDistance, you really shouldn't overthing this one, let me give you two
examples to understand it, if the distance of the particle and the mouse is 0, then this calculation will return 1,
if however the distance is equal to maxDistance, it will return 0, anything in between will return values between 0 and 1.
Force basically will be used to tell us what percent of the force should the particle move with,
if it's 1, meaning that the distance is 0, then it will move with full force, if however the distance is half of the max distance, then
force will take the value of 0.5, and so we will use that value to make the particle
move with 50% of it's full force. That's exactly what I do after, when I create the
directionX and directionY variables, I also multiple with this.velocity, the reason is because
I want each particle to move at a slightly different speed than the rest, this is only so
the effect look a little more cool.
</p>

<p>I added this code I just explained inside a function, so that I can use it for both mouse and touches, I also made some other
changes to the code that were needed for this to work, for example, I needed to keep track of the touch and mouse dx and dy so that
I can calculate their angle later, so I have marked everything new with lightcoral color for you to see.
</p>

<p>Last thing I did was make it so that the particle return to their original position when they are out of the mouse's distance radius.
I actually wanted to add some physics to this movement as well, so I made them move slower as they
get closer to their original position. You shouldn't overthing the calculation I made there either,
it's actually pretty simple, let's say the particle has been moved to the right 100 pixels from it's original position,
dx will be 100, so dx / 10 will be 10, which means that this.x -= dx / 10 will move the particle 10 pixels to the left,
after that, dx will change to 90, since the particle will have moved closer to it's original position, 
so dx / 10 will equal 9, and so this time the particle will move to the left only 9 pixels,
this will continue again and again till dx becomes 0. If the particles had been moved to the left instead,
then dx would be a negative number, so this.x -= dx / 10 would return a positive number, thus,
moving the particle to the right. I do the exact same thing for this.y. 
</p>

<p>Let's now try and make it so that instead of adding particles on the screen randomly we actually
fill shapes with those particles, such as images, text, or anything else you want:
</p>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass4');
let c = canvas.getContext('2d');
canvas.style.backgroundColor = 'black';

<span class="orange">let image = new Image();
image.src = './../images/goldensun.jpg';

image.addEventListener('load', (e)=>{</span>
    canvas.width = 500;
    canvas.height = 400;

<span class="orange">    let aspectRatio = image.naturalWidth / image.naturalHeight;
    let difference = canvas.width - (image.naturalWidth);
    let height = 130;
    let width = Math.floor(height * aspectRatio);
    c.drawImage(image, 0, 0, width, height);

    let imageData = c.getImageData(0, 0, width, height);
    let data = imageData.data;</span>

    let distanceRadius = <span class="orange">30</span>;

    let mouse = {
        x: undefined,
        y: undefined
    }

    let touches = new Array();

    window.addEventListener('mousemove', (e)=>{
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        mouse = {
            x: e.clientX - x,
            y: e.clientY - y
        }
    });

    function setTouches(e){
        touches = [];
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        for(let i = 0; i < e.touches.length; i++){
            touches.push({
                x: e.touches[i].clientX - x,
                y: e.touches[i].clientY - y,
            });
        }
    }

    function resetTouches(e){
        if (e.cancelable) {
            e.preventDefault();
        }
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        touches.forEach((touch, i)=>{
            if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
                touches.splice(i, 1);
            }     
        });
    }

    canvas.addEventListener('touchstart', setTouches);
    canvas.addEventListener('touchmove', setTouches);
    canvas.addEventListener('touchend', resetTouches);
    canvas.addEventListener('touchcancel', resetTouches);

    let particlesArray = [];

    let particleConstructor = class{
        constructor(x, y, size, color){
            this.x = x;
            this.y = y;
            this.originalX = this.x;
            this.originalY = this.y;
            this.size = size;
            this.color = color;
            this.velocity = (Math.random() * 30) + 1;
        }
        draw(){
            c.fillStyle = this.color;
            c.beginPath();
<span class="orange">            c.fillRect(this.x, this.y, this.size, this.size);</span>
            c.fill();
        }
        update(){
           let dx = mouse.x - this.x;
           let dy = mouse.y - this.y;
           let mouseDistance = Math.hypot(dx, dy);
           let mouseDifference = {
               dx: dx,
               dy: dy
           }
           let touchesDistances = new Array();
           let minTouchDistance;
           let minTouchDifference;
           if(touches.length > 0){
               touches.forEach((touch)=>{
                   let x = touch.x - this.x;
                   let y = touch.y - this.y;
                   touchesDistances.push(Math.hypot(x, y));
               });
               minTouchDistance = Math.min.apply(Math, touchesDistances);
               let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
               minTouchDifference = {
                   dx: touches[minTouchIndex].x - this.x, 
                   dy: touches[minTouchIndex].y - this.y
               }
           } else {
                minTouchDistance = Number.NEGATIVE_INFINITY;
            }

            let returnParticles = ()=>{
            if(this.x != this.originalX){
                let dx = this.x - this.originalX;
                     this.x -= dx / 20;
                 }
                 if(this.y != this.originalY){
                     let dy = this.y - this.originalY;
                     this.y -= dy / 20;
                 }
             }

            if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                 let moveParticle = (distance, difference)=>{
                     let angle = Math.atan2(difference.dy, difference.dx);
                     let forceDirectionX = Math.cos(angle);
                     let forceDirectionY = Math.sin(angle);
                     let maxDistance = distanceRadius;
                     let force = (maxDistance - distance) / maxDistance;
                     let directionX = forceDirectionX * force * this.velocity;
                     let directionY = forceDirectionY * force * this.velocity;
                     this.x -= directionX;
                     this.y -= directionY;
                 }
                 if(mouseDistance < distanceRadius){
                     moveParticle(mouseDistance, mouseDifference);
                 }
                 if(Math.abs(minTouchDistance) < distanceRadius){
                     moveParticle(minTouchDistance, minTouchDifference);
                 }
            } else if(mouseDistance > distanceRadius + 5){
                 returnParticles();
            } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                 returnParticles();
            }
           this.draw();
        }
    }

    let init = function(){
        particlesArray = [];
<span class="orange">        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                if(data[(x + y * width) * 4 + 3] == 255){
                    let red = data[(x + y * width) * 4];
                    let green = data[(x + y * width) * 4 + 1];
                    let blue = data[(x + y * width) * 4 + 2];
                    let color = `rgb(${red}, ${green}, ${blue})`;
                    let offset = {x: 15, y: 0};
                    let scale = 3;
                    particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, scale, color));
                }
            }
        }</span>
    }

    init();

    function isScrolledIntoView(el) {
        let rect = el.getBoundingClientRect();
        let elemTop = rect.top;
        let elemBottom = rect.bottom;
        let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            particlesArray.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();
});</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="ccaannvvaass4"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass4');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        let image = new Image();
        image.src = './../images/goldensun.jpg';

        image.addEventListener('load', (e)=>{
            canvas.width = 500;
            canvas.height = 400;

            let aspectRatio = image.naturalWidth / image.naturalHeight;
            let difference = canvas.width - (image.naturalWidth);
            let height = 130;
            let width = Math.floor(height * aspectRatio);
            c.drawImage(image, 0, 0, width, height);

            let imageData = c.getImageData(0, 0, width, height);
            let data = imageData.data;

            let distanceRadius = 30;

            let mouse = {
                x: undefined,
                y: undefined
            }

            let touches = new Array();

            window.addEventListener('mousemove', (e)=>{
                let box = canvas.getBoundingClientRect();
                let x = box.left;
                let y = box.top;
                mouse = {
                    x: e.clientX - x,
                    y: e.clientY - y
                }
            });

            function setTouches(e){
                touches = [];
                let box = canvas.getBoundingClientRect();
                let x = box.left;
                let y = box.top;
                for(let i = 0; i < e.touches.length; i++){
                    touches.push({
                        x: e.touches[i].clientX - x,
                        y: e.touches[i].clientY - y,
                    });
                }
            }
    
            function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

            canvas.addEventListener('touchstart', setTouches);
            canvas.addEventListener('touchmove', setTouches);
            canvas.addEventListener('touchend', resetTouches);
            canvas.addEventListener('touchcancel', resetTouches);

            let particlesArray = [];

            let particleConstructor = class{
                constructor(x, y, size, color){
                    this.x = x;
                    this.y = y;
                    this.originalX = this.x;
                    this.originalY = this.y;
                    this.size = size;
                    this.color = color;
                    this.velocity = (Math.random() * 30) + 1;
                }
                draw(){
                    c.fillStyle = this.color;
                    c.beginPath();
                    c.fillRect(this.x, this.y, this.size, this.size);
                    c.fill();
                }
                update(){
                   let dx = mouse.x - this.x;
                   let dy = mouse.y - this.y;
                   let mouseDistance = Math.hypot(dx, dy);
                   let mouseDifference = {
                       dx: dx,
                       dy: dy
                   }
                   let touchesDistances = new Array();
                   let minTouchDistance;
                   let minTouchDifference;
                   if(touches.length > 0){
                       touches.forEach((touch)=>{
                           let x = touch.x - this.x;
                           let y = touch.y - this.y;
                           touchesDistances.push(Math.hypot(x, y));
                       });
                       minTouchDistance = Math.min.apply(Math, touchesDistances);
                       let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
                       minTouchDifference = {
                           dx: touches[minTouchIndex].x - this.x, 
                           dy: touches[minTouchIndex].y - this.y
                       }
                   } else {
                   minTouchDistance = Number.NEGATIVE_INFINITY;
               }

               let returnParticles = ()=>{
               if(this.x != this.originalX){
                   let dx = this.x - this.originalX;
                        this.x -= dx / 20;
                    }
                    if(this.y != this.originalY){
                        let dy = this.y - this.originalY;
                        this.y -= dy / 20;
                    }
                }

               if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                    let moveParticle = (distance, difference)=>{
                        let angle = Math.atan2(difference.dy, difference.dx);
                        let forceDirectionX = Math.cos(angle);
                        let forceDirectionY = Math.sin(angle);
                        let maxDistance = distanceRadius;
                        let force = (maxDistance - distance) / maxDistance;
                        let directionX = forceDirectionX * force * this.velocity;
                        let directionY = forceDirectionY * force * this.velocity;
                        this.x -= directionX;
                        this.y -= directionY;
                    }
                    if(mouseDistance < distanceRadius){
                        moveParticle(mouseDistance, mouseDifference);
                    }
                    if(Math.abs(minTouchDistance) < distanceRadius){
                        moveParticle(minTouchDistance, minTouchDifference);
                    }
               } else if(mouseDistance > distanceRadius + 5){
                    returnParticles();
               } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                    returnParticles();
               }
                   this.draw();
                }
            }

            let init = function(){
                particlesArray = [];
                for(let y = 0; y < height; y++){
                    for(let x = 0; x < width; x++){
                        if(data[(x + y * width) * 4 + 3] == 255){
                            let red = data[(x + y * width) * 4];
                            let green = data[(x + y * width) * 4 + 1];
                            let blue = data[(x + y * width) * 4 + 2];
                            let color = `rgb(${red}, ${green}, ${blue})`;
                            let offset = {x: 15, y: 0};
                            let scale = 3;
                            particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, scale, color));
                        }
                    }
                }
            }

            init();

            function isScrolledIntoView(el) {
                let rect = el.getBoundingClientRect();
                let elemTop = rect.top;
                let elemBottom = rect.bottom;
                let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                return isVisible;
            }

            let animate = function(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    particlesArray.forEach((particle)=>{
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();
        });
    }
</script>

<p>So, first of all, you should try to use a small image if possible, the smaller the better, and that's because
the more space it takes on the canvas, the more particles will be created, and if a lot of particles are created then
there will be issues with the performance. After adding the wanted image, which was an image I found
online that had invisible background, I scaled it down to 130 pixels height, and also calculated the aspectRatio of the image
and used it to calculate what the width should be. After that, before I draw anything else on the canvas I
saved the imageData of the area that the image was drawn, so that I can use it later, since the
height and width variables will be useful later, I also made sure to floor the
width number, since it could be a float number and that would create problems to my code later.
After drawing the image and getting the pixel data of the image, I then was ready
to use that data while creating my particles. I made a loop, that
loops through the rows and columns of the area I drew the image before,
inside that loop I used the x and y positions in each iteration to check wether
the pixel with those coordinates inside the image data I had saved before has an opasity
equal to 255 or not. To do that I used the (x + y * width) * 4 formula, which I have explained before
earlier in this page. If this test is passed, then I get the rgb values of the pixel,
set an rbg string to use as a color, and then create a particle with those coordinates and color inside
the particlesArray. Since as I said before the image is scaled down it be small,
I wanted to scale up the particles so that the image visible at the end 
is of a greater size with particles bigger than 1 pixel each. To do that I created the scale variable.
Basically, by multiplying x and y with scale, and then setting the size of
the particle equal to the scale used, I can change the scale of the image. How does this work though?
Well, let's say our image were four particles forming a box, two particles each side, if
I ran this code, with a scale of 2, then the first particle, which would
be at coordinates (1, 1), would be created at coordinates (2, 2), and have double the
size it originally had, then, the next particle, positioned at coordinates (2, 2), would be
created at (4, 4), exactly next to the other particle, since the other would be
positioned at (2, 2) with a 2 pixels width, the same thing basically happens to all other particles too,
both horizontaly and vertically, and so the image is scaled twice as big as it originally was.
Another thing I wanted to do was make it so that I can move it around, so I created offset variable, I
can simple add an offset to x and y and the image will move, if I made the x offset 5, and the scale was 2, then the
image would move 10 pixels to the right, since 5 * 2 equals 10.
</p>

<p>In this section however I actually want to create this project with text,
and later also make it look cooler by adding lines that collect each particle.
Let's remove the image and add some text in it's place instead:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass5');
    let c = canvas.getContext('2d');
    canvas.style.backgroundColor = 'black';

<Span class="orange">    canvas.width = 800;</span>
    canvas.height = 400;

<Span class="orange">    let text = 'Karak10\'s Notes!'
    c.font = 'normal 30px Luckiest Guy';
    let measurements = c.measureText(text);
    c.fillStyle = 'white';
    c.fillText(text, 10, 50);
    let height = Math.floor(measurements.actualBoundingBoxAscent + 60);
    let width = Math.floor(measurements.width + 20);</span>

    let imageData = c.getImageData(0, 0, width, height);
    let data = imageData.data;

    let distanceRadius = 30;

    let mouse = {
        x: undefined,
        y: undefined
    }

    let touches = new Array();

    window.addEventListener('mousemove', (e)=>{
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        mouse = {
            x: e.clientX - x,
            y: e.clientY - y
        }
    });

    function setTouches(e){
        touches = [];
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        for(let i = 0; i < e.touches.length; i++){
            touches.push({
                x: e.touches[i].clientX - x,
                y: e.touches[i].clientY - y,
            });
        }
    }

    function resetTouches(e){
        if (e.cancelable) {
            e.preventDefault();
        }
        let box = canvas.getBoundingClientRect();
        let x = box.left;
        let y = box.top;
        touches.forEach((touch, i)=>{
            if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
                touches.splice(i, 1);
            }     
        });
    }

    canvas.addEventListener('touchstart', setTouches);
    canvas.addEventListener('touchmove', setTouches);
    canvas.addEventListener('touchend', resetTouches);
    canvas.addEventListener('touchcancel', resetTouches);

    let particlesArray = [];

    let particleConstructor = class{
        constructor(x, y, size, color){
            this.x = x;
            this.y = y;
            this.originalX = this.x;
            this.originalY = this.y;
            this.size = size;
            this.color = color;
            this.velocity = (Math.random() * 30) + 1;
        }
        draw(){
            c.fillStyle = this.color;
            c.beginPath();
<Span class="orange">            c.arc(this.x, this.y, this.size, 0, Math.PI * 2);</span>
            c.fill();
        }
        update(){
           let dx = mouse.x - this.x;
           let dy = mouse.y - this.y;
           let mouseDistance = Math.hypot(dx, dy);
           let mouseDifference = {
               dx: dx,
               dy: dy
           }
           let touchesDistances = new Array();
           let minTouchDistance;
           let minTouchDifference;
           if(touches.length > 0){
               touches.forEach((touch)=>{
                   let x = touch.x - this.x;
                   let y = touch.y - this.y;
                   touchesDistances.push(Math.hypot(x, y));
               });
               minTouchDistance = Math.min.apply(Math, touchesDistances);
               let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
               minTouchDifference = {
                   dx: touches[minTouchIndex].x - this.x, 
                   dy: touches[minTouchIndex].y - this.y
               }
           } else {
               minTouchDistance = Number.POSITIVE_INFINITY;
           }
           else {
               minTouchDistance = Number.NEGATIVE_INFINITY;
           }

           let returnParticles = ()=>{
           if(this.x != this.originalX){
               let dx = this.x - this.originalX;
                    this.x -= dx / 20;
                }
                if(this.y != this.originalY){
                    let dy = this.y - this.originalY;
                    this.y -= dy / 20;
                }
            }

           if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                let moveParticle = (distance, difference)=>{
                    let angle = Math.atan2(difference.dy, difference.dx);
                    let forceDirectionX = Math.cos(angle);
                    let forceDirectionY = Math.sin(angle);
                    let maxDistance = distanceRadius;
                    let force = (maxDistance - distance) / maxDistance;
                    let directionX = forceDirectionX * force * this.velocity;
                    let directionY = forceDirectionY * force * this.velocity;
                    this.x -= directionX;
                    this.y -= directionY;
                }
                if(mouseDistance < distanceRadius){
                    moveParticle(mouseDistance, mouseDifference);
                }
                if(Math.abs(minTouchDistance) < distanceRadius){
                    moveParticle(minTouchDistance, minTouchDifference);
                }
           } else if(mouseDistance > distanceRadius + 5){
                returnParticles();
           } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                returnParticles();
           }
           this.draw();
        }
    }

    let init = function(){
        particlesArray = [];
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                if(data[(x + y * width) * 4 + 3] == 255){
                    let red = data[(x + y * width) * 4];
                    let green = data[(x + y * width) * 4 + 1];
                    let blue = data[(x + y * width) * 4 + 2];
                    let color = `rgb(${red}, ${green}, ${blue})`;
<Span class="orange">                    let scale = 3;
                    let distance =  canvas.width - (20 + measurements.width) * scale;
                    let offset = {x: (distance / 2) / scale, y: 20};
                    particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, 0.5, color));</span>
                }
            }
        }
    }

    console.log(data);

    init();

    function isScrolledIntoView(el) {
        let rect = el.getBoundingClientRect();
        let elemTop = rect.top;
        let elemBottom = rect.bottom;
        let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
        return isVisible;
    }

    let animate = function(){
        if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            particlesArray.forEach((particle)=>{
                particle.update();
            });
        }
        requestAnimationFrame(animate);
    }

    animate();</span></p>

<canvas class="canvvaas" id="ccaannvvaass5"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass5');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        canvas.width = 800;
        canvas.height = 400;

        let text = 'Karak10\'s Notes!'
        c.font = 'normal 30px Luckiest Guy';
        let measurements = c.measureText(text);
        c.fillStyle = 'white';
        c.fillText(text, 10, 50);
        let height = Math.floor(measurements.actualBoundingBoxAscent + 60);
        let width = Math.floor(measurements.width + 20);

        let imageData = c.getImageData(0, 0, width, height);
        let data = imageData.data;

        let distanceRadius = 30;

        let mouse = {
            x: undefined,
            y: undefined
        }

        let touches = new Array();

        window.addEventListener('mousemove', (e)=>{
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            mouse = {
                x: e.clientX - x,
                y: e.clientY - y
            }
        });

        function setTouches(e){
            touches = [];
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            for(let i = 0; i < e.touches.length; i++){
                touches.push({
                    x: e.touches[i].clientX - x,
                    y: e.touches[i].clientY - y,
                });
            }
        }
    
        function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

        canvas.addEventListener('touchstart', setTouches);
        canvas.addEventListener('touchmove', setTouches);
        canvas.addEventListener('touchend', resetTouches);
        canvas.addEventListener('touchcancel', resetTouches);

        let particlesArray = [];

        let particleConstructor = class{
            constructor(x, y, size, color){
                this.x = x;
                this.y = y;
                this.originalX = this.x;
                this.originalY = this.y;
                this.size = size;
                this.color = color;
                this.velocity = (Math.random() * 30) + 1;
            }
            draw(){
                c.fillStyle = this.color;
                c.beginPath();
                c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                c.fill();
            }
            update(){
               let dx = mouse.x - this.x;
               let dy = mouse.y - this.y;
               let mouseDistance = Math.hypot(dx, dy);
               let mouseDifference = {
                   dx: dx,
                   dy: dy
               }
               let touchesDistances = new Array();
               let minTouchDistance;
               let minTouchDifference;
               if(touches.length > 0){
                   touches.forEach((touch)=>{
                       let x = touch.x - this.x;
                       let y = touch.y - this.y;
                       touchesDistances.push(Math.hypot(x, y));
                   });
                   minTouchDistance = Math.min.apply(Math, touchesDistances);
                   let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
                   minTouchDifference = {
                       dx: touches[minTouchIndex].x - this.x, 
                       dy: touches[minTouchIndex].y - this.y
                   }
               } else {
                   minTouchDistance = Number.NEGATIVE_INFINITY;
               }

               let returnParticles = ()=>{
               if(this.x != this.originalX){
                   let dx = this.x - this.originalX;
                        this.x -= dx / 20;
                    }
                    if(this.y != this.originalY){
                        let dy = this.y - this.originalY;
                        this.y -= dy / 20;
                    }
                }

               if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                    let moveParticle = (distance, difference)=>{
                        let angle = Math.atan2(difference.dy, difference.dx);
                        let forceDirectionX = Math.cos(angle);
                        let forceDirectionY = Math.sin(angle);
                        let maxDistance = distanceRadius;
                        let force = (maxDistance - distance) / maxDistance;
                        let directionX = forceDirectionX * force * this.velocity;
                        let directionY = forceDirectionY * force * this.velocity;
                        this.x -= directionX;
                        this.y -= directionY;
                    }
                    if(mouseDistance < distanceRadius){
                        moveParticle(mouseDistance, mouseDifference);
                    }
                    if(Math.abs(minTouchDistance) < distanceRadius){
                        moveParticle(minTouchDistance, minTouchDifference);
                    }
               } else if(mouseDistance > distanceRadius + 5){
                    returnParticles();
               } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                    returnParticles();
               }
               this.draw();
            }
        }

        let init = function(){
            particlesArray = [];
            for(let y = 0; y < height; y++){
                for(let x = 0; x < width; x++){
                    if(data[(x + y * width) * 4 + 3] == 255){
                        let red = data[(x + y * width) * 4];
                        let green = data[(x + y * width) * 4 + 1];
                        let blue = data[(x + y * width) * 4 + 2];
                        let color = `rgb(${red}, ${green}, ${blue})`;
                        let scale = 3;
                        let distance =  canvas.width - (20 + measurements.width) * scale;
                        let offset = {x: (distance / 2) / scale, y: 20};
                        particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, 0.5, color));
                    }
                }
            }
        }

        console.log(data);

        init();

        function isScrolledIntoView(el) {
            let rect = el.getBoundingClientRect();
            let elemTop = rect.top;
            let elemBottom = rect.bottom;
            let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach((particle)=>{
                    particle.update();
                });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>In the code above I measured the text and used math in order to cender the text, I wanted to make it this way
so that I can then change the text to anything I like and have it be aligned to the center at all times. I also changed the
particles width to 0.5.
</p>

<p>Now, the last thing I want to do is make it so that lines connect the particles together, let's try this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('ccaannvvaass6');
let c = canvas.getContext('2d');
canvas.style.backgroundColor = 'black';

canvas.width = 800;
canvas.height = 400;

let text = 'Karak10\'s Notes!'
<Span class="orange">c.font = 'normal 20px Arial';</span>
let measurements = c.measureText(text);
c.fillStyle = 'white';
c.fillText(text, 10, 50);
let height = Math.floor(measurements.actualBoundingBoxAscent + 60);
let width = Math.floor(measurements.width + 20);

let imageData = c.getImageData(0, 0, width, height);
let data = imageData.data;

let distanceRadius = 30;

let mouse = {
    x: undefined,
    y: undefined
}

let touches = new Array();

window.addEventListener('mousemove', (e)=>{
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    mouse = {
        x: e.clientX - x,
        y: e.clientY - y
    }
});

function setTouches(e){
    touches = [];
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    for(let i = 0; i < e.touches.length; i++){
        touches.push({
            x: e.touches[i].clientX - x,
            y: e.touches[i].clientY - y,
        });
    }
}

function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

canvas.addEventListener('touchstart', setTouches);
canvas.addEventListener('touchmove', setTouches);
canvas.addEventListener('touchend', resetTouches);
canvas.addEventListener('touchcancel', resetTouches);

let particlesArray = [];

let particleConstructor = class{
    constructor(x, y, size, color){
        this.x = x;
        this.y = y;
        this.originalX = this.x;
        this.originalY = this.y;
        this.size = size;
        this.color = color;
        this.velocity = (Math.random() * 30) + 1;
    }
    draw(){
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        c.fill();
    }
    update(){
       let dx = mouse.x - this.x;
       let dy = mouse.y - this.y;
       let mouseDistance = Math.hypot(dx, dy);
       let mouseDifference = {
           dx: dx,
           dy: dy
       }
       let touchesDistances = new Array();
       let minTouchDistance;
       let minTouchDifference;
       if(touches.length > 0){
           touches.forEach((touch)=>{
               let x = touch.x - this.x;
               let y = touch.y - this.y;
               touchesDistances.push(Math.hypot(x, y));
           });
           minTouchDistance = Math.min.apply(Math, touchesDistances);
           let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
           minTouchDifference = {
               dx: touches[minTouchIndex].x - this.x, 
               dy: touches[minTouchIndex].y - this.y
           }
       } else {
           minTouchDistance = Number.NEGATIVE_INFINITY;
       }

       let returnParticles = ()=>{
       if(this.x != this.originalX){
           let dx = this.x - this.originalX;
                this.x -= dx / 20;
            }
            if(this.y != this.originalY){
                let dy = this.y - this.originalY;
                this.y -= dy / 20;
            }
        }

       if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
            let moveParticle = (distance, difference)=>{
                let angle = Math.atan2(difference.dy, difference.dx);
                let forceDirectionX = Math.cos(angle);
                let forceDirectionY = Math.sin(angle);
                let maxDistance = distanceRadius;
                let force = (maxDistance - distance) / maxDistance;
                let directionX = forceDirectionX * force * this.velocity;
                let directionY = forceDirectionY * force * this.velocity;
                this.x -= directionX;
                this.y -= directionY;
            }
            if(mouseDistance < distanceRadius){
                moveParticle(mouseDistance, mouseDifference);
            }
            if(Math.abs(minTouchDistance) < distanceRadius){
                moveParticle(minTouchDistance, minTouchDifference);
            }
       } else if(mouseDistance > distanceRadius + 5){
            returnParticles();
       } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
            returnParticles();
       }
       this.draw();
    }
}

let init = function(){
    particlesArray = [];
    for(let y = 0; y < height; y++){
        for(let x = 0; x < width; x++){
            if(data[(x + y * width) * 4 + 3] > 150){
                let red = data[(x + y * width) * 4];
                let green = data[(x + y * width) * 4 + 1];
                let blue = data[(x + y * width) * 4 + 2];
                let color = `rgb(${red}, ${green}, ${blue})`;
                let scale = 5;
                let distance =  canvas.width - (20 + measurements.width) * scale;
                let offset = {x: (distance / 2) / scale, y: -5};
                particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, 0.5, color));
            }
        }
    }
}

console.log(data);

init();

function isScrolledIntoView(el) {
    let rect = el.getBoundingClientRect();
    let elemTop = rect.top;
    let elemBottom = rect.bottom;
    let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

<Span class="orange">function connectParticles(){
    for(let a = 0; a < particlesArray.length; a++){
        let opacity = 1;
        for(let b = a; b < particlesArray.length; b++){
            let particle1 = particlesArray[a];
            let particle2 = particlesArray[b];
            if(particle1 != particle2){
                let dx = particle1.x - particle2.x;
                let dy = particle1.y - particle2.y;
                let distance = Math.hypot(dx, dy);
                let num = 14;
                if(distance < num){
                    opacity = 1 - (distance / num);
                    c.globalAlpha = opacity;
                    c.strokeStyle = 'white';
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.moveTo(particle1.x, particle1.y);
                    c.lineTo(particle2.x, particle2.y);
                    c.stroke();
                    c.globalAlpha = 1;
                }
            }
        }
    }
}</span>

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particlesArray.forEach((particle)=>{
            particle.update();
        });
<span class="orange">        connectParticles();</span>
    }
    requestAnimationFrame(animate);
}

animate();</span></p>
    
<canvas class="canvvaas" id="ccaannvvaass6"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('ccaannvvaass6');
        let c = canvas.getContext('2d');
        canvas.style.backgroundColor = 'black';

        canvas.width = 800;
        canvas.height = 400;

        let text = 'Karak10\'s Notes!'
        c.font = 'normal 20px Arial';
        let measurements = c.measureText(text);
        c.fillStyle = 'white';
        c.fillText(text, 10, 50);
        let height = Math.floor(measurements.actualBoundingBoxAscent + 60);
        let width = Math.floor(measurements.width + 20);

        let imageData = c.getImageData(0, 0, width, height);
        let data = imageData.data;

        let distanceRadius = 30;

        let mouse = {
            x: undefined,
            y: undefined
        }

        let touches = new Array();

        window.addEventListener('mousemove', (e)=>{
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            mouse = {
                x: e.clientX - x,
                y: e.clientY - y
            }
        });

        function setTouches(e){
            touches = [];
            let box = canvas.getBoundingClientRect();
            let x = box.left;
            let y = box.top;
            for(let i = 0; i < e.touches.length; i++){
                touches.push({
                    x: e.touches[i].clientX - x,
                    y: e.touches[i].clientY - y,
                });
            }
        }
    
        function resetTouches(e){
    if (e.cancelable) {
        e.preventDefault();
    }
    let box = canvas.getBoundingClientRect();
    let x = box.left;
    let y = box.top;
    touches.forEach((touch, i)=>{
        if(Math.abs(touch.x - (e.changedTouches[0].clientX - x)) < e.changedTouches[0].radiusX + 10){
            touches.splice(i, 1);
        }     
    });
}

        canvas.addEventListener('touchstart', setTouches);
        canvas.addEventListener('touchmove', setTouches);
        canvas.addEventListener('touchend', resetTouches);
        canvas.addEventListener('touchcancel', resetTouches);

        let particlesArray = [];

        let particleConstructor = class{
            constructor(x, y, size, color){
                this.x = x;
                this.y = y;
                this.originalX = this.x;
                this.originalY = this.y;
                this.size = size;
                this.color = color;
                this.velocity = (Math.random() * 30) + 1;
            }
            draw(){
                c.fillStyle = this.color;
                c.beginPath();
                c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                c.fill();
            }
            update(){
               let dx = mouse.x - this.x;
               let dy = mouse.y - this.y;
               let mouseDistance = Math.hypot(dx, dy);
               let mouseDifference = {
                   dx: dx,
                   dy: dy
               }
               let touchesDistances = new Array();
               let minTouchDistance;
               let minTouchDifference;
               if(touches.length > 0){
                   touches.forEach((touch)=>{
                       let x = touch.x - this.x;
                       let y = touch.y - this.y;
                       touchesDistances.push(Math.hypot(x, y));
                   });
                   minTouchDistance = Math.min.apply(Math, touchesDistances);
                   let minTouchIndex = touchesDistances.indexOf(minTouchDistance);
                   minTouchDifference = {
                       dx: touches[minTouchIndex].x - this.x, 
                       dy: touches[minTouchIndex].y - this.y
                   }
               } else {
                   minTouchDistance = Number.NEGATIVE_INFINITY;
               }

               let returnParticles = ()=>{
               if(this.x != this.originalX){
                   let dx = this.x - this.originalX;
                        this.x -= dx / 20;
                    }
                    if(this.y != this.originalY){
                        let dy = this.y - this.originalY;
                        this.y -= dy / 20;
                    }
                }

               if(mouseDistance < distanceRadius || Math.abs(minTouchDistance) < distanceRadius){
                    let moveParticle = (distance, difference)=>{
                        let angle = Math.atan2(difference.dy, difference.dx);
                        let forceDirectionX = Math.cos(angle);
                        let forceDirectionY = Math.sin(angle);
                        let maxDistance = distanceRadius;
                        let force = (maxDistance - distance) / maxDistance;
                        let directionX = forceDirectionX * force * this.velocity;
                        let directionY = forceDirectionY * force * this.velocity;
                        this.x -= directionX;
                        this.y -= directionY;
                    }
                    if(mouseDistance < distanceRadius){
                        moveParticle(mouseDistance, mouseDifference);
                    }
                    if(Math.abs(minTouchDistance) < distanceRadius){
                        moveParticle(minTouchDistance, minTouchDifference);
                    }
               } else if(mouseDistance > distanceRadius + 5){
                    returnParticles();
               } else if(Math.abs(minTouchDistance) > distanceRadius + 5){
                    returnParticles();
               }
               this.draw();
            }
        }

        let init = function(){
            particlesArray = [];
            for(let y = 0; y < height; y++){
                for(let x = 0; x < width; x++){
                    if(data[(x + y * width) * 4 + 3] > 150){
                        let red = data[(x + y * width) * 4];
                        let green = data[(x + y * width) * 4 + 1];
                        let blue = data[(x + y * width) * 4 + 2];
                        let color = `rgb(${red}, ${green}, ${blue})`;
                        let scale = 5;
                        let distance =  canvas.width - (20 + measurements.width) * scale;
                        let offset = {x: (distance / 2) / scale, y: -5};
                        particlesArray.push(new particleConstructor((x + offset.x) * scale, (y + offset.y) * scale, 0.5, color));
                    }
                }
            }
        }

        console.log(data);

        init();

        function isScrolledIntoView(el) {
            let rect = el.getBoundingClientRect();
            let elemTop = rect.top;
            let elemBottom = rect.bottom;
            let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            return isVisible;
        }

        function connectParticles(){
            for(let a = 0; a < particlesArray.length; a++){
                let opacity = 1;
                for(let b = a; b < particlesArray.length; b++){
                    let particle1 = particlesArray[a];
                    let particle2 = particlesArray[b];
                    if(particle1 != particle2){
                        let dx = particle1.x - particle2.x;
                        let dy = particle1.y - particle2.y;
                        let distance = Math.hypot(dx, dy);
                        let num = 14;
                        if(distance < num){
                            opacity = 1 - (distance / num);
                            c.globalAlpha = opacity;
                            c.strokeStyle = 'white';
                            c.lineWidth = 0.5;
                            c.beginPath();
                            c.moveTo(particle1.x, particle1.y);
                            c.lineTo(particle2.x, particle2.y);
                            c.stroke();
                            c.globalAlpha = 1;
                        }
                    }
                }
            }
        }
        let animate = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particlesArray.forEach((particle)=>{
                    particle.update();
                });
                connectParticles();
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>To connect the particles with lines I created the connectParticles function,
it's actually a pretty simple function once you understand what it does, it has two loops,
so, I am looking through all the particles, and for each particle, I loop through
all particles to compare this one with the rest, however, comparing every single particle
with every single other particle is not needed, if I for example have already compared particle 1 with particle 2
then when it's particle's 2 turn to check all other particles it would be a waste of time
to check it's distance with particle 1 since this would already have been done before,
that's why in the second loop I set b to a, so, if second particle for example is checking it's distance
with all the other particles it will not check particles before it, since they already have been checked.
To make the lines I first calculate the distance of the two particles, if the distance is smaller than a
number you define, which in my case I decided to be 14, then I draw lines from one particle to another.
However, to make the effect look cooler, I wanted to make it so that lines do not just appear and disappear,
I wanted to make it so that they slowly appear as the particles get closer and slowly disappears when
the particles move away, and to do that I declared an opacity variable, and
set it to 1 - (distance / num), don't overthink this too much, if distance is 14 then 1 - 1 will return 0 so the line will be invisible,
if distance is 0 then 1 - 0 equals 1 so the line will be fully visible, anything in between
will return numbers between 0 and 1.
</p>
</article>
<hr>
</body>
</html>