<!DOCTYPE HTML>
<html lang="en-US">
<head>
<title> Page twenty-three of my notes </title>
<meta charset="UTF-8"> 
<link href="../CSS-JavaScript-External-Files/HTMLnotes.css" rel="stylesheet">
<Style>
    .left {
        text-align: left;
    }
    
    .code10 {
    white-space: pre-wrap;
    background-color: lightgreen;
    
    }
    
    p {
    text-align:center;
    }
    h1 {
    text-align:center;
    }
    h2 {
    text-align:center;
    }
    h3 {
    text-align:center;
    }
    .c {
    background-color:lightgreen;
    }
    hr {
    width:100%;
    height:15px;
    background-color:black;
    color:black;
    border: black solid;
    }
    body {
    background-color:rgb(165, 235, 235);
    }
    span {
    background-color:lightgreen;
    }
    
    a:link {
    color: black;
    text-shadow: 1px 0px 1px black;
    
    }
    
    a:visited {
    color: black;
    text-shadow: 1px 0px 1px rgb(22, 22, 22);
    }
    
    a:hover {
    text-decoration: underline;
    color: red;
    text-shadow: 1px 0px 1px black;
    }

    .pink {
        background-color: lightcoral;
        font-weight: bold;
    }

    iframe {
        width: 600px;
        height: 350px;
        border: 3px solid black;
        margin: 20px auto 20px auto;
        display: block;
    }
    
   .list_container{
       width: 50vw;
       max-width: 600px;
       background-color: white;
       border: 3px solid black;
       border-radius: 20px;
       margin: 20px auto 20px auto;
       padding: 20px;
       font-weight: bold;
   }
    
   .list_container li{
       margin-top: 15px;

   }

   .gray{
       background-color: lightgray;
   }

    </style> 
</head>
<body>

<hr>

    <header> 
    <h1> Page eleven of my JavaScript notes </h1>
    </header>
    
<article id="start-of-page"> 
  
<div id="homepages">

    <h3>Home Pages:</h3>
   

</div>

<nav data-notes="JavaScript" data-page="11">

</nav>

    <h3> Informations included in this page:</h3>
    <p><a href="../JavaScript-Notes/Notes23.html#one">Introduction to Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#two">Canvas Basics</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#three">Introduction to Canvas Paths</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#four">Bezier Curves in Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#five">Canvas Arcs</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#six">Canvas Text</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#seven">Linear Gradients in Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eight">Canvas Transforms</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#nine">Stroke properties</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#ten">Canvas globalAlpha property</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eleven">Using images</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#twelve">Animating the Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#thirteen">Using event listeners with Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#fourteen">Creating gravity effect on Canvas</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#fifteen">Collision Detection</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#sixteen">Circual Movement</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#seventeen">How to obtain and manipulate pixels data</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#eighteen">How to make Sine Waves</a></p>
    <p><a href="../JavaScript-Notes/Notes23.html#nineteen">Controlled Randomness with Perlin Noise</a></p>

    
</article>

 <script src="../CSS-JavaScript-External-Files/nav.js"></script>

<hr>

<article id="one">

    <header>
        <h1>Introduction to Canvas</h1>
    </header>

<p>Back to drawing again, this takes me back to the times I was learning how to 
    draw <Span>SVG</Span>, hopefully some of the stuff I learned back then will 
make the learning process of the <Span>canvas</Span> easier for me, since even though 
the are different they still have some similarities too. So what exactly is the <Span>canvas</Span>?
And how is that different from <Span>SVG</Span>?</p>

<p><Span>&lt;canvas></Span> is an <span>HTML</span> element which can be used 
to draw <Span>graphics</Span> via <Span>scripting</Span> (usually <Span>JavaScript</Span>). This 
can, for instance, be used to draw <Span>graphs</Span>, <Span>combined photos</Span>, 
or create <Span>animations</Span>, <Span>games</Span> and more.</p>

<p>The main difference between <Span>canvas</Span> and <Span>SVG</Span> is that 
<Span>canvas</Span> is drawn <Span>progammatically</Span> and the <Span>drawing</Span>
is done with <Span>pixels</Span>, while <Span>SVG</Span> is drawn by 
<Span>elements</Span> which are a part of the page's <Span>DOM</Span> and the 
<Span>drawing</Span> is done by <Span>vectors</Span>. I have listed 
more about <Span>canvas</Span> and <Span>SVG</Span> <a href="../HTML-Notes/Notes5.html#twelve">here</a>
but these I believe are the most important differences. </p>

<p>So now, let's try and create our very first <Span>canvas</Span> element:</p>

<p class="left">HTML Code:</p>

<p class="left"><span class="code10">&lt;canvas id="first-canvas">&lt;/canvas></span></p>

<p class="left">CSS Code:</p>

<p class="left"><span class="code10">#first-canvas{
    display: block;
    margin: 20px auto 20px auto;
    border: 2px solid black;
}</span></p>

<p class="left">Outcome:</p>

<style>
    #first-canvas{
        display: block;
        margin: 20px auto 20px auto;
        border: 2px solid black;
    }
</style>

<canvas id="first-canvas"></canvas>

<p>So as you can see, the <Span>canvas</Span> is an <Span>inline-block</Span> element
and by default it's <Span>background</Span> is <Span>invisible</Span>, it also has a 
<Span>default size</Span>, which I think is <span>300px width</span> and <Span>150px height</Span>.</p>

</article>

<hr>

<article id="two">

    <header>
        <h1>Canvas Basics</h1>
    </header>

<p>Let's learn how to draw some basic shapes now, drawing is 
done <Span>progammatically</Span>, so we will have to do it 
through <Span>JavaScript</Span> of course, to draw stuff you 
first need to access the <Span>context</Span> of the <Span>canvas</Span>
which you can do by using <Span>getContext()</Span> method, this method 
can take a <Span>parameter</Span>, all I know at the moment is that we should 
write <Span>getContext('2d')</Span>, because we will be drawing in <Span>2d</Span>
I guess, later we may learn about <span>3d</span> too.</p>

<p>The <Span>getContext('2d') method</Span>
will return the <Span>CanvasRenderingContext2D</Span> object, which contains information 
about the <Span>canvas</Span>, if you access it's <Span>prototype</Span> using <Span>__proto__</Span>
there you will find all the different <Span>methods</Span> that you can use to 
<Span>draw</Span> the <Span>canvas</Span>, so if you ever forget a <Span>method</Span>
that's where you can find a reference of all the <Span>methods</Span> that exist, through it's 
<Span>prototype</Span> you can access it's <Span>constructor</Span> and the <Span>Object Prototype</Span>, 
and that's basically how <Span>CanvasRenderingContext2D</Span> is chained in the 
<Span>prototype tree</Span>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#first-canvas');
let c = canvas.getContext('2d');
console.log(c);</span></p>

<p class="left">Outcome:</p>

<style>
    img{
        display: block;
        border: 2px solid black;
        margin: 20px auto 20px auto;
        border-radius: 20px;
    }
</style>
<img src="../images/Î¶1.PNG">

</p>

<script>
    if(true){
       let canvas = document.querySelector('#first-canvas');
       let c = canvas.getContext('2d');
       console.log(c);
    }
</script>

<p>So, let's start by drawing a simple <Span>rectangle</Span>, to do so we will need to use 
the <span>fillRect(x, y, width, height)</span> method, like in the example below:</p>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;canvas id="second-canvas" class="canvas">&lt;/canvas></Span></p>

<p class="left">CSS Code:</p>

<p class="left"><Span class="code10">.canvas{
    display: block;
    margin: 20px auto 20px auto;
    width: 500px;
    height: 200px;
    border: 2px solid black;
    background-color: white;
}</Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas =  document.querySelector('#second-canvas');
let c = canvas.getContext('2d');

c.fillRect(100, 20, 100, 100);</Span></p>

<p class="left">Outcome:</p>

<style>
    .canvas{
        display: block;
        margin: 20px auto 20px auto;
        width: 500px;
        height: 200px;
        background-color: white;
        border: 2px solid black;
    }
</style>

<canvas id="second-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas =  document.querySelector('#second-canvas');
        let c = canvas.getContext('2d');

        c.fillRect(100, 20, 100, 100);
    }
</script>

<p>So, the <Span>y</Span> is the <Span>top</Span> of the <Span>rectangle</Span>
and not the <Span>bottom</Span> as you may expected, imagine the <Span>rectangle</Span> was 
a <Span>paper</Span>, put your finger on the <Span>top left corner</Span> of the <Span>rectangle</Span> and 
move it <Span>100 px</Span> to the <Span>right</Span> and <Span>20px down</Span>, that's what we basically did.</p>

<p>So, how do you <Span>color</Span> those <Span>rectangles</Span>? If you take a 
look at <Span>CanvasRenderingContext2D object</Span> in the picture above, there 
is a <span>property</span> called <span>fillStyle</span>, by default it's set to 
<Span>#000000</Span>, which is <Span>black</Span>, when using a <Span>method</Span> such 
as <Span>fillRect()</Span>, the <Span>shape</Span> looks at <Span>fillStyle</Span> property 
and <Span>colors</Span> the <Span>shape</Span> based on the <Span>value</Span> of the 
<span>property</span>, so to <Span>color</Span> your <Span>rectangles</Span> simple 
<span>change</span> the <Span>value</Span> of this <Span>property</Span> to the 
wanted <Span>color</Span>, like in the example below:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#third-canvas');
let c = canvas.getContext('2d');

c.fillStyle = "red";
c.fillRect(20, 20, 50, 50);
c.fillStyle = "green";
c.fillRect(200, 20, 50, 50);
c.fillStyle = "blue";
c.fillRect(100, 80, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="third-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#third-canvas');
        let c = canvas.getContext('2d');
        
        c.fillStyle = "red";
        c.fillRect(20, 20, 50, 50);
        c.fillStyle = "green";
        c.fillRect(200, 20, 50, 50);
        c.fillStyle = "blue";
        c.fillRect(100, 80, 50, 50);
       
    }
</script>

<p>How do we style the <Span>stroke</Span> of those <Span>rectangles</Span> now? Just like 
<Span>fillStyle</Span>, if you take a look in the <span>CanvasRenderingContext2D</span> there is a 
<Span>property</Span> called <Span>strokeStyle</Span> which by default is set to <Span>black</Span>, 
the <Span>value</Span> of this <Span>property</Span> is used to set the <Span>color</Span> of the 
<Span>stroke</Span>, however, the <Span>rectangles</Span> above don't have a <span>stroke</span>, 
so how do we add them one? You could use <Span>strokeRect</Span> to create a <Span>rectangle</Span>
with only <Span>stroke</Span> and then <Span>position it</Span> where your <span>rectangle</Span>
is.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#fourth-canvas');
let c = canvas.getContext('2d');

c.strokeStyle = "red";
c.fillRect(20, 20, 50, 50);
c.strokeRect(20, 20, 50, 50);
c.fillRect(200, 20, 50, 50);
c.strokeRect(200, 20, 50, 50);
c.fillRect(100, 80, 50, 50);
c.strokeRect(100, 80, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="fourth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#fourth-canvas');
        let c = canvas.getContext('2d');
        
        c.strokeStyle = "red";
        c.fillRect(20, 20, 50, 50);
        c.strokeRect(20, 20, 50, 50);
        c.fillRect(200, 20, 50, 50);
        c.strokeRect(200, 20, 50, 50);
        c.fillRect(100, 80, 50, 50);
        c.strokeRect(100, 80, 50, 50);
       
    }
</script>

<p>Alright, great, but how do you change the <Span>width</Span> of the 
<Span>stroke</Span>? You can do so with the <Span>lineWidth</Span> property, just 
like <Span>fillStyle</Span> and <Span>stokeStyle</Span>, this <span>property</span> can be 
found inside the <Span>CanvasRenderingContext2D</Span> and by default it's 
<span>value</span> is <Span>1</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#fifth-canvas');
let c = canvas.getContext('2d');

c.strokeStyle = "red";
c.lineWidth = "10";
c.fillRect(100, 20, 100, 100);
c.strokeRect(100, 20, 100, 100);</Span></p>

<p class="left">Outcome:</p>

<canvas id="fifth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#fifth-canvas');
        let c = canvas.getContext('2d');
        
        c.strokeStyle = "red";
        c.lineWidth = "10";
        c.fillRect(100, 20, 100, 100);
        c.strokeRect(100, 20, 100, 100);
       
    }
</script>

<p>So now, what if you wanted to create many <Span>rectangles</Span> and 
wanted to have a <Span>stroke</Span> for all of them? Would you need to 
make all <Span>rectangles</Span> and <span>strokes</span> differently? That would take 
a lot of space and time, so you could instead create a <Span>function</Span>
that creates <Span>rectangles with stroke</Span> without needing to place
the <Span>stroke</Span> and <Span>rectangle</Span> differently:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#sixth-canvas');
let c = canvas.getContext('2d');

function createRect(x, y, w, h, fs, ss, lw){
    c.fillStyle = fs;
    c.strokeStyle = ss;
    c.lineWidth = lw;
    c.fillRect(x, y, w, h);
    c.strokeRect(x, y, w, h);    
}

createRect(20, 40, 50, 50);
createRect(100, 20, 50, 50, 'yellow', undefined,5);
createRect(180, 40, 50, 50, 'blue', 'red', 3);</Span></p>

<p class="left">Outcome:</p>

<canvas id="sixth-canvas" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#sixth-canvas');
        let c = canvas.getContext('2d');
        
        function createRect(x, y, w, h, fs, ss, lw){
            c.fillStyle = fs;
            c.strokeStyle = ss;
            c.lineWidth = lw;
            c.fillRect(x, y, w, h);
            c.strokeRect(x, y, w, h);    
        }
        
        createRect(20, 40, 50, 50);
        createRect(100, 20, 50, 50, 'yellow', undefined,5);
        createRect(180, 40, 50, 50, 'blue', 'red', 3);
       
    }
</script>

<p>Before I finish with this section, I want to also talk about <span>clearRect(x, y, w, h)</span>
method, which <span>clears</Span> a <Span>specified rectangular area</Span>, making it 
<Span>fully transparent</Span>, like this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#eighth-canvas');
let c = canvas.getContext('2d');

c.fillRect(20, 20, 100, 100);
c.clearRect(40, 40, 60, 60);</Span></p>

<p class="left">Outcome:</p>

<canvas id="eighth-canvas" class="canvas"></canvas>

<script>
   if(true){
       let canvas = document.querySelector('#eighth-canvas');
       let c = canvas.getContext('2d');

       c.fillRect(20, 20, 100, 100);
       c.clearRect(40, 40, 60, 60);
   }
</script>

<p>So what did we learn in this section? Here is a list of 
    all the <span>properties</span> and <span>methods</span> we 
    went over, as well as a quick description of what each does:

    <div class="list_container">
        <ul>
            <li><span>canvas.getContext('2d')</span> - returns the CanvasRenderingContext2D object, should be accessed in order to use any of the following methods/properties</li>
            <li><span>fillRect(x, y, w, h)</span> - creates a rectangle</li>
            <li><span>strokeRect(x, y, w, h)</span> - creates a stroke of a rectangle, without a fill</li>
            <li><Span>clearRect(x, y, w, h)</Span> - clears the specified rectangular area making it fully transparent</li>
            <li><span>fillStyle = string</span> - sets the color that should be used when creating shapes</li>
            <li><span>strokeStyle = string</span> - sets the color that should be used when creating strokes</li>
            <li><span>lineWidth = number</span> - sets the width that should be used when creating strokes</li>
       </ul>
    </div>
</p>
</article>

<hr>

<article id="three">

    <header>
        <h1>Introduction to Canvas Paths</h1>
    </header>

    <p>Alright, so we now know how to make <Span>rectangles</Span>, we are not going 
    to make minecraft though, so we need something more than just <Span>rectangles</Span>.
    Let's talk about <Span>paths</Span> now, they are pretty similar to <Span>SVG paths</Span>,
what exactly is a <span>path</span> though?</p>

<P>You can think of a <Span>path</Span> as a <Span>set of instructions</Span> used 
to move a <Span>virtual pen</Span> around to form <Span>lines</Span> and 
<Span>curves</Span>, in this section, I will go over some basic <Span>path commands</Span>, I 
will get in more details about <Span>curves</Span>, <Span>arcs</Span> and more in later sections.</P>

<p>To <Span>begin a path</Span> you shoud use the <Span>beginPath()</Span> method, after 
that to start <Span>drawing your path</Span> you can use <Span>moveTo(x, y)</Span> to <Span>pick up</Span>
your <Span>virtual pen</Span> and <Span>move it</Span> around, <Span>without drawing</Span>, and then you can use 
<Span>lineTo(x, y)</Span> to create a <Span>line</Span> from the position your 
<Span>virtual pen</Span> was moved to, to the specified <Span>coordinates</Span>, lastly, you can 
use the <Span>closePath()</Span> method to create a <Span>line</Span> back to the 
<Span>start of the path</Span> and <Span>close the shape</Span>. This by it 
self will not have any visible effect on the <Span>canvas</Span> however, and that's because the <Span>path</Span> 
still has no <Span>stroke</Span> or <Span>fill</Span>, you can add a <Span>stroke</Span>
using the <Span>stroke()</Span> method, and you can add a <Span>fill</Span> using the <Span>fill()</Span> method.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#seventh-canvas');
let c = canvas.getContext('2d');

c.beginPath();
c.moveTo(10, 10);
c.lineTo(100, 10);
c.lineTo(100, 100);
c.closePath();
c.strokeStyle = 'red';
c.lineWidth = 3;
c.stroke();
c.fillStyle = 'yellow';
c.fill();</Span></p>

<p class="left">Outcome:</p>

<canvas id="seventh-canvas" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#seventh-canvas');
        let c = canvas.getContext('2d');

        c.beginPath();
        c.moveTo(10, 10);
        c.lineTo(100, 10);
        c.lineTo(100, 100);
        c.closePath();
        c.strokeStyle = 'red';
        c.lineWidth = 3;
        c.stroke();
        c.fillStyle = 'yellow';
        c.fill();
    }
</Script>

<p>So what did we lern in this section? Here is a list of all the <Span>methods</Span> we went over, 
as well as a quick description of what each does:</p>

<div class="list_container">
    <li><Span>beginPath()</Span> - creates a new path, once created, future drawing commands 
    can be directed into the path and used to build the path up</li>
    <li><Span>stroke()</Span> - draws the shape by stroking the path's outline</li>
    <li><Span>fill()</Span> - draws a solid shape by filling the path's content area</li>
    <li><Span>moveTo(x, y)</Span> - moves the virtual pen to the coordinates specified by x and y</li>
    <li><Span>lineTo(x, y)</Span> - draws a line from current drawing position to the position specified by x and y</li>
    <li><Span>closePath()</Span> - adds a straight line to the path, going to the start of the current sub-path</li>
</div>

<p>Here is a really cool video that explains the methods I just talked about in only two minute:</p>
<iframe src="https://www.youtube.com/embed/VNejl6cMH-s" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="four">

    <header>
        <h1>Bezier Curves in Canvas</h1>
    </header>

    <p>The next type of <Span>paths</span> I want to talk about are <Span>Bezier curves</span>, there are 
    actually <Span>2 methods</Span> I want to talk about, and these are <Span>quadraticCurveTo(cp1x, cp1y, x, y)</Span>
and <Span>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</Span> methods.</p>

<p>The difference between these two can best be described using the following image:</p>

<img src="../images/Î¶2.PNG">

<p>As you can see, to draw <Span>curves</Span> you are using <Span>control points</Span>, 
<span>bezier curves</span> use <Span>two control points</Span> while <Span>quadratic curves</Span> 
only use <Span>one control point</Span>.</p>

<p>Here is a <Span>quadratic curve</Span> for example, I have set a <Span>background</Span> and 
drew the <Span>control point</Span> too so that it is easier to see what exactly happens with the code, 
in order to get confortable with using <Span>control points</Span> you should play around with 
it:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-one');
let c = canvas.getContext('2d');

c.beginPath();
c.strokeStyle = "black";
c.moveTo(80, 60);
c.quadraticCurveTo(120, 100, 160, 60)
c.lineWidth = 3;
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-one" class="canvas"></canvas>

<style>
  .canvas{
      height: 250px;
  }
</style>
<Script>
    function background(x){
        x.fillStyle = "rgba(6, 190, 46, 0.100)"
        for(let i=0; i<=40; i++){
        x.fillRect(0, i * 20, 500, 1);
        x.fillRect(i * 20, 0, 1, 200);
        x.fillStyle = "rgba(6, 190, 46, 0.579)"
        if(i > 1){
        x.fillRect(i * 10, 10, 1, 200);
        } 
        x.fillRect(0, i * 10, 500, 1);
        x.lineWidth = 1;
        x.font = "8px Arial"
        if(i == 1){
            x.strokeText(i * 10, 1.5, i * 10 - 1);
         } else if(i > 1 && i <= 4){
        x.strokeText(i * 20, i * 20 - 15, 8);
        x.strokeText(i * 10, 1.5, i * 10 - 1);
        } else {
            x.strokeText(i * 20, i * 20 - 16, 8)
            x.strokeText(i * 10, 1.5, i * 10 - 1);
        }

        }
    }

    if(true){
        let canvas = document.querySelector('#canvas-one');
        let c = canvas.getContext('2d');
        
        background(c);

        c.beginPath();
        c.lineWidth = 1;
        c.strokeStyle = "gray";
        c.moveTo(80, 60);
        c.lineTo(120, 100);
        c.lineTo(160, 60);
        c.stroke();

        c.beginPath();
        c.fillStyle = "red";
        c.arc(120, 100, 2, 0, 2*Math.PI);
        c.fill();

        c.beginPath();
        c.strokeStyle = "black";
        c.moveTo(80, 60);
        c.quadraticCurveTo(120, 100, 160, 60)
        c.lineWidth = 3;
        c.stroke();

    }
</Script>

<p>Now let's try to create a <Span>bezier curve</Span>, which uses 
    <Span>two control points</span>:

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-2');
let c = canvas.getContext('2d');

c.beginPath();
c.moveTo(70, 80);
c.bezierCurveTo(90, 30, 150, 120, 180, 80);
c.lineWidth = 2;
c.strokeStyle="black";
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-2"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-2');
        let c = canvas.getContext('2d');

        background(c);

        c.beginPath();
        c.moveTo(70, 80)
        c.lineTo(90, 30);
        c.moveTo(180, 80);
        c.lineTo(150, 120);
        c.strokeStyle = "gray";
        c.stroke();

        c.beginPath();
        c.fillStyle = "red";
        c.arc(90, 30, 2, 0, 2*Math.PI);
        c.arc(150, 120, 2, 0, 2*Math.PI);
        c.fill();

        c.beginPath();
        c.moveTo(70, 80);
        c.bezierCurveTo(90, 30, 150, 120, 180, 80);
        c.lineWidth = 2;
        c.strokeStyle="black";
        c.stroke();
    }
</Script>

<p>Here is a helpful video that explains curves pretty well:</p>

<iframe src="https://www.youtube.com/embed/uQbqB8J7Ua0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="five">

    <header>
        <h1>Canvas Arcs</h1>
    </header>

    <p>Let's now learn about <Span>Arcs</Span>, to create <Span>arcs</Span> you should use 
    the <Span>arc(x, y, r, sAngle, eAngle, counterclockwise)</Span> method, as you can see it has quite 
a few <Span>parameters</Span> it can take, but I'm gonna explain what each does as well as I can.</p>

<p>The <Span>x</Span> and <Span>y</Span> should be used to place the <Span>arc</Span>
on the <Span>canvas</Span>, the <Span>r</Span> is the <Span>radius</Span> of 
the <Span>arc</Span>, the <Span>sAngle</Span> and <Span>eAngle</Span> parameters take 
<Span>radians</Span> and define the <Span>starting angle</Span> and <Span>ending angle</Span> of 
the <Span>arc</Span> and lastly the <Span>counterclockwise</Span> is <Span>optional</Span> and takes a 
<Span>boolean value</Span>, by default it is <Span>fault</Span> which means 
the <Span>arc</Span> is drawn <Span>clockwise</Span>, if changed to <Span>ture</Span> 
the it is drawn <Span>counter-clockwise</Span>. </p>

<p>In order to easier be able to work with <Span>arcs</Span>, we will convert 
<Span>degrees</Span> to <Span>radians</Span> by doing <Span>degrees * Math.PI / 180</Span>, 
here is an example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-3');
let c = canvas.getContext('2d');

let Sangle = 90 * Math.PI / 180;
let Eangle = 180 * Math.PI / 180;

c.fillStyle = "green"
c.strokeStyle = "black";

c.beginPath();
c.arc(70, 90, 30, Sangle, Eangle, false);
c.lineTo(70, 90);
c.closePath();
c.stroke();
c.fill();

Sangle = -90 * Math.PI / 180;
Eangle = 180 * Math.PI / 180;

c.beginPath();
c.arc(155, 90, 30, Sangle, Eangle, false);
c.lineTo(155, 90);
c.closePath();
c.stroke();
c.fill();
  
Sangle = 90 * Math.PI / 180;
Eangle = 180 * Math.PI / 180;

c.beginPath();
c.arc(240, 90, 30, Sangle, Eangle, true);
c.lineTo(240, 90);
c.closePath();
c.stroke();
c.fill();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-3" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-3');
        let c = canvas.getContext('2d');

        background(c);

        let Sangle = 90 * Math.PI / 180;
        let Eangle = 180 * Math.PI / 180;

        c.beginPath()
        c.strokeStyle = "red";
        c.arc(70, 90, 30, 0, 2 * Math.PI, false);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(70, 90, 30, Sangle, Eangle, false);
        c.lineTo(70, 90);
        c.closePath();
        c.stroke();
        c.fill();

        Sangle = -90 * Math.PI / 180;
        Eangle = 180 * Math.PI / 180;

        c.beginPath();
        c.strokeStyle = "red";
        c.arc(155, 90, 30, 0, 2 * Math.PI, false);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(155, 90, 30, Sangle, Eangle, false);
        c.lineTo(155, 90);
        c.closePath();
        c.stroke();
        c.fill();

        
        Sangle = 90 * Math.PI / 180;
        Eangle = 180 * Math.PI / 180;

        c.beginPath();
        c.strokeStyle = "red";
        c.arc(240, 90, 30, 0, 2 * Math.PI, true);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.arc(240, 90, 30, Sangle, Eangle, true);
        c.lineTo(240, 90);
        c.closePath();
        c.stroke();
        c.fill();

    }
</Script>

<p>I have done some extra decoration so tht it's easier to understand what's happening, so, let's look at the 
    <Span>first arc</Span>, it is drawn <Span>clockwise</Span>, the <span>arcs</span>
    are drawn from the <Span>x axis</Span> of the <Span>right side</span> of the <Span>circle</Span>, since it's <Span>end angle</Span> is 
    <Span>180</Span> the <Span>arc</Span> was drawn all the way to the <San>left side</San> forming <Span>half a circle</Span>, 
    however, since the <Span>start angle</Span> is <Span>90</Span>, the <Span>90 first degrees</Span> were 
    <Span>cleared</Span>, leaving us with <Span>1/4 of the circle</Span>.
</p>

<p>The <Span>second arc</Span> is the same, except that the <Span>star degree</Span> is 
<Span>-90</Span> instead of <span>90</span>. Lastly, the <Span>third arc</Span> is drawn <Span>counter-clockwise</Span>, it's 
<Span>end degree</Span> is <Span>180</Span> which is why the <Span>top half</Span> of the  
<span>arc</span> is drawn and the <Span>start degree</Span> is <Span>90</Span>, the <Span>start degree</Span> 
is formed <Span>clockwise</Span> no matter what, so that's why the <Span>1/4</Span> of the <Span>right down side</Span> of the <Span>circle</Span> 
is drawn.</Span></p>

<p>Alright, so <Span>arc()</Span> method is pretty cool when you want to make 
<Span>circles</Span> and stuff, let's now talk about <Span>arcTo(x1, y1, x2, y2, r)</Span> method
which is kind like <Span>curves</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-4');
let c = canvas.getContext('2d');

c.beginPath();
c.strokeStyle = "black";
c.lineWidth = "2";
c.moveTo(100, 90);
c.arcTo(155, 50, 200, 90, 40);
c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-4" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-4');
        let c = canvas.getContext('2d');

        background(c);
 
        c.beginPath();
        c.strokeStyle = "red";
        c.moveTo(100, 90);
        c.lineTo(155, 50);
        c.lineTo(200, 90);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "blue";
        c.arc(152, 102, 40, 0, 2 * Math.PI, false);
        c.font = "10px Arial";
        c.strokeText("40r", 147, 104);
        c.stroke();

        c.beginPath();
        c.strokeStyle = "black";
        c.lineWidth = "2";
        c.moveTo(100, 90);
        c.arcTo(155, 50, 200, 90, 40);
        c.stroke();
    }
</Script>

<p>So, I did some extra decoration as you can see to help you understand what kind of happens 
    behind the scenes in order to form the <Span>arc</Span>, this is a little complicated the truth is, 
    however, I have just the perfect video right here to help you understand how this method works:
</p>

<iframe src="https://www.youtube.com/embed/VkS7B9IvGy8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="six">

    <header>
        <h1>Canvas Text</h1>
    </header>

<p>Let's now learn how to draw <Span>text</Span> on the 
<Span>canvas</Span>, the <Span>most important methods</Span> you need 
to know are the following: <Span>font</Span>, <Span>fillText(text, x, y)</Span>
and <span>strokeText(text, x, y)</span>.</p>

<div class="list_container">
    <ul>
        <li><Span>font</Span> - defines the font properties for the text, must like in CSS</li>
        <li><span>fillText(text, x, y)</span> - draws filled text on the canvas</li>
        <li><span>strokeText(text, x, y)</span> - draws text on the canvas without fill</li>
    </ul>
</div>

<p class = "left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-5');
let c = canvas.getContext('2d');

<Span class="gray">// type, size, font-family
// type: norma, italic, bold</span>
c.font = "normal 24px Arial";
c.fillStyle = "blue";

c.fillText("Hello World!", 80, 60);
c.strokeText("Hello World!", 80, 60);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-5" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-5');
        let c = canvas.getContext('2d');

        background(c);
        
        // type, size, font-family
        // type: norma, italic, bold
        c.font = "normal 24px Arial";
        c.fillStyle = "blue";

        c.fillText("Hello World!", 80, 60);
        c.strokeText("Hello World!", 80, 60);

    }
</script>

<p>Let's learn some more <Span>methods</Span> now, to 
<Span>align</Span> text you will need to use <Span>textAlign</Span>
and <Span>textBaseline</Span> properties:</p>

<p>Let's first learn the different <Span>textAlign</Span> values 
you can use to <Span>align</Span> text <Span>horizontally</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-6');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";

c.textAlign = "start";
c.fillText('textAlign=start', 140, 40);
c.textAlign = "end";
c.fillText('textAlign=end', 140, 60);
c.textAlign = "left";
c.fillText('textAlign=left', 140, 80);
c.textAlign = "center";
c.fillText('textAlign=center', 140, 100);
c.textAlign = "right";
c.fillText('textAlign=right', 140, 120);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-6" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-6');
        let c = canvas.getContext('2d');

        background(c);
        
        c.fillStyle = "red";
        c.fillRect(140, 30, 1, 90);

        c.fillStyle = "black";
        c.font = "normal 15px Arial";
        
        c.textAlign = "start";
        c.fillText('textAlign=start', 140, 40);
        c.textAlign = "end";
        c.fillText('textAlign=end', 140, 60);
        c.textAlign = "left";
        c.fillText('textAlign=left', 140, 80);
        c.textAlign = "center";
        c.fillText('textAlign=center', 140, 100);
        c.textAlign = "right";
        c.fillText('textAlign=right', 140, 120);

    }
</Script>

<p>Now let's learn the different <Span>textBaseline</Span> values you can use 
to <Span>align</Span> text <Span>vertically</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-7');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";
c.textAlign = "start";

c.textBaseline = "top";
c.fillText('Top', 30, 70);
c.textBaseline = "bottom";
c.fillText('Bottom', 60, 70);
c.textBaseline = "middle";
c.fillText('Middle', 110, 70);
c.textBaseline = "alphabetic";
c.fillText('Alphabetic', 157, 70);
c.textBaseline = "hanging";
c.fillText('Hanging', 230, 70);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-7" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-7');
        let c = canvas.getContext('2d');

        background(c);

        c.fillStyle = "red";
        c.fillRect(30, 70, 258, 1);

        c.fillStyle = "black";
        c.font = "normal 15px Arial";
        c.textAlign = "start";

        c.textBaseline = "top";
        c.fillText('Top', 30, 70);
        c.textBaseline = "bottom";
        c.fillText('Bottom', 60, 70);
        c.textBaseline = "middle";
        c.fillText('Middle', 110, 70);
        c.textBaseline = "alphabetic";
        c.fillText('Alphabetic', 157, 70);
        c.textBaseline = "hanging";
        c.fillText('Hanging', 230, 70);

    }
</script>

<p>Next let's talk about <Span>direction</Span> property, this one is 
still <Span>experimental</Span>, and is not supported by <Span>Firefox</Span> and 
<Span>Internet Explorer</Span>, this <Span>property</Span> allows us to specify the 
<Span>direction</Span> to draw the <Span>text</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-8');
let c = canvas.getContext('2d');

c.fillStyle = "black";
c.font = "normal 15px Arial";

c.direction = "ltr";
c.fillText("left to right!", 100, 40);
c.direction = "rtl";
c.fillText("right to left!", 100, 60);
c.direction = "inherit";
c.fillText("inherit from canvas!", 100, 80)</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-8" class="canvas"></canvas>

<Script>
    if(true){
        let canvas = document.querySelector('#canvas-8');
        let c = canvas.getContext('2d');

        background(c);
        
        c.fillStyle = "black";
        c.font = "normal 15px Arial";
 
        c.direction = "ltr";
        c.fillText("left to right!", 100, 40);
        c.direction = "rtl";
        c.fillText("right to left!", 100, 60);
        c.direction = "inherit";
        c.fillText("inherit from canvas!", 100, 80)

    }
</Script>

<P>Lastly, let's talk about how we can <Span>measure</Span> the 
<Span>text</Span> to get it's <Span>width</Span> or 
<Span>height</Span> using <Span>measureText(text)</Span> method:</P>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-9');
let c = canvas.getContext('2d');

let txt = "Hello World"

console.log(c.measureText(txt));

c.font = "normal 30px Arial";
c.fillStyle = "red";

c.fillText(txt, 90, 90)

console.log(c.measureText(txt));</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-9" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-9');
        let c = canvas.getContext('2d');

        background(c);

        let txt = "Hello World"

        console.log(c.measureText(txt));

        c.font = "normal 30px Arial";
        c.fillStyle = "red";

        c.fillText(txt, 90, 90)

        console.log(c.measureText(txt));
    }
</script>

<p>Here are the logs, as you can see, the <Span>width</Span> changed after I set 
the <Span>font</Span>:</p>
<img src="../images/Ï1.JPG">


<p>Let's now make a little project for practice:</p>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;canvas id="canvas-10" class="canvas">&lt;/canvas>

&lt;p style="
width: 500px; 
text-align: left; 
margin: auto;
">
&lt;input type="text" id="inputc" value="Insert text">
&lt;/p></Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-10');
let c = canvas.getContext('2d');
let input = document.querySelector('#inputc');

let txt = "Insert text";
c.font = "normal 15px Arial";
c.fillStyle = "black";
c.fillText(txt, 20, 50);
let width = c.measureText(txt).width;
let txt2 = `Text Width: ${width}px`
c.fillText(txt2, 20, 100);
let width2 = c.measureText(txt2).width;

input.addEventListener('input', (e) => {
    c.clearRect(20, 37, width, 18);
    c.clearRect(20, 87, width2, 18);
    txt = input.value;
    width = c.measureText(txt).width;
    c.fillText(txt, 20, 50);
    txt2 = `Text Width: ${width}px`
    c.fillText(txt2, 20, 100);
    width2 = c.measureText(txt2).width;
});</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-10" class="canvas"></canvas>

<p style="
width: 500px; 
text-align: left; 
margin: auto;
">
<input type="text" id="inputc" value="Insert text">
</p>

<p>Here is a video that helped me a lot, watch it if you want and subscribe to 
    the guy, his tutorials have helped me countless of times:</p>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-10');
        let c = canvas.getContext('2d');
        let input = document.querySelector('#inputc');

        let txt = "Insert text";
        c.font = "normal 15px Arial";
        c.fillStyle = "black";
        c.fillText(txt, 20, 50);
        let width = c.measureText(txt).width;
        let txt2 = `Text Width: ${width}px`
        c.fillText(txt2, 20, 100);
        let width2 = c.measureText(txt2).width;

        input.addEventListener('input', (e) => {
            c.clearRect(20, 37, width, 18);
            c.clearRect(20, 87, width2, 18);
            txt = input.value;
            width = c.measureText(txt).width;
            c.fillText(txt, 20, 50);
            txt2 = `Text Width: ${width}px`
            c.fillText(txt2, 20, 100);
            width2 = c.measureText(txt2).width;
        });
       
    }
</script>


<iframe src="https://www.youtube.com/embed/qMPifeAMo7k" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="seven">
    <header>
        <h1>Linear Gradients in Canvas</h1>
    </header>

    <p>The <Span>createLinearGradient()</Span> method creates a <Span>linear gradient object</Span>. This 
    <Span>gradient</Span> can later be used to <Span>fillStyle</Span> and <Span>strokeStyle</Span> properties.</p>

    <p>The <Span>createLinearGradient(x0, y0, x1, y1)</Span> method takes <Span>four parameters</Span>, which define the 
    <Span>start point</Span> and <span>end point</span> of the <span>gradient</span>, inside the 
<Span>gradient object</Span> that is returned by the <Span>createLinearGradient()</Span> method 
there is a <Span>method</Span>:</p>

    <canvas id="canvas-01" height="1"></canvas>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-01');
let c = canvas.getContext("2d");

let gradient = c.createLinearGradient(10, 10, 10, 190);

console.log(gradient);</span></p>

<p class="left">Outcome:</p>

    <script>
        if(true){
            let canvas = document.querySelector('#canvas-01');
            let c = canvas.getContext("2d");

            let gradient = c.createLinearGradient(10, 10, 10, 190);

            console.log(gradient);
        }
    </script>

    <img src="../images/Ï4.JPG">

    <p>To add <Span>colors</Span> to the <Span>linear gradient</Span> you will need to use the <span>addColoStop()</span> methods 
    which takes <span>two parameters</span>, the <Span>first parameter</Span> defines the 
<Span>position</Span> and the <span>second parameter</span> the <span>color</span>. The <span>first parameter</span> should 
take a value between <Span>0</Span> and <Span>1</Span>, where <Span>0.5</Span> represents <Span>50%</Span> and <Span>1</Span> 
represents <Span>100%</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById("canvas-02");
let c = canvas.getContext('2d');

let gradient = c.createLinearGradient(50,50,50,100);
gradient.addColorStop(0, 'red')
gradient.addColorStop(0.5, 'blue');
gradient.addColorStop(1, 'green');

c.fillStyle = gradient;
c.fillRect(50, 50, 100, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-02"></canvas>

<script>
    if(true){
        let canvas = document.getElementById("canvas-02");
        let c = canvas.getContext('2d');

        let gradient = c.createLinearGradient(50,50,50,100);
        gradient.addColorStop(0, 'red')
        gradient.addColorStop(0.5, 'blue');
        gradient.addColorStop(1, 'green');

        background(c);

        c.fillStyle = gradient;
        c.fillRect(50, 50, 100, 50);


    }
</script>

<p>The <Span>createLinearGradient()</Span> creates the <Span>direction</Span> and <Span>size</Span> of 
the <Span>gradient</Span>, if we were to change the <span>end point</span> to <Span>150, 100</Span> then 
the <span>direction</span> of the <Span>gradient</Span> would be from the <Span>top left</Span> of the 
<Span>rectangle</Span> towards the <Span>bottom right</Span> side of the <Span>rectangle</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10"> let canvas = document.getElementById("canvas-03");
let c = canvas.getContext('2d');

let gradient = c.createLinearGradient(50,50,150,100);
gradient.addColorStop(0, 'red')
gradient.addColorStop(0.33, 'red');
gradient.addColorStop(0.34, 'blue');
gradient.addColorStop(0.70, 'blue');
gradient.addColorStop(0.701, 'green');
gradient.addColorStop(1, 'green');

c.fillStyle = gradient;
c.fillRect(50, 50, 100, 50);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-03"></canvas>

<script>
    if(true){
        let canvas = document.getElementById("canvas-03");
        let c = canvas.getContext('2d');

        let gradient = c.createLinearGradient(50,50,150,100);
        gradient.addColorStop(0, 'red')
        gradient.addColorStop(0.33, 'red');
        gradient.addColorStop(0.34, 'blue');
        gradient.addColorStop(0.70, 'blue');
        gradient.addColorStop(0.701, 'green');
        gradient.addColorStop(1, 'green');

        background(c);

        c.fillStyle = gradient;
        c.fillRect(50, 50, 100, 50);


    }
</script>

<iframe src="https://www.youtube.com/embed/RlilYyjLF78" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="eight">
    <header>
        <h1>Canvas Transforms</h1>
    </header>

    <p>So, using <Span>CSS</Span> we can set the <Span>width</Span> and 
    <Span>height</Span> of the <Span>viewport</Span>, and using <Span>width</Span> and 
<Span>height</Span> attributes, either by hand either through <span>JavaScript</span> we can 
define the <Span>pixels</Span> inside the <Span>viewport</Span>. In this 
section we will learn more ways to <Span>customize</Span> the <Span>canvas grid</Span>. With <Span>transformations</Span> 
you can <Span>translate</Span> the <Span>0, 0</Span> point to a different position, 
<Span>rotate</Span> the grid and even <Span>scale</Span> it.</p>

<h2><u>Translating:</u></h2>

<p>The first of the <span>transformation methods</span> we will look at 
is <Span>translate()</Span>. This <span>method</span> is used to <Span>move</Span> the 
<Span>canvas and it's origin</Span> to a different point in the <Span>grid.</Span></p>

<p>The <Span>translate(x, y)</Span> methods <Span>moves the canvas and it's origin</Span> 
on the <Span>grid</Span>. The <Span>first parameter</Span> indicates the 
<Span>horizontal distance to move</Span>, and the <Span>second parameter</Span> indicates 
how far to <Span>move the grid vertically</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-05');
let c = canvas.getContext('2d');

background(c);

c.translate(100, 100);

c.fillStyle = "red";

c.beginPath();
c.arc(0, 0, 3, 0, 2 * Math.PI, false);
c.moveTo(20, 20);
c.arc(20, 20, 3, 0, 2 * Math.PI, false);
c.stroke();
c.fill()</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-05"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-05');
        let c = canvas.getContext('2d');

        background(c);

        c.translate(100, 100);
        
        c.fillStyle = "red";

        c.beginPath();
        c.arc(0, 0, 3, 0, 2 * Math.PI, false);
        c.moveTo(20, 20);
        c.arc(20, 20, 3, 0, 2 * Math.PI, false);
        c.stroke();
        c.fill()

    }
</script>

<h2><u>Rotating:</u></h2>
<p>The second <Span>transformation method</Span> I wanna talk about is 
<Span>rotate()</Span>. We use it to <Span>rotate</Span> the <Span>canvas</Span>
around the current <Span>origin</Span>.</p>

<p>The <Span>rotate(angle)</Span> method <Span>rotates</Span> the canvas <Span>clockwise</Span> 
around the <Span>current origin</Span> by the <Span>angle number of radians</Span>.</p>

<img src="../images/Î¼2.png">

<p>The <Span>rotation center point</Span> is always the <Span>canvas origin</Span>. To 
<span>change the center point</span>, we will need to <Span>move the canvas</Span> by 
using the <Span>translate()</Span> method.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById("canvas-06");
let c = canvas.getContext('2d');

c.translate(0, 0);
background(c);

c.fillStyle = 'red';
c.font = 'normal 15px Arial';

c.translate(100, 50);
c.rotate(135 * Math.PI / 180);

c.fillText('Hello World!', 0, 0);
c.fillRect(0, 10, 85, 5);</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-06"></canvas>

<Script>
    if(true){
        let canvas = document.getElementById("canvas-06");
        let c = canvas.getContext('2d');

        c.translate(0, 0);
        background(c);

        c.fillStyle = 'red';
        c.font = 'normal 15px Arial';

        c.translate(100, 50);
        c.rotate(135 * Math.PI / 180);

        c.fillText('Hello World!', 0, 0);
        c.fillRect(0, 10, 85, 5);

    }
</Script>

<h2><u>Scaling:</u></h2>

<p>The next <Span>transformation method</Span> is <span>scaling</span>. We use this to <Span>increase</Span> or <Span>decrease</Span>
the <Span>units</Span> in our <span>canvas grid</span>. This can 
be used to draw <Span>scaled down</Span> or <span>enlarged</span> shapes and bitmaps.</p>

<p>The <span>scale(x, y)</span> method <Span>scales</Span> the <Span>canvas units</Span> by 
<Span>x horizontally</Span> and by <Span>y vertically</Span>. Both parameters are real numbers. 
Values that are <Span>smaller than 1.0</Span> will <Span>reduce the unit size</Span> and 
values <Span>above 1.0</Span> will <Span>increase the unit size</Span>. Values of <Span>1.0</Span> will 
<Span>leave the units the same size</Span>.</p>

<p>Using <span>negative numbers</span> will <Span>flip the shape</Span> and 
do <span>axis mirroring</span>, here are some example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-07');
let c = canvas.getContext('2d');

background(c);

c.save();
   c.scale(2, 2);
   c.fillRect(10, 10, 25, 25);
c.restore();

c.font = 'normal 20px Arial';
c.fillStyle = 'black';

c.save();
   c.translate(200, 50);
   c.scale(-1, 1);
   c.fillText('Hello World!', 0, 0);
c.restore();

c.save();
   c.translate(200, 100);
   c.scale(-1, 1);
   c.fillText('Hello People!', 0, 0)
c.restore();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-07"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-07');
        let c = canvas.getContext('2d');

        background(c);

        c.save();
           c.scale(2, 2);
           c.fillRect(10, 10, 25, 25);
        c.restore();

        c.font = 'normal 20px Arial';
        c.fillStyle = 'black';
        
        c.save();
           c.translate(200, 50);
           c.scale(-1, 1);
           c.fillText('Hello World!', 0, 0);
        c.restore();

        c.save();
           c.translate(200, 100);
           c.scale(-1, 1);
           c.fillText('Hello People!', 0, 0)
        c.restore();
    }
</script>

<p>So, you are probably wondering now what does <Span>save()</Span> and <Span>restore()</Span> do, and that's what 
I'm gonna talk about next.</p>

<h2><u>Saving and restoring state:</u></h2>

<p><Span>Canvas states</Span> are <span>stored</span> on a <Span>stack</Span>. Every time the <Span>save()</Span> method is called, 
the <span>current drawing state</span> is <Span>pushed onto the stack</Span>. A <Span>drawing state</Span> consists of:</p>

<div class="list_container">
    <ul>
        <li>The transformations that have been applied (i.e. translate, rotate 
            and scale)
        </li>
        <li>The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, 
            lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, globalCompositeOperation, font, textAlign, textBaseline, direction, 
            imageSmoothingEnabled.
        </li>
        <li>The current clipping path.</li>
    </ul>
</div>

<p>I still haven't talked about some of the stuff listed in the list, I will try and 
write about these later on my notes.
</p>

<p>You can call the <span>save()</span> method as many times as you like, Each time the <Span>restore()</Span>
method is called, the <Span>last saved state</Span> is <Span>popped off</Span> the 
<Span>stack</Span> and <Span>all saved settings are restored</Span>.</p>
    <iframe src="https://www.youtube.com/embed/5vxygxshTQ4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="nine">
    <header>
        <h1>Stroke properties</h1>
    </header>

    <p>In this section I want to talk some more about 
        <Span>strokes</Span>, there are a few <Span>properties</Span>
        out there that can be used to <span>decorate strokes</span>, 
        here is a list of all the properties I will explain in the
        section:
    </p>

    <div class="list_container">
        <dl>
            <dt><span>strokeStyle = 'color'</span></dt>
            <dd>strokeStyle property sets the color of the line. <br><br>
            </dd>
            <dt><span>lineWidth = number</span></dt>
            <dd>lineWidth property sets the width of the line. <br><br></dd>
            <dt><Span>lineCap = 'style'</Span></dt>
            <dd>linecap property is used to get or set the line cap style. 
                There are three cap styles, butt, round and square.
                <ul>
                    <li>butt: Default. A flat edge is put perpendicular to each 
                        end of the line with no cap added.
                    </li>
                    <li>round: A semicircle or rounded end cap is added to each end of the line.</li>
                    <li>square: A square end cap is added to each end of the line.</li>
                </ul>
            </dd>
            <dt><Span>lineJoin = 'type'</Span></dt>
            <dd>lineJoin property is used to get or set the type of corner that 
                is created when two lines join. There are three values, bevel, round and square.
                <ul>
                    <li>bevel: A filled triangle connects the two lines that are joined, creating a 
                        beveled corner.
                    </li>
                    <li>round: Lines join with a rounded corner.</li>
                    <li>miter: Default, lines join with a smoothly mitered corner.</li>
                </ul>
            </dd>
            <dt><span>setLineDash([array])</span></dt>
            <dd>The setLineDash() method sets the line dash pattern used when stroking lines, It uses an 
                array of values the specify alternating lengths of lines and gaps which describe the pattern.
            </dd>
            <dt><span>lineDashOffset = value</span></dt>
            <dd>lineDashOffset property sets the line dash offset. It's value 
                should be a float specifying the amount of the line dash offset. The default 
                value is 0.0 <br><br>
            </dd>
            <dt><Span>miterLimit = number</Span></dt>
            <dd>The miterLimit property sets or returns the maximum 
                miter length.
            </dd>
        </dl>
    </div>

    <p>So, I have already told about <span>lineWidth</span> and 
    <span>lineStyle</span> before, and there really isn't much about them anyway, 
couldn't be any simplier, so let's skip those two and get started with the 
<Span>lineCap</Span> property first, lets take a loo kat the different 
kind of <Span>line cap styles</Span> we can use:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-08');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';

c.lineCap = 'butt';

    c.beginPath();
    c.moveTo(50, 120);
    c.lineTo(50, 30);
    c.stroke();

c.lineCap = 'round';

    c.beginPath();
    c.moveTo(120, 120);
    c.lineTo(120, 30);
    c.stroke();

c.lineCap = 'square';

    c.beginPath();
    c.moveTo(190, 120);
    c.lineTo(190, 30);
    c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-08" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-08');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        
        c.lineCap = 'butt';

            c.beginPath();
            c.moveTo(50, 120);
            c.lineTo(50, 30);
            c.stroke();

        c.lineCap = 'round';

            c.beginPath();
            c.moveTo(120, 120);
            c.lineTo(120, 30);
            c.stroke();
        
        c.lineCap = 'square';

            c.beginPath();
            c.moveTo(190, 120);
            c.lineTo(190, 30);
            c.stroke();
    }
</script>

<p>The reason I had to create different <Span>paths</Span> is because only 
one <Span>style</Span> can be applied to the <Span>final shape</Span> made by the 
<Span>path</Span>, I could not create the <Span>three lines</Span> in <Span>one path</Span> 
and change the <Span>lineCap</Span> property for each, because only the <Span>final value</Span> 
I wrote would be used for the <span>path</span>.</p>

<p>Let's now check <Span>lineJoin</Span> property and the different <Span>types</Span> 
that can be used:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-09');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';

c.lineJoin = 'bevel';

    c.beginPath();
    c.moveTo(40, 120);
    c.lineTo(80, 120);
    c.lineTo(80, 30);
    c.lineTo(60, 50);
    c.stroke();

c.lineJoin = 'round';

    c.beginPath();
    c.moveTo(120, 120);
    c.lineTo(160, 120);
    c.lineTo(160, 30);
    c.lineTo(140, 50);
    c.stroke();

c.lineJoin = 'miter';

    c.beginPath();
    c.moveTo(200, 120);
    c.lineTo(240, 120);
    c.lineTo(240, 30);
    c.lineTo(220, 50);
    c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-09" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-09');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        
        c.lineJoin = 'bevel';

            c.beginPath();
            c.moveTo(40, 120);
            c.lineTo(80, 120);
            c.lineTo(80, 30);
            c.lineTo(60, 50);
            c.stroke();

        c.lineJoin = 'round';

            c.beginPath();
            c.moveTo(120, 120);
            c.lineTo(160, 120);
            c.lineTo(160, 30);
            c.lineTo(140, 50);
            c.stroke();
        
        c.lineJoin = 'miter';

            c.beginPath();
            c.moveTo(200, 120);
            c.lineTo(240, 120);
            c.lineTo(240, 30);
            c.lineTo(220, 50);
            c.stroke();
    }
</script>

<p>Since we just learned about the <span>miter</span> value of <Span>lineJoin</Span>, lets now 
talk about the <Span>miterLimit</Span> property.</p>

<p>The <Span>miterLimit</Span> property <span>sets</span> or 
<Span>returns</Span> the <Span>maximum miter length</Span>. The <Span>miter length</Span> is 
the <Span>distance</Span> between the <span>inner corner</span> and the <Span>outer corner</Span> where 
<Span>two lines meet</Span>.</p>

<img src="../images/Î¾1.png">

<p>The <Span>miterLimit</Span> property works only if the <Span>lineJoin</Span> property is 
<Span>miter</Span>. The miter length <Span>grows bigger</Span> as the <span>angle of the corner gets smaller</span>.</p>

<p>To <Span>prevent</Span> the <Span>miter length</Span> from being too long, we can use 
the <span>miterLimit</span> property.</p>

<P>If the <span>miter length exceeds</span> the <Span>miter limit value</Span>, the 
<Span>corner</Span> will be displayed as <Span>lineJoin type 'bevel'</Span>.</P>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-idk');
let c = canvas.getContext('2d');

background(c);

function draw(x, y, y2){
    c.beginPath();
    c.moveTo(x, y);
    c.lineTo(x + 40, y);
    c.lineTo(x, y2);
    c.stroke(); 
}

c.lineWidth = 10;        
c.lineJoin = 'miter';
c.miterLimit = Number.POSITIVE_INFINITY;
c.strokeStyle = 'green';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);

c.miterLimit = 5;
c.strokeStyle = 'red';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);

c.lineJoin = 'bevel';
c.strokeStyle = 'blue';

   draw(40, 80, 30);
   draw(120, 80, 65);
   draw(200, 80, 120);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-idk" class="canvas"></canvas>

<script>
    if(true){
        let canvas = document.querySelector('#canvas-idk');
        let c = canvas.getContext('2d');

        background(c);

        function draw(x, y, y2){
            c.beginPath();
            c.moveTo(x, y);
            c.lineTo(x + 40, y);
            c.lineTo(x, y2);
            c.stroke(); 
        }

        c.lineWidth = 10;        
        c.lineJoin = 'miter';
        c.miterLimit = Number.POSITIVE_INFINITY;
        c.strokeStyle = 'green';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);

        c.miterLimit = 5;
        c.strokeStyle = 'red';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);

        c.lineJoin = 'bevel';
        c.strokeStyle = 'blue';

           draw(40, 80, 30);
           draw(120, 80, 65);
           draw(200, 80, 120);
           
    }
</script>

<p>So, in the example above, you can see how when <Span>miterLimit</Span>
is set to <span>5</span>, the <Span>middle lines</Span> use <span>bever type</span>
to connect, because the <Span>miter length</Span> extends <Span>5 pixels</Span>, while 
the others which don't are drawn without a problem.</p>


<p>Now, let's try <Span>setLineDash()</Span> method and <Span>lineDashOffSet</Span> property:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvas-010');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 10;
c.strokeStyle = 'red';
c.lineCap = 'butt';

c.setLineDash([20, 5, 10, 5]);
    c.beginPath();
    c.moveTo(40, 40);
    c.lineTo(200, 40);
    c.stroke();

c.setLineDash([20, 5, 20]);
     c.beginPath();
    c.moveTo(40, 80);
    c.lineTo(200, 80);
    c.stroke();

c.setLineDash([20, 5, 20]);
c.lineDashOffset = 25;
    c.beginPath();
    c.moveTo(40, 120);
    c.lineTo(200, 120);
    c.stroke();</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-010" class="canvas"></canvas>


<script>
    if(true){
        let canvas = document.querySelector('#canvas-010');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 10;
        c.strokeStyle = 'red';
        c.lineCap = 'butt';

        c.setLineDash([20, 5, 10, 5]);
            c.beginPath();
            c.moveTo(40, 40);
            c.lineTo(200, 40);
            c.stroke();

        c.setLineDash([20, 5, 20]);
             c.beginPath();
            c.moveTo(40, 80);
            c.lineTo(200, 80);
            c.stroke();

        c.setLineDash([20, 5, 20]);
        c.lineDashOffset = 25;
            c.beginPath();
            c.moveTo(40, 120);
            c.lineTo(200, 120);
            c.stroke();
    }
</script>

<p>So, I need you to understand what happens with the <Span>dash pattern</Span>, the <span>pattern</span> 
goes like this: <span>line</span>, <Span>gap</Span>, <Span>line</Span>, etc, 
when it reads the <Span>array</Span>, the <Span>array values</Span> are used on this 
<Span>pattern</Span>, when the <span>array values</span> are over, it <Span>reads the array again</Span> from the <Span>start</Span>. If 
the <Span>array values</Span> are an <Span>even number</Span>, then everything works as expected, 
if however it's a <Span>an odd number</Span>, then after the <Span>array values end</Span>, when it 
<Span>starts reading from the start</Span> of the <Span>array</Span> the 
<span>first value</span> will be used to create a <Span>gap</Span>, and the <Span>second</Span> to 
create the <Span>line</Span>, and so on, till it reaches the end again, then it will get back to normal for the 
next run.</p>

<p>The <span>lineDashOffset</span> is used to <Span>move</Span> the <Span>stroke</Span>, 
this can create great effects when used for <Span>animations</Span>, here is an example:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.querySelector('#canvas-011');
let c = canvas.getContext('2d');

background(c);

c.lineWidth = 5;
c.strokeStyle = 'red';
c.lineDashOffset = 0;

function draw(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    
    c.beginPath();
    c.moveTo(50, 50);
    c.lineTo(200, 50);
    c.lineTo(200, 120);
    c.lineTo(50, 120);
    c.closePath();
    c.stroke();
}

function march(){
    c.setLineDash([2,2]);
    c.lineDashOffset++;
    draw();
}

setInterval(march, 20);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-011" class="canvas"></canvas>


<script>
    if(true){
        let canvas = document.querySelector('#canvas-011');
        let c = canvas.getContext('2d');

        background(c);

        c.lineWidth = 5;
        c.strokeStyle = 'red';
        c.lineDashOffset = 0;

        function draw(){
            c.clearRect(0, 0, canvas.width, canvas.height);
            
            c.beginPath();
            c.moveTo(50, 50);
            c.lineTo(200, 50);
            c.lineTo(200, 120);
            c.lineTo(50, 120);
            c.closePath();
            c.stroke();
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function march(){
            c.setLineDash([2,2]);
            c.lineDashOffset++;
            draw();
        }

        function animation(){
            if(isScrolledIntoView(canvas)){
                march();
            }
            requestAnimationFrame(animation);
        }

        animation();
    }
</script>

</article>

<hr>

<article id="ten">
    <header>
        <h1>Canvas globalAlpha property</h1>
    </header>

    <p>The <Span>globalAlpha</Span> property <Span>sets</Span>
    or <Span>returns</Span> the current <Span>transparency value</Span> of the 
<Span>drawing</Span>.</p>

<p>The <Span>globalAlpha property value</Span> must be a <Span>number</Span> 
between <Span>0.0</Span> (fully transparent) and <Span>1.0</Span> (no transparancy).</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-012');
let c = canvas.getContext('2d');

background(c);
c.fillStyle = 'red';

c.globalAlpha = 0.8;

c.fillRect(50, 50, 50, 50);

c.globalAlpha = 0.5;

c.fillRect(135, 50, 50, 50);

c.globalAlpha = 1;

c.fillRect(220, 50, 50, 50);</Span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-012" class="canvas">
</canvas>

<Script>
    if(true){
        let canvas = document.getElementById('canvas-012');
        let c = canvas.getContext('2d');

        background(c);
        c.fillStyle = 'red';

        c.globalAlpha = 0.8;

        c.fillRect(50, 50, 50, 50);

        c.globalAlpha = 0.5;

        c.fillRect(135, 50, 50, 50);

        c.globalAlpha = 1;

        c.fillRect(220, 50, 50, 50);
    }
</Script>


</article>

<hr>

<article id ="eleven">
    <header>
        <h1>Using images</h1>
    </header>

<p>Until now we have created our own <Span>shapes</Span> and <Span>applied styles</Span>
to them. One of the more exciting feautures of <Span>canvas</Span> is the ability to use 
<Span>images</Span>. <span>External images</span> can be used in any format supported by the browser, 
such as <Span>PNG</Span>, <span>GIF</span>, or <Span>SJPEG</Span>. You can even use 
the <Span>image</Span> produced by other <Span>canvas elements</Span> on the same 
page as the <Span>source</Span>.</p>

<p><span>Importing images</span> into a <Span>canvas</Span> is basically a <Span>two step process</Span>:</p>

<div class="list_container" style="background-color: unset; border: unset;">
<ol>
    <li>Get a reference to an <Span>HTMLImageElement object</Span> or 
    <span>another canvas element</span> as a <Span>source</Span>. It is also possible to use <Span>images</Span> by 
prividing a <span>URL</span>.</li>
<li>Draw the <span>image</span> on the <Span>canvas</Span> using the <Span>drawImage()</Span> function.</li>
</ol>
</div>

<h2><u>Getting images to draw:</u></h2>

<p>The <Span>canvas API</Span> is able to use any of the following <span>data types</span> 
as an <Span>image source</Span>:</p>

<div class="list_container">
    <dl>
        <dt><Span>HTMLImageElement</Span></dt>
        <dd>These are images created using the Image() constructor, as well as any &lt;img> element.</dd>
        <dt><Span>SVGImageElement</Span></dt>
        <dd>These are images embedded using the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image">&lt;image></a> element of SVG.</dd>
        <dt><span>HTMLVideoElement</span></dt>
        <dd>Using an HTML &lt;video> element as your image source grabs the current frame from the video and uses it as an image.</dd>
        <dt><Span>HTMLCanvasElement</Span></dt>
        <dd>You can use another &lt;canvas> element as your image source.</dd>
    </dl>
</div>

<p>There are several ways to get <Span>images</Span> for use on a <Span>canvas</Span>.</p>

<h2><u>Using images from the same page:</u></h2>

<p>We can obtain a <Span>reference</Span> to <Span>images on the same page</Span> as 
the <Span>canvas</Span> by using one of the following methods:</p>

<div class="list_container">
    <ul>
        <li>The <span>document.images</span> collection</li>
        <li>The <Span>document.getElementsByTagName()</Span> method</li>
        <li>If you know the ID of the specific image you wish to use, you can 
            use <Span>document.getElementById()</Span> to retrieve that specific image.
        </li>
    </ul>
</div>

<p>I have already talked about <span>getElementsByTagName()</span> and 
<span>getElementsById()</span> methods before in my notes, I have never 
mentioned <Span>images</Span> property however, this property of the <span>Document object</span> returns a 
<Span>collection ot the images</Span> in the <Span>current HTML document</Span>. Let's try this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">console.dir(document.images);</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        console.dir(document.images);
    }
</script>

<img src="../images/Ï1.JPG">

<p>Those <Span>image objects</Span> contain a lot of <Span>properties</Span> inside them, 
so you could use an <span>array method</span> such as <Span>filter</Span> to only get 
a specific <Span>image</Span>, if for example you want to check for their <Span>name</Span> 
you could use a <Span>regular expression</Span> and select it from the <span>outerHTML</span> property which contains 
a <Span>string</Span> of the <Span>outer HTML of the image</Span>.</p>

<h2><u>Using images from other domains:</u></h2>

<p>Using the <span>crossorigin attribute</span> of an <span>&lt;img></span> element (reflected by the 
<Span>HTMLImageElement.crossOrigin property</Span>), you can request permission to load 
an <Span>image</Span> from <span>another domain</span> for use in your call to <span>drawImage()</span>. If the hosting domain permits cross-domain access 
to the <Span>image</Span>, the <span>image</span> can be used in your <span>canvas</span> without tainting it, otherwise using the <Span>image</Span> will <Span>taint the canvas</Span>.</p>

<p>I have talked about the <Span>crossorigin attribute</Span> <a href="../HTML-Notes/HTML_Extra_1.html#one">here</a>, 
if you want to learn the different values you can use for this attribute check this out.</p>

<h2><u>Using other canvas elements:</u></h2>

<p>Just as with <Span>normal images</Span>, we can access other <Span>canvas elements</Span> using 
either <Span>document.getElementsByTagName()</Span> or <Span>document.getElementById()</Span>
method. Be sure you've drawn something to the <Span>source canvas</Span> before using it in your 
<Span>target canvas</Span>.</p>

<p>One of the more practical uses of this would be to use a <Span>second canvas element</Span>
as a <Span>thumbnail view</Span> of the <Span>other larger canvas</Span>.</p>

<h2><u>Creating an image from scratch:</u></h2>

<p>Another option is to create a new <span>HTMLImageElement</span> object in our script. To 
do this, you can use the convenient <Span>Image() constructor</Span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/example.png';

console.log(img);
console.dir(img);</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        let img = new Image();
        img.src = '../images/example.png';

        console.log(img);
        console.dir(img);
    }
</script>

<img src="../images/Ï3.png">

<p>When this script gets executed, the <span>image</span> starts loading.</p>

<p>If you try to call <Span>drawImage()</Span> before the <Span>image has finished loading</Span>, it won't do anything (or in older browsers, may 
even throw an exception). So you need to be sure to use the <Span>load event</Span> so you don't try this before the <span>image</span> has loaded.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">var img = new Image();
img.src = ../images/example.png';
img.addEventListener('load', function(e){
    <Span class="gray">// execute drawImage statements here</Span>
});
</Span></p>

<p>This should work fine when working with only <Span>one image</Span>, what if you 
are using <Span>multiple images</Span> though? How do you make sure all of them have loaded?
One simple way would be to add all your <Span>images</Span> directly into your 
<span>HTML code</span> using <Span>&lt;image></Span> tag, you could put all of them 
inside a <Span>div</Span> and then <Span>hide it</Span> with <span>CSS</span>, after you do so 
you could simple use <Span>window.addEventListener('load', function(){})</Span>.</p>

<p>If you however want to create the <Span>images</Span> with <Span>JavaScript</Span>, a code like 
this should do the job:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let imgToLoad = 3, imgLoaded = 0;
        
function onImgLoad(){
    imgLoaded++;
    if(imgLoaded == imgToLoad){
        <Span class="gray">//execute draw image statements here</Span>
    }
}

img1 = new Image();
img1.src = ../images/example.png';

img2 = new Image();
img2.src = ../images/example2.png';

img3 = new Image();
img3.src = ../images/example3.png';

let arr = [img1, img2, img3];

arr.forEach((img) => {
    img.addEventListener('load', onImgLoad);
});</Span></p>

<p class="left">Outcome:</p>

<script>
    if(true){
        let imgToLoad = 3, imgLoaded = 0;
            
        function onImgLoad(){
            imgLoaded++;
            if(imgLoaded == imgToLoad){
                //execute draw image statements here
            }
        }

        img1 = new Image();
        img1.src = '../images/example.png';
        
        img2 = new Image();
        img2.src = '../images/example2.png';

        img3 = new Image();
        img3.src = '../images/example3.png';

        let arr = [img1, img2, img3];

        arr.forEach((img) => {
            img.addEventListener('load', onImgLoad);
        });
    }
</script>

<h2><u>Drawing images:</u></h2>

<p>Once we have a <Span>reference</Span> to our <span>source image object</span> 
we can use the <span>drawImage()</span> method to <Span>render it</Span> to the <span>canvas</span>. 
As we will see later the <span>drawImage()</span>  ethod is overloaded and has several variants. In it's most 
basic form it looks like this: <Span>drawImage(image, x, y)</Span> but it can take up to 
<Span>nine parameters</Span>, and the way the parameters work change depending on how many are used, we will 
go over all that here in this section.</p>

<p>Let's try to draw our first <Span>image</Span> now, using those 
<span>three first parameters</span> only:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/example.png';

let canvas = document.getElementById('canvas-013');
let c = canvas.getContext('2d');

img.addEventListener('load', (e) => {
    canvas.width = '600';
    canvas.height = '200';

    c.drawImage(img, 0, -115);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-013"></canvas>

<script>
    if(true){

        let img = new Image();
        img.src = '../images/example.png';

        let canvas = document.getElementById('canvas-013');
        let c = canvas.getContext('2d');

        img.addEventListener('load', (e) => {
            canvas.width = '600';
            canvas.height = '200';

            c.drawImage(img, 0, -115);
        });

    }
</script>

<p>The <Span>image</Span> was <Span>too big</Span> so I had to change the <Span>size of the canvas</Span> in order to 
fit it inside, wouldn't that be great if we could <Span>scale it?</Span>, well, we can! The 
<span>two next parameters</span> do just that:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let img = new Image();
img.src = ../images/phoenix.png';

let canvas = document.getElementById('canvas-014');
let c = canvas.getContext('2d');

img.addEventListener('load', (e) => {
    c.drawImage(img, 40, 30, 200, 100);
    background(c);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-014"></canvas>

<script>
    if(true){

        let img = new Image();
        img.src = '../images/phoenix.png';

        let canvas = document.getElementById('canvas-014');
        let c = canvas.getContext('2d');

        img.addEventListener('load', (e) => {
            c.drawImage(img, 40, 30, 200, 100);
            background(c);
        });

    }
</script>

<p>So, now, if we add the next <Span>four parameters</Span> the <Span>drawImage()</Span> 
method will work different than expected, we would normally expect that those <Span>four new parameters</Span> 
would be the <Span>last four parameters</Span>, but they are not, if more than <Span>five parameters</Span> are added, 
then the order of the <span>parameters</span> changes a little, so, till now it was like this: 
<Span>(source, xPosition, yPosition, xScale, yScale)</Span>, if <Span>more parameters are added</Span> then 
it changes to be like this: <Span>(source, xSlice, ySlice, xSliceScale, ySliceScale, positionX, positionY, scaleX, scaleY)</Span>.</p>

<p>So, the <Span>first parameter</Span> and <Span>last four parameters</Span> are the same as before, 
but between them there are <Span>four new parameters</Span> added, those <Span>new parameters</Span> allow us 
to <Span>slice the image</Span>, so that we only use <Span>a part of the image</Span> inside of using the whole image, 
here is an example:</p>

<p>Let's use this image and use a <Span>loop</Span> to place <Span>grass tiles</Span> all over the 
<Span>canvas</Span>:</p>

<img src="../images/Ï4.png" id="imageAA">

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let image = document.getElementById('imageAA');
let canvas = document.getElementById('canvas-015');
let c = canvas.getContext('2d');

image.addEventListener('load', (e) => {
    for(i = 0; i &lt;= 12; i++){
        for(j = 0; j &lt;= 6; j++){
            c.drawImage(image, 80, 40, 40, 50, i * 25, j * 25, 25, 25);
        }
    }
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-015"></canvas>

<script>
    if(true){
        let image = new Image();
        image.src = '../images/Ï4.png';
        let canvas = document.getElementById('canvas-015');
        let c = canvas.getContext('2d');

        image.addEventListener('load', (e) => {
            for(i = 0; i <= 12; i++){
                for(j = 0; j <= 6; j++){
                    c.drawImage(image, 80, 40, 40, 50, i * 25, j * 25, 25, 25);
                }
            }
        });
    }
</script>

<p>Here is a video that may help you undersand <Span>imageDraw()</Span> method better:</p>
<iframe src="https://www.youtube.com/embed/jEUuM5bRAzw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Before I finish with this section I want to also talk about one more 
    property, the <Span>imageSmoothingEnabled = boolean</Span> property, whic is used to 
    control the use of <Span>image smoothing algorithms when scaling images</Span>. By default, it is <Span>true</Span>, meaning <Span>images</Span>
    will be <Span>smoothed when scaled</Span>. You can disable this future by setting the property to <Span>false</Span>:
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-016');
let c = canvas.getContext('2d');

let img = new Image();
img.src = ../images/phoenix.png';

background(c);

img.addEventListener('load', (e) => {
    c.drawImage(img, 20, 40, 120, 80);
    c.imageSmoothingEnabled = false;
    c.drawImage(img, 160, 40, 120, 80);
});</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-016"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-016');
        let c = canvas.getContext('2d');

        let img = new Image();
        img.src = '../images/phoenix.png';

        background(c);

        img.addEventListener('load', (e) => {
            c.drawImage(img, 20, 40, 120, 80);
            c.imageSmoothingEnabled = false;
            c.drawImage(img, 160, 40, 120, 80);
        })
    }
</script>

<h2><u>How to find the aspect ratio of an image:</u></h2>

<P>Let's now learn how to <Span>resize images</span> but <span>keep the original aspect ratio</span>, something useful 
if you want your <Span>images</span> to have good quality. First, in order to find the <Span>aspect ratio</span> we 
are gonna do <Span>img.naturalWidth / img.naturalHeight</span>, after we have the <Span>ratio</span> we can choose 
a <Span>width</span> for our <span>image</span> and in order to find what the <Span>height</span> should we we simple 
do <Span>width / aspect ratio</span>, what if we want to choose a <Span>height</span> and find what the <span>width</span> 
should be? By using a little bit of algebra, we can assume that <Span>width = height * ratio</Span>, lets try this on our 
<span>canvas</span> to see if that's true.</p>

<p></p>By the way, you may wonder what <span>naturalWidth</span> and <span>naturalHeight</span> are 
and how they are different to <Span>width</Span>, <Span>height</Span>, <Span>clientWidth</span> and <Span>clientHeight</span>, 
the <Span>width and height</Span> give us the <Span>value of the width and height attribute</Span>, the <Span>clientWidth and clientHeight</Span>
give us the <span>width and height of the element</span>, if for example we had <Span>changed it's size using CSS</Span> then 
this would give us <span>the exact width and height it takes on the page</span>, while lastly, <Span>naturalWidth and naturalHeight</Span>
give us the <span>original width and height of the image</span>.</p>


<p class="left">JavaScript Code:</p>
<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0001');
let c = canvas.getContext('2d');

let img = new Image();
img.src = ../images/phoenix.png';

background(c);
c.imageSmoothingEnabled = true;

img.addEventListener('load', (e) => {
    let aspectRatio = img.naturalWidth / img.naturalHeight;
    c.drawImage(img, 0, 0, 120, 120 / aspectRatio);
    c.drawImage(img, 120, 0, 100 * aspectRatio, 100)
});</span></p>
<p class="left">Outcome:</p>
<canvas class="canvas" id="canvas-0001"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-0001');
        let c = canvas.getContext('2d');

        let img = new Image();
        img.src = '../images/phoenix.png';

        background(c);
        c.imageSmoothingEnabled = true;

        img.addEventListener('load', (e) => {
            let aspectRatio = img.naturalWidth / img.naturalHeight;
            c.drawImage(img, 0, 0, 120, 120 / aspectRatio);
            c.drawImage(img, 120, 0, 100 * aspectRatio, 100)
        });
    }
</script>

</article>

<hr>

<article id="twelve">
    <header>
        <h1>Animating the Canvas</h1>
    </header>

    <p>In this section I'm gonna talk about ways you can <Span>animate</Span> 
    the <Span>canvas</Span>, there isn't really much to say, since we are gonna use 
simple <Span>JavaScript</Span> code to get the wanted result, there is however one <Span>method</Span> 
I want to talk about, the <Span>Window.requestAnimationFrame()</Span> method.</p>

<p>The <Span>window.requestAnimationFrame()</Span> method tells the browser that you wish to perform an 
<Span>animation</Span> and requests that the browser calls a <Span>specified function</Span> to <Span>update an animation before the next repaint</Span>. 
The <Span>method</Span> takes a <Span>callback</Span> as an <Span>argument</Span> to be <Span>invoked</Span> before the 
<Span>repaint</Span>.</p>

<p>Your <Span>callack routine</Span> must it self call <Span>requestAnimationFrame()</Span> again 
if you want to <Span>animate another frame</Span> at the next repaint. <Span>requestAnimationFrmae()</Span> is 1 shot.</p>

<p>So, why use the <span>requestAnimationFrame()</span> method if we can just use <Span>setInterval</Span>? That's because <Span>requestAnimationFrame</Span> produces 
<Span>higher quality animation</Span> completely <Span>eliminating flicker</Span> and <Span>shear</Span> that can happen 
when using <Span>setInterval</Span>, and it also <Span>reduce or completely remove frame skips</Span>.</p>

<p>Here is a simple example of <Span>requestAnimationFrame()</Span> method so that 
you can see it's syntax:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let container = document.getElementById('ctainer');

let i = 0;

function example(){
    i++
    if(i &lt;= 3){
        container.innerHTML += 'Hello World!';
        requestAnimationFrame(example);
    } else {
        return false;
    }
}

example();</Span></p>

<p class="left">Outcome:</p>

<p style="text-align: left;" id="ctainer"></p>

<script>
    if(true){

        let container = document.getElementById('ctainer');
       
        let i = 0;

        function example(){
            i++
            if(i <= 3){
                container.innerHTML += 'Hello World!';
                requestAnimationFrame(example);
            } else {
                return false;
            }
        }

        example();

    }
</script>

<p>Let's create an <Span>animation</Span> on the <Span>canvas</Span> now:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-017');
let c = canvas.getContext('2d');

c.fillStyle = 'black';
c.strokeStyle = 'blue';

let circle = function(x, y, r, dx, dy){
    this.x = x;
    this.y = y;
    this.r = r;
    this.dx = dx;
    this.dy = dy;
    this.draw = function draw(){
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.animate = function animate(){
        if(this.x > canvas.width - r || this.x - this.r < 0){
            this.dx = -this.dx;
        } if(this.y > canvas.height - r || this.y - this.r < 0){
            this.dy = -this.dy;
        }
        this.x += this.dx;
        this.y += this.dy;
        this.draw();
    }
}

let array = new Array();

for(let i = 1; i <= 100; i++){
    let r = 10;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 2) + r;
    let dx = (Math.random() - 0.5) * 2;
    let dy = (Math.random() - 0.5) * 2;
    array.push(new circle(x, y, r, dx, dy));
}

let animation = function(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    array.forEach((circle) => {
        circle.animate();
    })
    requestAnimationFrame(animation);
}

animation();</span></p>

<p class="left">Outcome:</p>

<canvas class="canvas" id="canvas-017"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-017');
        let c = canvas.getContext('2d');

        c.fillStyle = 'black';
        c.strokeStyle = 'blue';

        let circle = function(x, y, r, dx, dy){
            this.x = x;
            this.y = y;
            this.r = r;
            this.dx = dx;
            this.dy = dy;
            this.draw = function draw(){
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.animate = function animate(){
                if(this.x > canvas.width - r || this.x - this.r < 0){
                    this.dx = -this.dx;
                } if(this.y > canvas.height - r || this.y - this.r < 0){
                    this.dy = -this.dy;
                }
                this.x += this.dx;
                this.y += this.dy;
                this.draw();
            }
        }
        
        let array = new Array();

        for(let i = 1; i <= 100; i++){
            let r = 10;
            let x = Math.random() * (canvas.width - r * 2) + r;
            let y = Math.random() * (canvas.height - r * 2) + r;
            let dx = (Math.random() - 0.5) * 2;
            let dy = (Math.random() - 0.5) * 2;
            array.push(new circle(x, y, r, dx, dy));
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            } 
        
        let animation = function(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                array.forEach((circle) => {
                    circle.animate();
                })
            }
            requestAnimationFrame(animation);
        }

        animation();
        
    }
</script>

<p>So, at first this may seem a little complicated, but it's more easy once you understand it, I created a 
    <Span>object constructor</Span> which has <span>five properties</span> inside, 
    the <Span>first two</Span> are used to set the <Span>x and y coordinates</Span>, 
    the <Span>third property</Span> sets the <Span>radius</Span> and the <Span>last two</Span> set 
    the <Span>speed of x and y</Span>, those will be added to the current <Span>x</Span>
    and <Span>y</Span> per every <Span>iteration</Span>, then I created a <Span>draw method</Span>, which simple 
    <Span>draws the circle on the canvas</Span> and then I created an <Span>animate method</Span> which 
    <Span>checks some conditions and updates x and y coordinates</Span>, then it <Span>draws the circles</Span> by executing 
    the <Span>draw method</Span> using the <Span>new coordinates</Span>. If the <Span>x</Span> reaches 
    the <Span>edge of the canvas</Span> I make it <Span>change direction</Span>, and when it 
    reaches the <Span>starting edge</Span> I make it <Span>change direction</Span> again, same goes for <Span>y</Span>.
</p>

<p>Alright, so far I have explained what the <span>methods</span> do, now let me explain what I did next, 
I used that <Span>constructor</Span> to create <Span>100 different circle objects</Span> inside an 
<Span>array</Span>, then I created a <Span>function</Span> that is <Span>executed again and again by requestAnimationFrame() method</Span>, 
this <span>function</span> in every single iteration <Span>clears the canvas</Span> and then
goes through <Span>every object in the array</Span>, and calls the 
<Span>animate()</Span> method, which checks the <Span>current x and y coordinates</Span>, and then <Span>updates them</Span> and 
<Span>draws the circles using them</Span>, each <Span>circle object</Span> has <Span>different coordinates and speed</Span>, and that was 
achieved using <span>Math.random()</span> when we created them before.</p>

<p>The <Span>x</Span> parameter is <Span>randomly generated</Span> by 
<Span>Math.random() * (canvas.width - r * 2) + r</Span>, why is that? That's 
because <Span>Math.random()</Span> returns a <Span>number between 0 and 1</Span>, if I <Span>multiply it by the canvas width</Span> then 
the <Span>x</Span> can be <Span>anywhere between 0 and the edge of the canvas</Span>, but since 
the <Span>circle</Span> has a <Span>radius</Span>, I want to make sure that no 
<Span>circle</Span> can <Span>spawn</Span> through the <Span>edges</Span> for both 
<span>left and right sides</span>, that's why I did <Span>canvas.height - r *2</Span>, which makes sure 
the <Span>circle</Span> will be able to only spawn between 0 and on a <Span>distance</Span> equal to it's 
<Span>full width</Span> before the <Span>right edge</Span>, then to make sure 
it will not spawn in the <Span>left edge</Span> we <Span>add r</Span>, that's also the 
reason the <Span>distance from the right side</Span> we specified before was <Span>multiplied by 2</Span>, 
because now, no matter where the <Span>circle</Span> spawns, it will not be inside the <span>edges</span>. 
A similar way was used to generate the <Span>y</Span> coordinate.</p>

<p>About the <Span>dx and dy values</Span> now, I did <Span>Math.random() - 0.5</Span> so that there 
is a <Span>50% chance to return a negative number</Span>, then I <span>multiplied by 2</span> in order to 
<Span>make it move faster</Span>.</p>

<p>Here is a video that helped me a lot, it goes through the process of creating the 
    project I made above, slower, and explains things very much clearer than I did:
</p>

<iframe  src="https://www.youtube.com/embed/yq2au9EfeRQ?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</article>

<hr>

<article id="thirteen">
    <header>
        <h1>Using event listeners with Canvas</h1>
    </header>

<p>Let's now try to create something more cool using <Span>event listeners</Span>, 
    there isn't really much to say about <Span>event listeners</Span>, because I have already talked 
    about them in previous pages, here is a nice project I created:
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">window.addEventListener('load', (e) => {
    var canvas = document.querySelector('#canvas-project1');
    var c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    var points = new Array();

<Span class="gray">    // function to be used for all touch events</Span>
    function getTouchOffset(e){
        points = [];
        let canvas_box = canvas.getBoundingClientRect();
        let coords = {
            x: canvas_box.left,
            y: canvas_box.top 
        }
        Array.from(e.touches).forEach((touch) =>{
            points.push({x: touch.clientX - coords.x, y: touch.clientY - coords.y});
        });
    }

<Span class="gray">    // touch events that update x and y points</Span>
    canvas.addEventListener('touchstart', (e) =>{     
        getTouchOffset(e);
    });

    canvas.addEventListener('touchmove', (e) =>{
        getTouchOffset(e);
    });

    canvas.addEventListener('touchend', (e) =>{
        getTouchOffset(e);
    });

<span class="gray">    // mouse events that update x and y points</span>
    canvas.addEventListener('mousemove', (e) =>{
        points = [];
        points.push({
            x: e.offsetX,
            y: e.offsetY
        });
    });

    canvas.addEventListener('mouseout', (e) =>{
        points = [{
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
        }]
    });

<Span class="gray">    // constructor that creates circles</Span>
    var circleMaker = function(x,y,r,dx,dy,cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.r2 = r;
        this.dx = dx;
        this.dy = dy;
        this.randomColor = cl;
        this.draw = function(){
            c.fillStyle = this.randomColor;
            c.beginPath()
            c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
            c.stroke();
            c.fill();
        }
        this.update = function(){

            let range = 30;
            let arr;

<Span class="gray">            // checks if any of the (x, y) coordinates inside the points array are inside the wanted range of the circle, 
            // the reason I am using an array for the points is so that multi-touches are supported for touchscreens</Span>
            arr = points.filter((point) => {
                if(point.x - this.x < range && point.x - this.x > -range){
                    if(point.y - this.y < range && point.y - this.y > -range){
                        return true;
                    }
                }        
            });

<Span class="gray">            // if the filter method above returned at least one item then it
            // increases the radius, else it decreases it</Span>
            if(arr.length == 0){
                if(this.r > this.r2){
                    this.r -= 1;
                }
            } else{
                if(this.r < 30){
                    this.r += 5;
                }
            }

<Span class="gray">            // checks if the circle has met or passed the edges of the canvas,
            // if it has passed the right edge then I make sure dx is converted to a negative number else if it 
            // is less than 0 I make sure it is a positive number, I didn't do it like in the tutorial because 
            // problems would occur while scaling the circles, since if it was scaled and surpassed the edge then 
            // it would get stuck, that would happen because with the code in the video it would multiple dx with - every time 
            // x was higher than the width of the canvas, if x was heigher than 100 pixels from the edge for example
            // (something that could happen due to fast scaling while near the edge) then dx would become -dx and would increase 
            // like 4 pixels for example but would still be higher than the width of the canvas so it would change back to dx and 
            // that would go on forever causing it get stuck there.</Span>
            if(this.x - this.r < 0){
                this.dx = Math.abs(this.dx);
            } else if(this.x + this.r > canvas.width){
                this.dx = (this.dx < 0)? this.dx: -this.dx;
            }

            if(this.y - this.r < 0){
                this.dy = Math.abs(this.dy);
            } else if(this.y + this.r > canvas.height){
                this.dy = (this.dy < 0)? this.dy: -this.dy;
            }

<span class="gray">            // updates x and y of the circle and then executes the draw method</span>
            this.x += this.dx;
            this.y += this.dy;
            this.draw();
        }
    }

    var circles = new Array();

    var clrs = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

<span class="gray">    // loop that creates circles using the constructor made earlier</span>
    for(let i = 1; i <= 400; i++){
        let r = Math.random() * 3 + 1;
        let x = Math.random() * 
        (canvas.width - r * 2) + r;
        let y = Math.random() * 
        (canvas.height - r * 2) + r;
        let dx = (Math.random() - 0.5) * 3;
        let dy = (Math.random() - 0.5) * 3;
        let cl = clrs[Math.floor(Math.random() * clrs.length)];
    circles.push(new circleMaker(x, y, r, dx, dy, cl));
    }

<span class="gray">    // function that executes again and again to animate the canvas</span>
    function animate(){
    c.clearRect(0,0,canvas.width,canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
    }

    animate();

});</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-project1" style="background-color: black; margin: auto; display: block; border: 3px solid black;"></canvas>

    <script>
        if(true){
        window.addEventListener('load', (e) => {
            var canvas = document.querySelector('#canvas-project1');
            var c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;
             
            var points = new Array();
            
            function getTouchOffset(e){
                points = [];
                let canvas_box = canvas.getBoundingClientRect();
                let coords = {
                    x: canvas_box.left,
                    y: canvas_box.top 
                }
                Array.from(e.touches).forEach((touch) =>{
                    points.push({x: touch.clientX - coords.x, y: touch.clientY - coords.y});
                });
            }

            canvas.addEventListener('touchstart', (e) =>{     
                getTouchOffset(e);
            });
            
            canvas.addEventListener('touchmove', (e) =>{
                getTouchOffset(e);
            });
            
            canvas.addEventListener('touchend', (e) =>{
                getTouchOffset(e);
            });
            
            canvas.addEventListener('mousemove', (e) =>{
                points = [];
                points.push({
                    x: e.offsetX,
                    y: e.offsetY
                });
            });
            
            canvas.addEventListener('mouseout', (e) =>{
                points = [{
                    x: Number.POSITIVE_INFINITY,
                    y: Number.POSITIVE_INFINITY
                }]
            });
            
            var circleMaker = function(x,y,r,dx,dy,cl){
                this.x = x;
                this.y = y;
                this.r = r;
                this.r2 = r;
                this.dx = dx;
                this.dy = dy;
                this.randomColor = cl;
                this.draw = function(){
                    c.fillStyle = this.randomColor;
                    c.beginPath()
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    
                    let range = 30;
                    let arr;
                 
                    arr = points.filter((point) => {
                        if(point.x - this.x < range && point.x - this.x > -range){
                            if(point.y - this.y < range && point.y - this.y > -range){
                                return true;
                            }
                        }        
                    });
                       
                    if(arr.length == 0){
                        if(this.r > this.r2){
                            this.r -= 1;
                        }
                    } else{
                        if(this.r < 30){
                            this.r += 5;
                        }
                    }
                    
                    if(this.x - this.r < 0){
                        this.dx = Math.abs(this.dx);
                    } else if(this.x + this.r > canvas.width){
                        this.dx = (this.dx < 0)? this.dx: -this.dx;
                    }
                       
                    if(this.y - this.r < 0){
                        this.dy = Math.abs(this.dy);
                    } else if(this.y + this.r > canvas.height){
                        this.dy = (this.dy < 0)? this.dy: -this.dy;
                    }
                             
                    this.x += this.dx;
                    this.y += this.dy;
                    this.draw();
                }
            }
            
            var circles = new Array();
            
            var clrs = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];
            
            for(let i = 1; i <= 400; i++){
                let r = Math.random() * 3 + 1;
                let x = Math.random() * 
                (canvas.width - r * 2) + r;
                let y = Math.random() * 
                (canvas.height - r * 2) + r;
                let dx = (Math.random() - 0.5) * 3;
                let dy = (Math.random() - 0.5) * 3;
                let cl = clrs[
                Math.floor(Math.random() * clrs.length)
                ];
            circles.push(new circleMaker(x, y, r, dx, dy, cl));
            }
            
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }        

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0,0,canvas.width,canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
            
            animate();
            
        });
        }
    </script>

<h2><u>Explanation of the code:</u></h2>

<p>Let me explain a little now, you already can see from the comments what each 
    part of the code basically does, but I will try to give a more organized explanation about what 
    happens behind the scenes here. First of all, the circles moving around 
    were made just like the ones I created in the previous section, I explained the code 
    there so I will not go into much details about this, I changed some stuff however, 
    I made the radius of the circles be defined randomly, by writing Math.random() * 3 + 1, this makes 
    so the radius of the circles is between 1 and 4 pixels. I also made a new property called color, and 
    made it pick a random color for each circle, it chooses a color from an array of colors randomly 
    something I did by writing Math.floor(Math.random() * clrs.length), Math.floor will take the result, and 
    if it's a float number such as 0.5 it will return 0, or if the number is 0.7 it will also return 0, if 
    it's 1.6 it will return 1, if it's 2.3 it will return 2, and so on.  
</p>

<p>So, every time you hover your mouse over the canvas or touch the canvas 
    an object with the current x and y positions is added to an array called points, the reason I want it 
    to be an array is because for touches multiple objects could be returned if multi-touches occur. For every 
    iteration of the animation, I made it so, for each circle, a filter method 
    is used on the points array, to check if any of the x and y positions of the objects 
    provided are withing a wanted range, if even one of the objects in the array pass the test, then 
    the object is added in a new array, then I check to see if that array has a length greater than 0 or not, 
    if it has a length of 0 then that means no object passed the test, in which case, I check if the circle is bigger 
    than it's default radius, and make it smaller if it is, else if an object was matched 
    this means the circle is within the wanted range of at least one of the touches so I check 
    if the circle is smaller than a maximum radius I want and if it is then I make it bigger. 
</p>

<p>Another thing I changed from the code I had written before is the 
    if else statements that determine when to change the dx and dy direction, before 
    I would simple multiple them with - to change their direction, but now that the circles 
    can be scaled, if their radius changed while being near the edges a problem could occur due 
    to the circle surpassing the edge by more than 1 pixel, in which case the dx or dy would keep being 
    multipled by - in every single iteration, making the circle get stuck there. The Math.abs() method 
    converts a negative number to a positive one, to convert dx to a negative number I first made it check if 
    it already is a negative number, in which case I want it to let it be, and if it is not I 
    multiply it with - to make it one.
</p>

<h2><u>Tutorial that helped me:</u></h2>

<p>I used this tutorial to make this project, however, a large part of my code was 
    changed, and I believe improved, mine also supports multi touches and I also fixed some 
    problems with the code in the video.
</p>

<iframe src="https://www.youtube.com/embed/vxljFhP2krI?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</article>

<hr>

<article id="fourteen">
    <header>
        <h1>Creating gravity effect on Canvas</h1>
    </header>

    <p>In this section we will try to create the <Span>effect of gravirty</Span>, before we do 
    this, we need to understand what are the basic elements that create the <Span>effect</Span>. 
When an object <Span>falls</Span>, it starts with a <span>small speed</span> and <span>increases</span>, till 
it <Span>reaches the ground</Span>, then, if it's a small ball you would expect it to 
bounce back up towards the sky and fall again, however, as it  goes up it should <Span>decrease speed</Span>, so 
that it stops at some point and then <span>increase speed</span> again, towards the ground however.</s></p>

<p>Creating this <Span>speed change</Span> is pretty easy actually, let's try this out:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-018');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        if(this.y + this.r > canvas.height){
            this.dy = -this.dy;
        } else{
            this.dy += 1;
        }

        this.y += this.dy;
        this.draw();

        let p = document.getElementById('somethings');
        p.innerHTML = this.dy;
    }
}

let circles = new Array();
let colors = ['red', 'blue', 'green', 'yellow'];

for(let i = 1; i<= 1; i++){
    let r = Math.random() * 3 + 20;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];

    circles.push(new circleMaker(200, 50, r, 1, 1, clr));
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-018" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <p id="somethings"></p>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-018');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    if(this.y + this.r > canvas.height){
                        this.dy = -this.dy;
                    } else{
                        this.dy += 1;
                    }

                    this.y += this.dy;
                    this.draw();

                    let p = document.getElementById('somethings');
                    p.innerHTML = this.dy;
                }
            }

            let circles = new Array();
            let colors = ['red', 'blue', 'green', 'yellow'];

            for(let i = 1; i<= 1; i++){
                let r = Math.random() * 3 + 20;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];

                circles.push(new circleMaker(200, 50, r, 1, 1, clr));
            }

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }        

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p>So, the code may seem a little big, but it's actually the same 
    peace of code I used for the project in the <span>previous sections</span>, what I want 
    you to pay attention at is the <Span>update method</span>, I have made it so when 
    it <span>reaches the edge of the canvas</span> the <Span>dy</Span> is <Span>reversed</Span>, 
    if it <span>hasn't reached the edge</span> then it <Span>adds 1 to dy</Span>, to help you understand 
    what this little trick does I made a <Span>paragraph</Span> in which I 
    <Span>insert the dy</Span> in every <Span>iteration</Span>, it starts with a <Span>dy</Span> of 
    <span>1</span> and <Span>increases</Span>, till it <Span>reaches the bottom of the canvas</Span>, then 
    it's <span>direction is reversed</span>, so now, for <Span>each iteration</Span> we 
    <Span>add 1 to dy</Span>, which is currently a <span>negative number</span>, so we <Span>dicrease the speed</Span>, 
    till it reaches <Span>0</Span>, then the <span>direction changes towards the bottom again</span>, and 
    the <span>speed increases again</span>.
</p>

<p>This is good and all, but there is something missing, every time the 
    <Span>ball hits the ground</Span>, some of it's <span>energy</span> should 
    <Span>decrease</Span>, so at some point, the ball <Span>stays still</Span>. 
    Let's try doing that now:
</p>


<Style>
    .orange{
        background-color: lightcoral;
        font-weight: bold;
    }
</style>
<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">if(true){
let canvas = document.getElementById('canvas-019');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        let gravity = 1;
        let finished = false;

<Span class="orange">        if(this.y + this.r > canvas.height){
            this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
            if(this.dy > -5){
                this.dy = 0;
                finished = true;
            }
        } else{
            this.dy += gravity;
        }</span>

<Span class="orange">        if(finished == true){
            this.y = canvas.height - this.r + 0.1;
        } else{
            this.y += this.dy;
        }</span>

        this.draw();

        let p = document.getElementById('somethings2');
        p.innerHTML = this.dy;
    }
}

let circles = new Array();
let colors = ['red', 'blue', 'green', 'yellow'];

function createCircles(){
    circles = [];
    for(let i = 1; i<= 1; i++){
    let r = Math.random() * 3 + 20;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];

    circles.push(new circleMaker(x, y, r, 1, 1, clr));
    }
}

createCircles();

<Span class="orange">canvas.addEventListener('click', (e) => {
    createCircles();
});</span>

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>


<canvas id="canvas-019" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <p id="somethings2"></p>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-019');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    let gravity = 1;
                    let finished = false;

                    if(this.y + this.r > canvas.height){
                        this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
                        if(this.dy > -5){
                            this.dy = 0;
                            finished = true;
                        }
                    } else{
                        this.dy += gravity;
                    }

                    if(finished == true){
                        this.y = canvas.height - this.r + 0.1;
                    } else{
                        this.y += this.dy;
                    }

                    this.draw();

                    let p = document.getElementById('somethings2');
                    p.innerHTML = this.dy;
                }
            }

            let circles = new Array();
            let colors = ['red', 'blue', 'green', 'yellow'];

            function createCircles(){
                circles = [];
                for(let i = 1; i<= 1; i++){
                let r = Math.random() * 3 + 20;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];

                circles.push(new circleMaker(x, y, r, 1, 1, clr));
                }
            }

            createCircles();

            canvas.addEventListener('click', (e) => {
                createCircles();
            });

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }            

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p><Span>Click</Span> on the <Span>canvas</Span> to make the <span>animation restart</span>, now, let me explain what 
the code does, every time the <Span>ball hits the ground</Span>, it checks if the <span>dy is negative</span>, and if it is, 
then it <Span>lets it be</Span>, else it <Span>multiples it with - to make it negative</Span>, I made this that way to 
prevent some bugs that could occur due the <Span>dy</Span> becoming a <Span>float number</Span>, since it sometimes 
would <span></span>move the ball beyond the edge</span> and a bug would occur. Anyway, <Span>each time the ball hits the ground</Span> I 
<Span>multiply dy</Span> with <Span>0.95</Span> which makes it <Span>decrease</Span>, since when it got 
<span>very low</span> it would create an ugly effect of a trembling ball, I made it so 
if it <Span>hits the ground</Span> and it's <Span>reversed speed</Span> is <Span>lower than 5</Span> it 
just changes directly to <Span>0</Span>. Now, because the <span>ball</span> would some times 
stop <span>a little under the edge</span> I created a <Span>variable named finished</Span>, which I change to 
<Span>true</Span> when the <Span>ball's speed has reached 0</Span> and I made it so <Span>y becomes canvas.height - this.r + 0.1</Span>, 
why the <Span>+ 0.1</Span> you may wonder now, well, that's so the <span>cirlce</span> is 
<Span>barely past the edge</Span>, so that the <span>this.dy += gravity</span> is not executed in the 
<Span>next iterations</Span>.</p>

<p>Lets add some more circles now, add <span>dx</span> and also 
    change the <Span>colors</Span> to finish with this project:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-020');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let circleMaker = function(x, y, r, dx, dy, cl){
    this.x = x;
    this.y = y;
    this.r = r; 
    this.dx = dx;
    this.dy = dy; 
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        let gravity = 1;
        let finished = false;

        if(this.y + this.r > canvas.height){
            this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
            if(this.dy > -5){
                this.dy = 0;
                finished = true;
            }
        } else{
            this.dy += gravity;
        }

        if(this.x + this.r > canvas.width){
            this.dx = ((this.dx < 0)? this.dx: -this.dx) * 0.7;
        } else if(this.x - this.r < 0){
            this.dx = Math.abs(this.dx) * 0.7;
        } else {
            this.dx = (this.dx < 0)? this.dx + 0.001: this.dx - 0.001;
        }

        if(finished == true){
            this.y = canvas.height - this.r + 0.1;
        } else{
            this.y += this.dy;
        }

        this.x += this.dx;

        this.draw();
    }
}

let circles = new Array();
let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

function createCircles(){
    circles = [];
    for(let i = 1; i<= 100; i++){
    let r = Math.random() * 5 + 15;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 4) + r;
    let clr = colors[Math.floor(Math.random() * colors.length)];
    let dx = (Math.random() - 0.5) * 5;
    circles.push(new circleMaker(x, y, r, dx, 1, clr));
    }
}

createCircles();

canvas.addEventListener('click', (e) => {
    createCircles();
});

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    circles.forEach((circle) => {
        circle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas id="canvas-020" style="border: 3px solid black; display: block; margin: auto; background-color: black;"></canvas>
    
    <script>
        if(true){
            let canvas = document.getElementById('canvas-020');
            let c = canvas.getContext('2d');

            canvas.width = 500;
            canvas.height = 300;

            let circleMaker = function(x, y, r, dx, dy, cl){
                this.x = x;
                this.y = y;
                this.r = r; 
                this.dx = dx;
                this.dy = dy; 
                this.cl = cl;
                this.draw = function(){
                    c.fillStyle = cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
                    let gravity = 0.4;
                    let finished = false;

                    if(this.y + this.r > canvas.height){
                        this.dy = ((this.dy < 0)? this.dy: -this.dy) * 0.95;
                        if(this.dy > -5){
                            this.dy = 0;
                            finished = true;
                        }
                    } else{
                        this.dy += gravity;
                    }

                    if(this.x + this.r > canvas.width){
                        this.dx = ((this.dx < 0)? this.dx: -this.dx) * 0.7;
                    } else if(this.x - this.r < 0){
                        this.dx = Math.abs(this.dx) * 0.7;
                    } else {
                        this.dx = (this.dx < 0)? this.dx + 0.001: this.dx - 0.001;
                    }

                    if(finished == true){
                        this.y = canvas.height - this.r + 0.1;
                    } else{
                        this.y += this.dy;
                    }

                    this.x += this.dx;

                    this.draw();
                }
            }

            let circles = new Array();
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            function createCircles(){
                circles = [];
                for(let i = 1; i<= 100; i++){
                let r = Math.random() * 5 + 15;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 4) + r;
                let clr = colors[Math.floor(Math.random() * colors.length)];
                let dx = (Math.random() - 0.5) * 5;
                circles.push(new circleMaker(x, y, r, dx, 1, clr));
                }
            }

            createCircles();

            canvas.addEventListener('click', (e) => {
                createCircles();
            });

            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
            }            

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    circles.forEach((circle) => {
                        circle.update();
                    });
                }
                requestAnimationFrame(animate);
            }

            animate();

        }
    </script>

<p>This tutorial below helped me a lot with that project, however, my version is a bit different than the one 
    in the video, I have fixed some bugs and made it a little better, still the video is great since the guy goes through 
    the steps of creating the project and explains things better than I did, so check this out if you want:
</p>

<iframe src="https://www.youtube.com/embed/3b7FyIxWW94?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="fifteen">
    <header>
        <h1>Collision Detection</h1>
    </header>

<p>Determining when <Span>two objects touch</Span>, or when <Span>your mouse touches an object</Span> allows 
you to create some really cool stuff, that's why in this section, I will teach you how to 
<span>etect collision</span>.</p>

<p>To do so, we are gonna use the famous <Span>Pythagorean theorem</Span>, 
which allows us to find the <span>hypotenuse</span> of a <Span>triangle</Span>. The 
formula is <Span>âx^2 + y^2</Span>, however, in code it's faster for us to use the 
<span>Math.hypot(x, y)</span> method. Now, to get the <span>x, y</span> coordinates of a 
<Span>vector</Span> we need to know it's <Span>starting points</Span> and <span>end points</span>, then to get 
the <Span>Vx</Span> we can get it by doing <Span>x2 - x1</Span> and to get <Span>Vy</Span> we can get 
it by doing <Span>y2 - y1</Span>, I have also talked about that stuff, as well as how to get the <Span>angle</span> formed by 
the <Span>vector</span> in my <Span>Math notes</span>.</p>

<p>For now, let's try to make a simple <Span>collision</Span> border-image-width
<span>two circles</span>, one <Span>moving with our corsure</span>, when the <Span>two cicles touch</span> 
I will make it so the <Span>big static circle changes color</Span>:</p>


<style>
    .canvases{
        display: block;
        margin: auto;
        border: 3px solid black;
    }
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-001');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

function circleMaker(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){
        this.draw();
    }
}

let circle1 = new circleMaker(canvas.width/2, canvas.height/2, 50, 'black');  
let circle2 = new circleMaker(undefined, undefined, 20, 'red');

let cursorCoords = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    cursorCoords.x = e.offsetX;
    cursorCoords.y = e.offsetY;
});

canvas.addEventListener('touchstart', (e) => {
    let box = canvas.getBoundingClientRect();
    cursorCoords.x = box.left - e.touches[0].clientX;
    cursorCoords.y = box.top - e.touches[0].clientY;
});

canvas.addEventListener('touchmove', (e) => {
    let box = canvas.getBoundingClientRect();
    cursorCoords.x = box.left - e.touches[0].clientX;
    cursorCoords.y = box.top - e.touches[0].clientY;
});

function getDistance(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    [circle2.x, circle2.y] = [cursorCoords.x, cursorCoords.y];
    let distance = getDistance(circle2.x, circle2.y, circle1.x, circle1.y);
    if(distance < circle1.r + circle2.r){
        circle1.cl = 'red';
    } else { circle1.cl = 'black'; }
    circle1.update();
    circle2.update();
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvases" id="canvas-001"></canvas>

<script>
    if(true){
        let canvas = document.getElementById('canvas-001');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 300;

        function circleMaker(x, y, r, cl){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.update = function(){
                this.draw();
            }
        }

        let circle1 = new circleMaker(canvas.width/2, canvas.height/2, 50, 'black');         
        let circle2 = new circleMaker(undefined, undefined, 20, 'red');
        
        let cursorCoords = {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
        }

        canvas.addEventListener('mousemove', (e) => {
            cursorCoords.x = e.offsetX;
            cursorCoords.y = e.offsetY;
        });

        canvas.addEventListener('touchstart', (e) => {
            let box = canvas.getBoundingClientRect();
            cursorCoords.x = box.left - e.touches[0].clientX;
            cursorCoords.y = box.top - e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            let box = canvas.getBoundingClientRect();
            cursorCoords.x = box.left - e.touches[0].clientX;
            cursorCoords.y = box.top - e.touches[0].clientY;
        });

        function getDistance(x1, y1, x2, y2){
            let Vx = x2 - x1;
            let Vy = y2 - y1;
            return Math.hypot(Vx, Vy);
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function animate(){
            if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                [circle2.x, circle2.y] = [cursorCoords.x, cursorCoords.y];
                let distance = getDistance(circle2.x, circle2.y, circle1.x, circle1.y);
                if(distance < circle1.r + circle2.r){
                    circle1.cl = 'red';
                } else { circle1.cl = 'black'; }
                circle1.update();
                circle2.update();
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<P>Here is a video that can help you understand the code above better:</p>

<iframe src="https://www.youtube.com/embed/XYzA_kPWyJ8?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<P>So, for my next code, I am gonna use some <span>math</span> and 
<Span>physics</span> to create <Span>realistic collisions</span>. In order 
to better understand this, I recommend you also check my <a href="../Math-and-Physics-Notes/math1.html#two">physics notes</a>, 
where I explained the <Span>physics of the code</Span> in more details. Anyway, here is the project:</P>

<p>First thing we need to do, is to make sure <Span>particles cannot spawn inside each other</Span>, to do so, 
we are gonna use this code:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-030');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let getDistance = function(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

let particle = function(x, y, r, cl, velocities, mass){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl; 
    this.velocity = velocities
    this.m = mass;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
    }
    this.update = function(){
        this.draw();
    }
}

let particles = new Array();

function int(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 15;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = 'red';

        if(i !== 0){
            for(let j = 0; j < particles.length; j++){
                let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    x = Math.random() * (canvas.width - r * 2) + r;
                    y = Math.random() * (canvas.height - r * 2) + r;
                    j = -1;
                }
            }
        }    

        particles.push(new particle(x, y, r, cl));
    }
}

int();

canvas.addEventListener('click', (e) => {
    int();
});

function animate(){
    c.fillStyle = 'black';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((x) => {
        x.update();
    });
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome</span>

<canvas id="canvas-030" style="display: block; margin: auto; border: 3px solid black;">

<script>
    if(true){
        let canvas = document.getElementById('canvas-030');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 300;

        let getDistance = function(x1, y1, x2, y2){
            let Vx = x2 - x1;
            let Vy = y2 - y1;
            return Math.hypot(Vx, Vy);
        }

        let particle = function(x, y, r, cl, velocities, mass){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl; 
            this.velocity = velocities
            this.m = mass;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.fill();
                c.stroke();
            }
            this.update = function(){
                this.draw();
            }
        }

        let particles = new Array();

        function int(){
            particles = [];
            for(let i = 0; i < 50; i++){
                let r = 15;
                let x = Math.random() * (canvas.width - r * 2) + r;
                let y = Math.random() * (canvas.height - r * 2) + r;
                let cl = 'red';

                if(i !== 0){
                    for(let j = 0; j < particles.length; j++){
                        let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                        if(distance < 0){
                            x = Math.random() * (canvas.width - r * 2) + r;
                            y = Math.random() * (canvas.height - r * 2) + r;
                            j = -1;
                        }
                    }
                }    

                particles.push(new particle(x, y, r, cl));
            }
        }

        int();

        canvas.addEventListener('click', (e) => {
            int();
        });

        function animate(){
            c.fillStyle = 'black';
            c.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach((x) => {
                x.update();
            });
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>Check the code inside the <Span>int function</span>, <Span>after the first particle is created</span>, 
<Span>all the other particles I create</Span> will <Span>check their distance with all the previous particles created</span>, 
I made sure that the <Span>first particle will not be checked</span> since there would be 
<Span>no other particles to compare with</span>, if the <Span>distance with at least one of the other particles is less than 0</Span>
then I <span>redefine x and y</span> and <Span>change j to -1</span> which at the <Span>end of the iteration</span> will
<Span>become 0</Span>, so what basically happens is that the <span>whole loop is redone</span> and the <Span>distance with the new coordinates is calculated</span> 
this will happen again and again till <Span>coordinates</span> that <span>don't overlap any other particles</span> are found. Be aware, that if the <Span>particles are too big</span> 
and <span>there is no space for all to fit</span> then the <span>page will crash being unable to find coordinates that don't overlap</span>, so try different sizes or 
reduce the number of particles 
to make sure all particles can fit.</p>

<p class="left">JavaScript:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-031');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let getDistance = function(x1, y1, x2, y2){
    let Vx = x2 - x1;
    let Vy = y2 - y1;
    return Math.hypot(Vx, Vy);
}

let rotate = function(velocity, angle){
    let rotatedVelocities = {
        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
    }
    return rotatedVelocities;
}

let particle = function(x, y, r, cl, velocities, mass){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl; 
    this.velocity = velocities;
    this.m = mass;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.fill();
        c.stroke();
    }
    this.changeVelocities = function(thisParticle, otherParticle){
        let [x1, y1, v1, m1] = [thisParticle.x, thisParticle.y, thisParticle.velocity, thisParticle.m];
        let [x2, y2, v2, m2] = [otherParticle.x, otherParticle.y, otherParticle.velocity, otherParticle.m];

        let xVelocityDiff = v1.x - v2.x;
        let yVelocityDff = v1.y - v2.y;

        let xDist = x2- x1;
        let yDist = y2 - y1;

        if(xVelocityDiff * xDist + yVelocityDff * yDist >= 0){
            let angle = -Math.atan2(y2 - y1, x2 - x1);

            let rotatedV1 = rotate(v1, angle);
            let rotatedV2 = rotate(v2, angle);

            let rotatedV1final = {x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2), y: rotatedV1.y};
            let rotatedV2final = {x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2), y: rotatedV2.y};

            let finalV1 = rotate(rotatedV1final, -angle);
            let finalV2 = rotate(rotatedV2final, - angle);

            thisParticle.velocity = finalV1; 
            otherParticle.velocity = finalV2;
        }
    }
    this.update = function(particles){
        if(this.x + this.r > canvas.width){
            this.velocity.x = (this.velocity.x < 0)? this.velocity.x: -this.velocity.x;
        } else if(this.x - this.r < 0){
            this.velocity.x = Math.abs(this.velocity.x);
        }

        if(this.y + this.r > canvas.height){
            this.velocity.y = (this.velocity.y < 0)? this.velocity.y: -this.velocity.y;
        } else if(this.y - this.r < 0){
            this.velocity.y = Math.abs(this.velocity.y);
        }

        for(let j = 0; j < particles.length; j++){
            if(this == particles[j]){
                continue;
            } else {
                let distance = getDistance(this.x, this.y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    this.changeVelocities(this, particles[j]);
                }
            }
        }

        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.draw();
    }
}

let particles = new Array();

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

function int(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 15;
        let x = Math.random() * (canvas.width - r * 2) + r;
        let y = Math.random() * (canvas.height - r * 2) + r;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        let dx = (Math.random() - 0.5) * 3;
        let dy = (Math.random() - 0.5) * 3;

        if(i !== 0){
            for(let j = 0; j < particles.length; j++){
                let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                if(distance < 0){
                    x = Math.random() * (canvas.width - r * 2) + r;
                    y = Math.random() * (canvas.height - r * 2) + r;
                    j = -1;
                }
            }
        }    

        particles.push(new particle(x, y, r, cl, {x: dx, y: dy}, 1));
    }
}

int();

canvas.addEventListener('click', (e) => {
    int();
});

function animate(){
    c.fillStyle = 'black';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((x) => {
        x.update(particles);
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvas-031" style="display: block; margin: auto; border: 3px solid black;"></canvas>

    <script>
        if(true){
            let canvas = document.getElementById('canvas-031');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
    
            let getDistance = function(x1, y1, x2, y2){
                let Vx = x2 - x1;
                let Vy = y2 - y1;
                return Math.hypot(Vx, Vy);
            }

            let rotate = function(velocity, angle){
                let rotatedVelocities = {
                    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
                }
                return rotatedVelocities;
            }
    
            let particle = function(x, y, r, cl, velocities, mass){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl; 
                this.velocity = velocities;
                this.m = mass;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.fill();
                    c.stroke();
                }
                this.changeVelocities = function(thisParticle, otherParticle){
                    let [x1, y1, v1, m1] = [thisParticle.x, thisParticle.y, thisParticle.velocity, thisParticle.m];
                    let [x2, y2, v2, m2] = [otherParticle.x, otherParticle.y, otherParticle.velocity, otherParticle.m];
                    
                    let xVelocityDiff = v1.x - v2.x;
                    let yVelocityDff = v1.y - v2.y;

                    let xDist = x2- x1;
                    let yDist = y2 - y1;

                    if(xVelocityDiff * xDist + yVelocityDff * yDist >= 0){
                        let angle = -Math.atan2(y2 - y1, x2 - x1);

                        let rotatedV1 = rotate(v1, angle);
                        let rotatedV2 = rotate(v2, angle);

                        let rotatedV1final = {x: rotatedV1.x * (m1 - m2) / (m1 + m2) + rotatedV2.x * 2 * m2 / (m1 + m2), y: rotatedV1.y};
                        let rotatedV2final = {x: rotatedV2.x * (m1 - m2) / (m1 + m2) + rotatedV1.x * 2 * m2 / (m1 + m2), y: rotatedV2.y};

                        let finalV1 = rotate(rotatedV1final, -angle);
                        let finalV2 = rotate(rotatedV2final, - angle);

                        thisParticle.velocity = finalV1; 
                        otherParticle.velocity = finalV2;
                    }
                }
                this.update = function(particles){
                    if(this.x + this.r > canvas.width){
                        this.velocity.x = (this.velocity.x < 0)? this.velocity.x: -this.velocity.x;
                    } else if(this.x - this.r < 0){
                        this.velocity.x = Math.abs(this.velocity.x);
                    }

                    if(this.y + this.r > canvas.height){
                        this.velocity.y = (this.velocity.y < 0)? this.velocity.y: -this.velocity.y;
                    } else if(this.y - this.r < 0){
                        this.velocity.y = Math.abs(this.velocity.y);
                    }

                    for(let j = 0; j < particles.length; j++){
                        if(this == particles[j]){
                            continue;
                        } else {
                            let distance = getDistance(this.x, this.y, particles[j].x, particles[j].y) - r * 2;
                            if(distance < 0){
                                this.changeVelocities(this, particles[j]);
                            }
                        }
                    }

                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.draw();
                }
            }
    
            let particles = new Array();
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            function int(){
                particles = [];
                for(let i = 0; i < 50; i++){
                    let r = 15;
                    let x = Math.random() * (canvas.width - r * 2) + r;
                    let y = Math.random() * (canvas.height - r * 2) + r;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    let dx = (Math.random() - 0.5) * 3;
                    let dy = (Math.random() - 0.5) * 3;
    
                    if(i !== 0){
                        for(let j = 0; j < particles.length; j++){
                            let distance = getDistance(x, y, particles[j].x, particles[j].y) - r * 2;
                            if(distance < 0){
                                x = Math.random() * (canvas.width - r * 2) + r;
                                y = Math.random() * (canvas.height - r * 2) + r;
                                j = -1;
                            }
                        }
                    }    
    
                    particles.push(new particle(x, y, r, cl, {x: dx, y: dy}, 1));
                }
            }
    
            int();
    
            canvas.addEventListener('click', (e) => {
                int();
            });
    
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'black';
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((x) => {
                        x.update(particles);
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>I did basically the same thing I did before while defining the <span>x and y coordinates</span> to 
<Span>check for collisions</span>, so there isn't much to explain, the hardest part to understand of this code 
is the <span>changeVelocities() function</span>, but I explain this <Span>function</span> 
in my <a href="../Math-and-Physics-Notes/math1.html#two">physics notes</a>. Here is a video if you need more help with the code:</p>

<iframe src="https://www.youtube.com/embed/789weryntzM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
 
</article>

<hr>

<article id="sixteen">
    <header>
        <h1>Circular Motion</h1>
    </header>

    <p>So, in order to code <Span>circular motion</Span>, we are gonna 
    need some basic knowledge of what <Span>radians</Span>, <Span>cos</Span> and 
<Span>sin</Span> are.</p>

<p><Span>Radians</Span> are used to measure <Span>angles</Span>, to 
conver <Span>degrees</Span> to <Span>radians</Span> you can multiple the <Span>degrees</Span> 
by <Span>Ï/180</Span>. <br><br><span>Half a circle</span> is <span>180 degrees</span>, which 
equals to <span>3.1416... radians</span>, or else <Span>Ï radians</Span>, a 
<Span>full circle</Span> would be <Span>2Ï radians</Span>.</p>

<p>The reason we are learning about <Span>radians</Span> is because the <Span>methods</Span> we 
are gonna use take <Span>radians</Span> are their <Span>parameter</Span>, those <span>methods</span> will be 
<Span>Math.cos()</Span> and <Span>Math.sin()</Span>, so what is <Span>cos</Span> and what is <span>sin</span>?
Take a look at this picture:</p>

<img src="../images/Ï5.png">

<p>So, for a given <span>angle</span>, like <span>65 degrees</span> for example, we can form a <span>triangle</span>, 
the <Span>sin</Span> of a <Span>triangle</Span> is equal to <Span>opposite side / hypotenuse</Span> and 
the <Span>cos</Span> is equal to <span>adjacent side / hypotenuse</span>. Because of that, at <Span>90 degrees</span>, since the <Span>adjacent side</Span> 
of the <Span>triangle</Span> will be <span>zero</span>, <Span>cos will be zero</Span>, while <span>sin</span> will be 
equal to <Span>1</Span> since <span>opposite side</span> and <Span>hypotenuse</Span> will be equal. </p>

<img src="../images/Ï6.png">

<p>Anyway, what we gotta understand from this basically is that
by doing <Span>circle's X position + Math.cos(radians) * radius</Span> we get the exact <Span>x position</span>
of the the <Span>angle</span>. If we created an <span>arc</span> at <Span>200 pixels x</Span> with a <Span>radius of 50 pixels</Span> and 
we then put our finger at the 
edge of the circle and draged it around the circle <Span>90 degrees</Span>, 
that would be <Span>Ï/2 radians</Span>, so if we wanted to find the exact <span>x position our finger is on</span> we could 
do <Span>200 + Math.cos(Ï/2) * 50</Span>, to find the <span>y position our finger is on</span> we simple would 
do the same but use <Span>Math.sin()</Span> instead, so we would do <span>200 + Math.sin(Ï/2) * 50</span>.</p>

<p>If in an <Span>animation</span>, we <Span>continuously increased the radians</Span>, it would be as if we were 
<Span>rotating around a circle again and again</Span>, if we used <Span>sin</Span> for <Span>y</Span> and <Span>cos</Span> for 
<Span>x</Span> positions of our <span>particle</span>, then a <Span>circual movement would be made</Span>, a 
small one though since <Span>sin</span> and <Span>cos</span> return numbers between <Span>-1 and 1</span>, anyway, let's test this out:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-021');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 200;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.005;
    this.radians = 0;
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){

        this.radians += this.velocity;

        this.x = Math.cos(this.radians);
        this.y = Math.sin(this.radians);

        let p = document.getElementById('smthinga');
        p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
        this.draw();
    }
}

let particles = new Array();

for(let i = 1; i <= 1; i++){
    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
}

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-021"></canvas>
<p id="smthinga"></p>

<script>
    if(true){
        let canvas = document.getElementById('canvas-021');
        let c = canvas.getContext('2d');

        canvas.width = 500;
        canvas.height = 200;
        
        let createParticle = function(x, y, r, cl){
            this.x = x;
            this.y = y; 
            this.r = r;
            this.cl = cl;
            this.velocity = 0.005;
            this.radians = 0;
            this.draw = function(){
                c.fillStyle = this.cl;
                c.beginPath();
                c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                c.stroke();
                c.fill();
            }
            this.update = function(){

                this.radians += this.velocity;

                this.x = Math.cos(this.radians);
                this.y = Math.sin(this.radians);

                let p = document.getElementById('smthinga');
                p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
                this.draw();
            }
        }

        let particles = new Array();

        for(let i = 1; i <= 1; i++){
            particles = [];
            particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
        }

        function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 

        function animate(){
            if(isScrolledIntoView(canvas)){
            c.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((particle) => {
                particle.update();
            });
            }
            requestAnimationFrame(animate);
        }

        animate();
    }
</script>

<p>The <Span>code above</Span> already creates a <Span>circular motion</span>, its just way too small 
to notice easily, but the <Span>circle</Span> does move, the <span>radians</span> are <Span>increasing</Span> per each 
iteration, therefore, the <Span>sin</span> and <Span>cos</span> are changing too, if we add 
these for our <span>x, y</span> positions we should get a <Span>circular movement</Span>, however, there are two issues we gotta 
fix in order to make this visible, first, we gotta <spa>move the center of our circle</spa>, to our 
<span>original x, y positions</span>, then, we will <Span>increase the range of the rotation</Span>, since at the moment it's rotation is of 
a range between -1 and 1, if we wanted it to <Span>rotate</span> on a 
<Span>distance of 50 pixels from the center</span> then we could <span>multiple sin and cos by 50</span>, let's try this:</P>


<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">this.x = x + Math.cos(this.radians) * 50;
this.y = y + Math.sin(this.radians) * 50;</Span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-022"></canvas>
    <p id="smthinga2"></p>
    
    <script>
        if(true){
            let canvas = document.getElementById('canvas-022');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 200;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = 0;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
    
                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * 50;
                    this.y = y + Math.sin(this.radians) * 50;
    
                    let p = document.getElementById('smthinga2');
                    p.innerHTML = `x: ${this.x} <br> y: ${this.y}`;
                    this.draw();
                }
            }
    
            let particles = new Array();
    
            for(let i = 1; i <= 1; i++){
                particles = [];
                particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
            }
            function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
        } 
            function animate(){
                if(isScrolledIntoView(canvas)){
                c.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach((particle) => {
                    particle.update();
                });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>Alright, now, let's add <Span>multiple particles</Span>, and 
    <Span>give them a random starting radians angle</Span>, as well as 
    a <Span>random distance from center</Span>.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-024');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    <Span class="orange">this.radians = Math.random() * Math.PI * 2;</span>
    <Span class="orange">this.distance = Math.random() * 50 + 50;</span>
    this.draw = function(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }
    this.update = function(){

        this.radians += this.velocity;

        <Span class="orange">this.x = x + Math.cos(this.radians) * this.distance;</span>
        <Span class="orange">this.y = y + Math.sin(this.radians) * this.distance;</span>

        this.draw();
    }
}

let particles = new Array();

<Span class="orange">function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
    }
}

int();</span>

function animate(){
    c.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

        <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-024"></canvas>
        
        <script>
            if(true){
                let canvas = document.getElementById('canvas-024');
                let c = canvas.getContext('2d');
        
                canvas.width = 500;
                canvas.height = 300;
                
                let createParticle = function(x, y, r, cl){
                    this.x = x;
                    this.y = y; 
                    this.r = r;
                    this.cl = cl;
                    this.velocity = 0.05;
                    this.radians = Math.random() * Math.PI * 2;
                    this.distance = Math.random() * 50 + 50;
                    this.draw = function(){
                        c.fillStyle = this.cl;
                        c.beginPath();
                        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                        c.stroke();
                        c.fill();
                    }
                    this.update = function(){
        
                        this.radians += this.velocity;
        
                        this.x = x + Math.cos(this.radians) * this.distance;
                        this.y = y + Math.sin(this.radians) * this.distance;
        
                        this.draw();
                    }
                }
        
                let particles = new Array();
                
                function int(){
                    particles = [];
                    for(let i = 1; i <= 50; i++){
                        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
                    }
                }

                int();
        
                function isScrolledIntoView(el) {
                var rect = el.getBoundingClientRect();
                var elemTop = rect.top;
                var elemBottom = rect.bottom;
            
                // Only completely visible elements return true:
                var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
                // Partially visible elements return true:
                //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
                return isVisible;
                } 

                function animate(){
                    if(isScrolledIntoView(canvas)){
                        c.clearRect(0, 0, canvas.width, canvas.height);
                        particles.forEach((particle) => {
                            particle.update();
                        });
                    }
                    requestAnimationFrame(animate);
                }
        
                animate();
            }
        </script>

<p>Now, let's try to create a nice <span>trail</span> to make the 
    animation smoother:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10"> function animate(){
    c.fillStyle = 'rgba(255, 255, 255, 0.06)';
    c.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach((particle) => {
        particle.update();
    });
    requestAnimationFrame(animate);
}</span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-025"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-025');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(){
                    c.fillStyle = this.cl;
                    c.beginPath();
                    c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
                    c.stroke();
                    c.fill();
                }
                this.update = function(){
    
                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * this.distance;
                    this.y = y + Math.sin(this.radians) * this.distance;
    
                    this.draw();
                }
            }
    
            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, 10, 'red'));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(255, 255, 255, 0.06)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>This doesn't look very beautiful to me, and that's because we are using 
<Span>arcs</span>, to make it better let's change <span>arcs</span> to <Span>lines</span>, 
in order to create <Span>lines</span> we are gona need to keep reference of our 
<span>previous x,y positions</span> so that we can draw the line from 
<Span>the previous x,y positions</span> to <Span>new x,y positions</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let cas = document.getElementById('canvas-026');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
<Span class="orange">this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }</span>
    this.update = function(){
<Span class="orange">        let previousPoints = {
            x: this.x, 
            y: this.y
        }</span>

        this.radians += this.velocity;

        this.x = x + Math.cos(this.radians) * this.distance;
        this.y = y + Math.sin(this.radians) * this.distance;

        <Span class="orange">this.draw(previousPoints);</span>
    }
}

<Span class="orange">let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];</span>

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        <Span class="orange">let r = Math.random() * 3 + 1;</span>
        <Span class="orange">let cl = colors[Math.floor(Math.random() * colors.length)];</span>
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();
</span></p>

<p class="left">Outcome:</p>

<canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-026"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-026');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    this.x = x + Math.cos(this.radians) * this.distance;
                    this.y = y + Math.sin(this.radians) * this.distance;
    
                    this.draw(previousPoints);
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>A lot better, don't you agree? I did some other changes too, like, I 
<Span>randomized the radius</span> and <span>color</span> to make it look better, 
since when the <Span>animation first starts</Span> the <Span>x</Span> and 
<Span>y</Span> are at the <Span>center of the circle</Span>, I made it so 
it checks if <Span>previous.x and y are equal to original x and y</Span> and if 
true I use the <Span>new x and y positions</Span> on both <Span>moveTo</span> and 
<Span>lineTo</Span>, I did that in order to fix a bug, after the canvas has been drawn, even though 
a lot of layers of <Span>black rectangles</Span> with a <Span>transparency of 0.05</span> are added to cover old drawings, 
the color stays slightly different, I don't know why, the background was just a little brighter, it wasn't very visible but I didn't like it 
so that's why I prevented the lines from starting at the center. 

<p>Let's now add some <Span>interactivity</span> so that the <span>particles</span> 
are <Span>moving with the mouse</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-027');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

<Span class="orange">let mouse = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mouseout', (e) => {
    mouse.x = Number.POSITIVE_INFINITY;
    mouse.y = Number.POSITIVE_INFINITY;
});</span>

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
    this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }
    this.update = function(){
        let previousPoints = {
            x: this.x, 
            y: this.y
        }

        this.radians += this.velocity;

        this.x = <Span class="orange">mouse.x</span> + Math.cos(this.radians) * this.distance;
        this.y = <Span class="orange">mouse.y</span> + Math.sin(this.radians) * this.distance;

        this.draw(previousPoints);
    }
}

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        let r = Math.random() * 3 + 1;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>



    <canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-027"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-027');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    this.x = mouse.x + Math.cos(this.radians) * this.distance;
                    this.y = mouse.y + Math.sin(this.radians) * this.distance;
    
                    this.draw(previousPoints);
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

<p>So, this works fine, but it isn't very smooth, I would like to create a <span>dragging effect</span>, so that the 
<Span>particles</Span> are being <span>dragged towards the mouse slower</span>, lets try this:</p>


<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-028');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let mouse = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
}

canvas.addEventListener('mousemove', (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});

canvas.addEventListener('mouseout', (e) => {
    mouse.x = Number.POSITIVE_INFINITY;
    mouse.y = Number.POSITIVE_INFINITY;
});

let createParticle = function(x, y, r, cl){
    this.x = x;
    this.y = y; 
    this.r = r;
    this.cl = cl;
    this.velocity = 0.05;
    this.radians = Math.random() * Math.PI * 2;
    this.distance = Math.random() * 50 + 50;
    <Span class="orange">this.lastMouse = {x: x, y: y};</span>
    this.draw = function(previous){
        c.strokeStyle = this.cl;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.closePath();
    }
    this.update = function(){
        let previousPoints = {
            x: this.x, 
            y: this.y
        }

        this.radians += this.velocity;

<Span class="orange">        if(mouse.x != Number.POSITIVE_INFINITY){
            this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
            this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

            this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
            this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

            this.draw(previousPoints);
        }</span>
    }
}

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let particles = new Array();

function int(){
    particles = [];
    for(let i = 1; i <= 50; i++){
        let r = Math.random() * 3 + 1;
        let cl = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
    }
}

int();

function isScrolledIntoView(el) {
var rect = el.getBoundingClientRect();
var elemTop = rect.top;
var elemBottom = rect.bottom;

// Only completely visible elements return true:
var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
// Partially visible elements return true:
//isVisible = elemTop < window.innerHeight && elemBottom >= 0;
return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){
        c.fillStyle = 'rgba(0, 0, 0, 0.05)';
        c.fillRect(0, 0, canvas.width, canvas.height);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>


<canvas style="background-color: black; border: 3px solid black; display: block; margin: auto;" id="canvas-028"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-028');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.lastMouse = {x: x, y: y};
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    if(mouse.x != Number.POSITIVE_INFINITY){
                        this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
                        this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

                        this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
                        this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

                        this.draw(previousPoints);
                    }
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>

    <p>So, when <Span>mouse.x stops being POSITIV_INFINITY</span>, if for example you 
    move your mouse to the <Span>top left corner of the canvas</Span>, the <Span>lastMouse.x</Span> will be increased by 
    the <Span>distance of your old mouse pisition and your new mouse positive * 0.09</Span>, then the result will be used to change the <Span>position of the circle</Span>, 
    which means, <Span>if you moved your mouse from (50, 50) to (100, 50)</Span>, then the <span>lastMouse.x</span> would become 
<span>50 (which was the last mouse position) + 50 (which is the distance from the new mouse position) * 0.09</span>, this is later used for the <Span>x</span> of the circle, 
so, what this basically does it that it makes <span>x increase slowly</span> instead of moving exactly with the mouse, and that creates a smoother effect than before.</p>

</article>
 
<hr>

<article id="seventeen">
    <header>
        <h1>How to obtain and manipulate pixels data</h1>
    </header>

    <p>In this section we will learn how to <Span>obtain</Span> and <Span>manipulate</Span> the <span>pixels data</span> 
        of the <span>canvas</span>, we will learn 
        how by providing <span>x, y coordinates</span> we can <span>obtain the RGBA value of the pixel at that position</span>, by knowing that, 
        we will then be able to <Span>manipulate them</Span>, using <Span>ctx.getImageData()</Span> and <span>ctx.putImageData()</span> 
        methods. Lastly we will also learn <Span>canvas.toDataURL()</Span> method which allows us to 
        <Span>save a canvas</span> as an <Span>URL</Span> that can later be used as 
        <Span>source</Span> of an <span>image</span>.

<h2><u>ctx.getImageDate() method:</u></h2>

    <p>The <Span>CanvasRenderingContext2D method getImageData()</span> of the 
    <span>Canvas 2D API</span> returns an <span>ImageData object</span> representing the
<Span>underlying pixel data</span> for a <span>specified portion of the canvas</span></p>

    <p>This <span>method</span> is <Span>not affected</span> by the <span>canva's transformation matrix</span>.
        If the <span>specified rectangle extends outside the bounds of the canvas</span>, the <Span>pixels outside the canvas</Span>
        are <Span>transparent black</span> in the <Span>returned ImageData object</span></p>

<p>The <Span>getImageData()</Span> method takes <span>four parameters</span>, which are the following: <Span>x, y, width, height</Span>, those 
<span>parameters</span> are used to <Span>select the area of the canvas you want</Span>, 
after using this <span>method</span> an <span>object will be returned</span>, let's take a look 
to that <span>object</span>:</p>

<p class="left">JavaScript Code:</p>
<p class="left"><span class="code10">let canvas = document.getElementById('canvas-020');
let c = canvas.getContext('2d');

let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

console.dir(imageData);</span></p>
<p class="left">Outcome:</p>

<script>
    if(true){
        let canvas = document.getElementById('canvas-020');
        let c = canvas.getContext('2d');

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);

        console.dir(imageData);
    }
</script>

<img src="../images/Ï7.png">

<p>There are <Span>two errors</span> that may appear when you 
call this <Span>method</span>, one is <span>IndexSizeError</span> which will 
be thrown if <span>either width or height are zero</span>, and the <span>second error</span> is 
<Span>SecurityError</Span>. The <span>canvas</span> contains or may contain <span>pixels which were loaded from an origin other than the one from 
which the document itself was loaded</span>. To avoid <Span>SecurityError</Span> being thrown in this situation, 
<Span>configure CORS</Span> to <Span>allow the source image to be used in this way</Span>.</p>

<p>Anyway, let's continue now and learn what the <Span>data property</span> is. The <span>data property</span>
is a <Span>Unit8ClampedArray</span> representing a <span>one-dimensional array</span> containing the <Span>data</Span> in the 
<span>RGBA order</span>, with <span>integer values between 0 and 255</span>.</p>

<p>The <span>data property</span> returns a <span>Uint8ClampedArray</span> which can be 
accessed to look at the <span>raw pixel data</span>. Each <Span>pixel</Span> is represented by 
<Span>four one-byte values</Span> (red, green, blue and alpha, in that order, that is, "RGBA" format). <Span>Each color</Span>
component is represented by an <Span>interger between 0 and 255</Span>. <Span>Each component</span> is 
assigned a <Span>consecutive index within the array</span>, with the <Span>top left pixel's red component</span> being at <Span>index 0 within the array</span>. <Span>Pixels</span> then proceed from 
<Span>left to right</span>, then <Span>downward</span>, throughout the <span>array</span>.</p>

<h2><u>How to find pixels in the pixels array:</u></h2>

<p>So, let me explain the <Span>pixels array</span> with simplier words now, the <Span>first four elements of the array</span> are the 
<Span>RGBA values of the first pixel at the top left of the canvas</span>, the <Span>first element is red</span>, 
the <Span>second element is green</span>, the <span>third element is blue</span> and the <span>fourth element is alpha</span>, 
so how could we <Span>find a specific pixel in the canvas</Span> inside this <span>array</span>? There is a 
<span>formula</span> we can use, if <Span>each pixel only was one element each</Span>, then <Span>x + y * width</Span> would return 
the <Span>pixel at the specified x and y position</Span>, the <Span>second pixel</Span> for example would be at <span>(1, 0)</span>, 
in a <Span>canvas with width 100pixels</Span>, if we did <span>2 + 0 * 100</span> we would get <span>2</span>, however, since <span>each pixel takes four elements</span> we 
should <span>multiple this by 4</span>, so if I wanted to choose the <span>first pixel</span>, I would do 
<span>(0 + 0 * 100) *4</span>, which would give me <Span>0</span>, which is indeed the 
<Span>first element of the first pixel</Span>, if I wanted to get the <Span>second pixel</Span> I would do 
<span>(1 + 0 * 100) *4</span> which would give me <Span>4</Span>, which is indeed the <span>first element of the second pixel</span>. 
What you need to remember is the following simple <Span>formula</Span> and you will be able to 
find the <Span>pixel</Span> you want in the <span>pixels array</span>: <Span>(x + y * canvas.width) * 4</Span></p>

<p>So, if you wanted to only choose the <span>red velue</span> of the <Span>pixels</Span> you could 
use the <Span>formula</span> I wrote above, if you however wanted to select the <Span>green value</Span> you could use this one instead:
<span>(x + y * canvas.width) * 4 + 1</span>, or if you wanted to select the <span>blue value</span> you could 
use this one: <span>(x + y * canvas.width) * 4 + 2</span>, and lastly, to select the <Span>alpha value</span> 
you could use this one: <Span>(x + y * canvas.width) * 4 + 3</span>.</p>

<p>Here is a video that really helped me understand the <span>pixels array</span>:</p>

<iframe src="https://www.youtube.com/embed/nMUMZ5YRxHI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>So, now, let's create a simple <Span>function</Span> that gets the
<Span>RGBA values</Span> of a <Span>specified pixel</Span>:

<p class="left">JavaScript Code:</p>
<p class="left"><Span class="code10">function getColorIndices(x, y, width){
let red = (x + y * width) * 4;
return [red, red + 1, red + 2, red + 3];
};

let colorIndices = getColorIndices(1, 0, 100);

let [redIndex, greenIndex, blueIndex, alphaIndex] = colorIndices;

// redIndex == 4, greenIndex == 5, blueIndex == 6, alphaIndex == 7
</Span></p>

<P>Let's create a <Span>color picker</Span> project for fun:</P>

<p class="left">HTML Code:</p>

<p class="left"><Span class="code10">&lt;table id="colorpicker-project">
    &lt;tr>
        &lt;th>Source&lt;/th>
        &lt;th>Hovered color&lt;/th>
        &lt;th>Selected Color&lt;/th>
    &lt;/tr>
    &lt;tr>
        &lt;td>&lt;canvas id="canvas-colorpicker">&lt;/canvas>&lt;/td>
        &lt;td>&lt;div id="hoveredcolor">&lt;/div>&lt;/td>
        &lt;td>&lt;div id="selectedcolor">&lt;/div>&lt;/td>
    &lt;/tr>
&lt;/table></Span></p>

<p class="left">CSS Code:</p>

<p class="left"><Span class="code10">#colorpicker-project{
    border: 3px solid lightcyan;
    border-collapse: collapse;
    margin: auto;
    background-color: black;
    color: lightcyan;
}
#colorpicker-project th, #colorpicker-project td{
    border: 2px solid lightcyan;
    padding: 5px;
}
#selectedcolor, #hoveredcolor{
    height: 150px;
    width: 100%;
}</Span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-colorpicker');
let c = canvas.getContext('2d');
let hoveredColor = document.getElementById('hoveredcolor');
let selectedColor = document.getElementById('selectedcolor');

let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
gradient.addColorStop(0, 'red');
gradient.addColorStop(0.5, 'green');
gradient.addColorStop(1, 'blue');

c.fillStyle = gradient;
c.fillRect(0, 0, canvas.width, canvas.height);

let mouse = {
    x: undefined,
    y: undefined
}

function colorPicker(event, target){
    mouse.x = event.offsetX;
    mouse.y = event.offsetY;

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    
    function getColorIndices(x, y, width){
        let red = (x + y * width) * 4;
        return [red, red + 1, red + 2, red + 3];
    }

    let colorIndices = getColorIndices(mouse.x, mouse.y, canvas.width);

    let RGBA = colorIndices.map((x) => {
        return imageData.data[x];
    });

    target.style.backgroundColor = `rgba(${RGBA})`;
}

canvas.addEventListener('mousemove', (e) => {
    colorPicker(e, hoveredColor);
});

canvas.addEventListener('click', (e) => {
    colorPicker(e, selectedColor);
});</Span></p>

<p class="left">Outcome:</p>

<Style>
    #colorpicker-project{
        border: 3px solid lightcyan;
        border-collapse: collapse;
        margin: auto;
        background-color: black;
        color: lightcyan;
    }
    #colorpicker-project th, #colorpicker-project td{
        border: 2px solid lightcyan;
        padding: 5px;
    }
    #selectedcolor, #hoveredcolor{
        height: 150px;
        width: 100%;
    }
</Style>

<table id="colorpicker-project">
    <tr>
        <th>Source</th>
        <th>Hovered color</th>
        <th>Selected Color</th>
    </tr>
    <tr>
        <td><canvas id="canvas-colorpicker"></canvas></td>
        <td><div id="hoveredcolor"></div></td>
        <td><div id="selectedcolor"></div></td>
    </tr>
</table>

<script>
    if(true){
        let canvas = document.getElementById('canvas-colorpicker');
        let c = canvas.getContext('2d');
        let hoveredColor = document.getElementById('hoveredcolor');
        let selectedColor = document.getElementById('selectedcolor');
        
        let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'red');
        gradient.addColorStop(0.5, 'green');
        gradient.addColorStop(1, 'blue');
        
        c.fillStyle = gradient;
        c.fillRect(0, 0, canvas.width, canvas.height);

        let mouse = {
            x: undefined,
            y: undefined
        }

        function colorPicker(event, target){
            mouse.x = event.offsetX;
            mouse.y = event.offsetY;

            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            
            function getColorIndices(x, y, width){
                let red = (x + y * width) * 4;
                return [red, red + 1, red + 2, red + 3];
            }

            let colorIndices = getColorIndices(mouse.x, mouse.y, canvas.width);

            let RGBA = colorIndices.map((x) => {
                return imageData.data[x];
            });

            target.style.backgroundColor = `rgba(${RGBA})`;
        }

        canvas.addEventListener('mousemove', (e) => {
            colorPicker(e, hoveredColor);
        });

        canvas.addEventListener('click', (e) => {
            colorPicker(e, selectedColor);
        });
    }
</script>

<p>Getting the <Span>opacity</Span> is a little different however, the 
<Span>opacity</Span> is stored in <Span>values between 0 and 255</Span>, 
if for example the <Span>first pixel</Span> has the <Span>opacity of 0.5</Span>, 
then <Span>imageData.data[3]</Span> would return <Span>0.5 * 255</Span>, 
in order to <Span>convert that number</Span> back to the 
<Span>original float number of the opacity</Span> you should 
<Span>devide the given number by 255</Span>, like this:</p>

<style>
#canvass1{
    margin: auto;
    display: block;
    border: 3px solid black;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.querySelector('#canvass1');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

c.fillStyle = 'red';
c.globalAlpha = '0.5';

c.fillRect(0, 0, canvas.width, canvas.height);

let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
let data = imageData.data;

let opacity = data[3] / 255;
document.write(`The first pixel of the canvas has an opacity of ${opacity}`);</span></p>

<p class="left">Outcome:</p>

<canvas id="canvass1"></canvas>

<script>
if(true){
    let canvas = document.querySelector('#canvass1');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    c.fillStyle = 'red';
    c.globalAlpha = '0.5';

    c.fillRect(0, 0, canvas.width, canvas.height);

    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;

    let opacity = data[3] / 255;
    document.write(`The first pixel of the canvas has an opacity of ${opacity}`);
}
</script>

<h2><u>putImageData() method:</u></h2>

<p>You can use the <Span>putImageData()</Span> method to <Span>paint pixel data</Span>
into a <Span>context</span>, it's <Span>syntax</span> looks like this: <Span>ctx.putImageDate(myImageData, dx, dy)</Span>;</p>

<p>The <Span>dx</span> and <Span>dy</span> parameters indicate the <Span>device coordinates within the context</Span>
which to paint the top left corner of the pixel data you wish to draw.</p>

<p>For example, to paint the <Span>entire image</Span> represented by <Span>myImageData</Span> to the 
<Span>top left corner of the context</span>, you can do the following: <Span>ctx.putImageData(myImageData, 0, 0);</Span></p>

<p class="left">HTML Code:</p>

<p class="left"><span class="code10">#canvas-project007{
    display: grid;
    grid-template-areas: 
    'canvas' 
    'form';
    justify-content: space-evenly;
    margin: auto; 
    width: fit-content;
}
#canvas-0002{
    border: 3px solid black;
    grid-area: canvas;
}
#canvas-project007 form{
    grid-area: form;
    display: flex; 
    width: 100%;
    justify-content: space-evenly;
}</span></p>

<p class="left">CSS Code:</p>

<p class="left"><span class="code10">&lt;div id="canvas-project007">
&LT;canvas id="canvas-0002" style="border: 3px solid black; display: block; margin: auto;">&lt;/canvas>
&lt;form>
    &lt;input type="radio" name="type" value="original" checked="true"> Original 
    &lt;input type="radio" name="type" value="Grayscale"> Grayscale 
    &lt;input type="radio" name="type" value="Inverted"> Inverted
&lt;/form>
&lt;/div></span></p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-0002');
let c = canvas.getContext('2d');

let inputs = document.querySelectorAll('#canvas-project007 input');

let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
gradient.addColorStop(0, 'red');
gradient.addColorStop(0.3, 'pink');
gradient.addColorStop(0.5, 'green');
gradient.addColorStop(0.7, 'yellow');
gradient.addColorStop(1, 'blue');

let img = new Image();
img.src = ../images/Ï8.png';

function original(){
    let aspectRatio = img.naturalWidth / img.naturalHeight;
    canvas.height = canvas.width / aspectRatio;
    c.drawImage(img, 0, 0, canvas.width, canvas.height);
}

img.addEventListener('load', (e) => {
    original();
});

function grayscale(){
    original();
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;
    for(let i = 0; i < data.length; i+=4){
        let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = avg;
        data[i + 1] = avg;
        data[i + 2] = avg;
    }
    c.putImageData(imageData, 0, 0);
}

function inverted(){
    original();
    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
    let data = imageData.data;
    for(let i = 0; i < data.length; i += 4){
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2]
    }
    c.putImageData(imageData, 0, 0);
}

inputs.forEach((input) => {
    input.addEventListener('change', (e) => {
        switch(e.target.value){
            case "Grayscale":
                return grayscale();
            break;
            case "Inverted":
                return inverted();
            break;
            default: 
                return original();
        }
    });
});</span></p>

<p class="left">Outcome:</p>

<style>
    #canvas-project007{
        display: grid;
        grid-template-areas: 
        'canvas' 
        'form';
        justify-content: space-evenly;
        margin: auto; 
        width: fit-content;
    }
    #canvas-0002{
        border: 3px solid black;
        grid-area: canvas;
    }
    #canvas-project007 form{
        grid-area: form;
        display: flex; 
        width: 100%;
        justify-content: space-evenly;
    }
</style>

<div id="canvas-project007">
<canvas id="canvas-0002" style="border: 3px solid black; display: block; margin: auto;"></canvas>
<form>
    <input type="radio" name="type" value="original" checked="true"> Original 
    <input type="radio" name="type" value="Grayscale"> Grayscale 
    <input type="radio" name="type" value="Inverted"> Inverted
</form>
</div>

<script>
    if(true){
        let canvas = document.getElementById('canvas-0002');
        let c = canvas.getContext('2d');

        let inputs = document.querySelectorAll('#canvas-project007 input');

        let gradient = c.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'red');
        gradient.addColorStop(0.3, 'pink');
        gradient.addColorStop(0.5, 'green');
        gradient.addColorStop(0.7, 'yellow');
        gradient.addColorStop(1, 'blue');
        
        let img = new Image();
        img.src = '../images/Ï8.png';

        function original(){
            let aspectRatio = img.naturalWidth / img.naturalHeight;
            canvas.height = canvas.width / aspectRatio;
            c.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        img.addEventListener('load', (e) => {
            original();
        });

        function grayscale(){
            original();
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 0; i < data.length; i+=4){
                let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
            }
            c.putImageData(imageData, 0, 0);
        }

        function inverted(){
            original();
            let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for(let i = 0; i < data.length; i += 4){
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2]
            }
            c.putImageData(imageData, 0, 0);
        }

        inputs.forEach((input) => {
            input.addEventListener('change', (e) => {
                switch(e.target.value){
                    case "Grayscale":
                        return grayscale();
                    break;
                    case "Inverted":
                        return inverted();
                    break;
                    default: 
                        return original();
                }
            });
        });        
    }
</script>

<p>In the <Span>previous section</span> I created a project in which some 
<Span>particles</span> are <Span>making a circual move around your mouse</span> 
with a <Span>trail effect</span>, but because I used <Span>fillRect with an opacity of 0.5</span> to
make that <Span>trail effect</span> the <Span>background of the canvas lost it's transparency</span>, something
that's bad since I wanted to later to make the <Span>canvas</span> take the 
whole page with a <Span>fixed position</span> and a <span>transparent background</span>, 
to fix that, I am gonna use <span>getImageData()</span>, to get the <Span>pixels data</Span> before 
each <Span>animation iteration</span>, then I will <Span>multiple the opacity of all pixels by 0.9</span>, meaning that 
<Span>pixels that are already transparent will stay transparent</span> while 
<Span>pixels that wer visible will become more transparent</span> then I will simple 
use <Span>clearRect()</span> to clear the <Span>canvas</span> and <span>putImageData()</span> to 
<Span>draw the particles with a lower transparency</Span>, then the <Span>next animation iteration will happen</span> 
and like that the <Span>trail effect</span> will be created:</p>

<p class="left">JavaScript:</p>

<p class="left"><span class="code10"> function animate(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);
        particles.forEach((particle) => {
            particle.update();
        });
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

    <canvas style="border: 3px solid black; display: block; margin: auto;" id="canvas-029"></canvas>
        
    <script>
        if(true){
            let canvas = document.getElementById('canvas-029');
            let c = canvas.getContext('2d');
    
            canvas.width = 500;
            canvas.height = 300;
            
            let mouse = {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
            }

            canvas.addEventListener('mousemove', (e) => {
                mouse.x = e.offsetX;
                mouse.y = e.offsetY;
            });

            canvas.addEventListener('mouseout', (e) => {
                mouse.x = Number.POSITIVE_INFINITY;
                mouse.y = Number.POSITIVE_INFINITY;
            });

            let createParticle = function(x, y, r, cl){
                this.x = x;
                this.y = y; 
                this.r = r;
                this.cl = cl;
                this.velocity = 0.05;
                this.radians = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 50 + 50;
                this.lastMouse = {x: x, y: y};
                this.draw = function(previous){
                    c.strokeStyle = this.cl;
                    c.lineWidth = this.r;
                    c.beginPath();
                    c.moveTo((previous.x == x)? this.x: previous.x, (previous.y == y)? this.y: previous.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();
                }
                this.update = function(){
                    let previousPoints = {
                        x: this.x, 
                        y: this.y
                    }

                    this.radians += this.velocity;
    
                    if(mouse.x != Number.POSITIVE_INFINITY){
                        this.lastMouse.x += (mouse.x - this.lastMouse.x) * 0.09;
                        this.lastMouse.y += (mouse.y - this.lastMouse.y) * 0.09;

                        this.x = this.lastMouse.x + Math.cos(this.radians) * this.distance;
                        this.y = this.lastMouse.y + Math.sin(this.radians) * this.distance;

                        this.draw(previousPoints);
                    }
                }
            }
    
            let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

            let particles = new Array();
            
            function int(){
                particles = [];
                for(let i = 1; i <= 50; i++){
                    let r = Math.random() * 3 + 1;
                    let cl = colors[Math.floor(Math.random() * colors.length)];
                    particles.push(new createParticle(canvas.width / 2, canvas.height / 2, r, cl));
                }
            }

            int();
    
            function isScrolledIntoView(el) {
            var rect = el.getBoundingClientRect();
            var elemTop = rect.top;
            var elemBottom = rect.bottom;
        
            // Only completely visible elements return true:
            var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
            // Partially visible elements return true:
            //isVisible = elemTop < window.innerHeight && elemBottom >= 0;
            return isVisible;
            } 

            function animate(){
                if(isScrolledIntoView(canvas)){
                    let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
                    let data = imageData.data;
                    for(i = 3; i < data.length; i += 4){
                        data[i] = data[i] * 0.9
                    }
                    c.clearRect(0, 0, canvas.width, canvas.height);
                    c.putImageData(imageData, 0, 0);
                    particles.forEach((particle) => {
                        particle.update();
                    });
                }
                requestAnimationFrame(animate);
            }
    
            animate();
        }
    </script>







<h2><u>Saving images with canvas.toDataURL() method:</u></h2>

<p>The <span>HTMLCanvasElement</span> provides a <Span>toDataURL()</Span> method, which is
useful when <Span>saving images</Span>. It returns a <Span>data URL</Span> containing a 
representation of the <span>image</span> in the format specified by the type parameter (defaults to PNG). The <Span>returned image</Span> is a <Span>resolution of 9 dpi</Span>.</p>

<P>The syntax looks like this: <Span>canvas.toDataURL('image/png', quality)</span>, of course you can use other formats 
    such as <span>jpg</span>, <span>jpeg</span>, etc, and also, the <span>second parameter</span> is 
    <Span>optional</Span>, you don't need to add it, you can provide a 
    <span>quality</span> in a <Span>range from 0 to 1</Span>, with one being the 
    best quality and with - almost not recognizable but small in file size.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">let canvas = document.getElementById('canvas-idka');
let c = canvas.getContext('2d');

c.fillStyle = 'lightcoral';
c.fillRect(0, 0, canvas.width, canvas.height);

let colors = ["yellow", "brown", "green", "orange", "pink", 'purple'];

for(let i = 0; i&lt;100; i++){
    let r = Math.random() * 3 + 2;
    let x = Math.random() * (canvas.width - r * 2) + r;
    let y = Math.random() * (canvas.height - r * 2) + r;
    let cl = colors[Math.floor(Math.random() * colors.length)];

    c.fillStyle = cl;
    c.beginPath();
    c.arc(x, y, r, 0, Math.PI * 2);
    c.stroke();
    c.fill();
}

let url = canvas.toDataURL('image/jpeg', 1);

let img = document.getElementById('image-container');
img.src = url;</span></p>

<p class="left">Outcome:</p>


<canvas id="canvas-idka" style="border: 3px solid black; display: block; margin: auto;"></canvas>
<img id="image-container">

<script>
    if(true){
        let canvas = document.getElementById('canvas-idka');
        let c = canvas.getContext('2d');

        c.fillStyle = 'lightcoral';
        c.fillRect(0, 0, canvas.width, canvas.height);

        let colors = ["yellow", "brown", "green", "orange", "pink", 'purple'];

        for(let i = 0; i<100; i++){
            let r = Math.random() * 3 + 2;
            let x = Math.random() * (canvas.width - r * 2) + r;
            let y = Math.random() * (canvas.height - r * 2) + r;
            let cl = colors[Math.floor(Math.random() * colors.length)];

            c.fillStyle = cl;
            c.beginPath();
            c.arc(x, y, r, 0, Math.PI * 2);
            c.stroke();
            c.fill();
        }

        let url = canvas.toDataURL('image/jpeg', 1);

        let img = document.getElementById('image-container');
        img.src = url;
    }
</script>

<p>The reason the image has a border and is center is because I 
have styled all the images I add to be like that since it's time consuming 
to add the styles on each seperately.

</article>

<hr>

<article id="eighteen">
    <header>
        <h1>How to make Sine Waves</h1>
    </header>

<p>In this section we will learn how to draw 
<Span>sine waves</span> and <Span>edit them</Span>, 
learning the theory behind them can be very useful, because 
<Span>sine waves</span> can be used in many ways. They are 
very beautiful to use for <Span>dynamic backgrounds</Span> 
and stuff, that make your <span>website</span> look better
than simple static drawings. 
</p>

<p>To create the <Span>waves</Span> we are 
going to use the <Span>Math.sin()</span> method, I explaine 
how it works in the previous section, when you want something 
to go <Span>forth and back</Span>, or <Span>up and down</span> 
the <Span>Math.sin()</span> method is usually what you are looking for, 
since it returns <Span>numbers between -1 and 1</span>, 
we are going to create a <Span>loop</Span> to draw the 
waves <Span>pixel by pixel</span> and use <Span>Math.sin()</Span>
to change the <Span>y value continuously<Span>, let's try this:</p>

<style>
.cvas{
    display: block; 
    margin: auto;
    border: 3px solid black;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0003');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i));
}
c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0003"></canvas>

<script>
if(true){
    let canvas = document.getElementById('canvas-0003');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let wave = {
        y: canvas.height / 2
    }

    c.beginPath();
    c.moveTo(0, wave.y);
    for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i));
    }
    c.stroke();
}
</script>

<p>Alright, we did make some <Span>really small waves</span>, 
but I would like them more if they were a little bigger, 
to do that we will add an <Span>aplitude</Span> to our 
<Span>waves</Span>, right now, <Span>Math.sin()</Span> returns 
<Span>numbers between -1 and 1</span>, if I were to <Span>multiple this</span> 
by <Span>50</Span> for example it would <Span>return numbers between -50 and 50</Span>, 
lets try this:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0004');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2,
    aplitude: 50
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i) * wave.aplitude);
}
c.stroke();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0004"></canvas>

<script>
if(true){
    let canvas = document.getElementById('canvas-0004');
    let c = canvas.getContext('2d');

    canvas.width = 500;
    canvas.height = 300;

    let wave = {
        y: canvas.height / 2,
        aplitude: 50
    }

    c.beginPath();
    c.moveTo(0, wave.y);
    for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i) * wave.aplitude);
    }
    c.stroke();
}
</script>

<p>That's a little better, but it's still a little ugly, the <Span>length</Span>
of the <Span>waves</span> is way too small, to dix that we can <Span>multiple i inside Math.(sin) with a demical number</Span>, 
right now we are getting a <span>small length</span> because the <Span>numbers between -50 and 50</Span> are 
<Span>going up and down way too fast</Span>, if instead of <Span>increasing i by 1 for each loop</Span> I were 
<span>increasing it with 0.05</span> for example, the <Span>waves would get bigger</Span>, so all I have to do 
is <Span>multiple i with 0.05</span>.</p>

    <p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-0005');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

c.beginPath();
c.moveTo(0, wave.y);
for(let i = 0; i <= canvas.width; i++){
    c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
}
c.stroke();</span></p>
    
    <p class="left">Outcome:</p>

    <canvas class="cvas" id="canvas-0005"></canvas>

    <script>
    if(true){
        let canvas = document.getElementById('canvas-0005');
        let c = canvas.getContext('2d');
    
        canvas.width = 500;
        canvas.height = 300;
    
        let wave = {
            y: canvas.height / 2,
            aplitude: 50,
            length: 0.05
        }
    
        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
    }
    </script>

<p>Now, before I continue I would like to add a 
<Span>package</span> to our code that allows us to <Span>change the values of the variables</Span>
and see our <Span>animation change</span> on screen without having to <Span>edit the code and save</Span>, 
this will save us a lot of time since we won't have to just try out random values again and again till we find the ones we like, 
and also it's just cool, to be able to manipulate the <Span>wave</Span>, it also will help us better understand how the 
<Span>wave</span> works. 
</p>

<p>The <Span>package</Span> I will use is called <span>dat.GUI</span> and I have wrote about everything you need 
to know to <span>install it</span> in <a href="./../Extra-Notes/extranotes1.html">this page</a>, you will need to learn how to 
use the <Span>terminal</Span>, how to use <span>NPM</span>, then how to use <Span>parcel</Span> and then I have also 
wrote instructions abou thow to <Span>install and use dat.gui</Span>.</p>

<img src="./../images/waves1.png">

<p>I know this may seem a little complicated, so let me explain what I did, 
I created an <Span>external canvas.js file</Span> which I will from now on use 
to <Span>draw all my canvas elements</Span>, and I <Span>bundled it with parcel</Span>, 
so that <span>data.gui package works</span>. From now on, whenever I 
<Span>update canvas.js</span> the <Span>canvas.js inside canvas folder will also be updated automatically</span>. 
I will be using the <Span>bundled file</Span> inside <Span>the page you are currently viewing</Span>, 
after I'm done with all my projects, I will <span>use parcel build to minimize the bundled file</span> 
so it <Span>takes less space</Span>, I  then <span>remove the original canvas.js</span> file, or keep it somewhere 
for later anyway, and I will only need to keep the <Span>bundled canvas.js file</Span>.
</p>

<style>
.property-name{
    background-color: gray !important;
}
.c{
    background-color: gray !important;
}
.cvas{
    display: block; 
    margin: auto;
    border: 3px solid black;
}
</style>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10"><Span class="orange">import * as dat from 'dat.gui'</Span>

let canvas = document.getElementById('canvas-0006');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

<Span class="orange">canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
}

function animate(){
    if(isScrolledIntoView(canvas)){</span>
        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
<span class="orange">    }</span>
    requestAnimationFrame(animate);
<Span class="orange"></Span>}

animate();</Span></span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0006"></canvas>

<script src="./../CSS-JavaScript-External-Files/dat/canvas/canvas.js">
</script>

<P>If you <Span>click the canvas</Span> and <Span>play with the variables</Span> you 
will see the <Span>waves change</Span>, it will only work 
if the <Span>canvas</span> is <Span>scrolled into view</span> 
and I do that for <span>every animation I make</span> because 
I have built a lot of <Span>animations</span> and if all of them 
worked together the page would be very laggy. Anyway, there is a problem, it keeps on 
<Span>drawing over the previous frames</Span>, to fix that, I'm gonna use 
<Span>getImageData()</Span> and <Span>putImageData()</span>, I 
could just <Span>use clearRect()</span> but I want to add a 
<Span>trail effect</span> and <Span>keep a transparent background</span> 
so that the <Span>canvas</span> can later be used easily anywhere 
without a problem:</P>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui'

let canvas = document.getElementById('canvas-0007');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

function animate(){
    if(isScrolledIntoView(canvas)){

<span class="orange">        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);</span>

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length) * wave.aplitude);
        }
        c.stroke();
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0007"></canvas>

<p>Let's try to make the <Span>wave move</Span> now, by adding 
a <Span>frequency</span> variable. <span>Frequency</span> in a 
<Span>number of wave cycles</Span> that <Span>pass a fixed point over time</span>.</p>

<p>To create the <Span>moving effect</span> we will be <Span>adding an increasing number</Span> inside 
our <span>Math.sin()</span> method, this <Span>increment number</Span> will be <Span>increased by the frequency</span> 
every time <Span>an animation frame is over</span>, thus creating an <Span>illusion of moving</Span>. Why does 
this create the <Span>illusion of moving</span>? From what I understand, this <Span>increment number</span> changes the 
<Span>starting point of our waves</span>, since it's a <Span>static number</span> that <Span>does not increase throughout the for loop</span>,
the <Span>number inside Math.sin()</Span> method will be <span>increased the same</span> for <Span>all loops</Span> 
in an <Span>animation frame</Span>, thus <Span>moving all the pixels</Span> to slightly <Span>different positions</Span>
than in the <Span>previous animation frame</Span>.
The <Span>waves</Span> will always <Span>start from our y point</Span> since only the <Span>lineTo()</span> method is 
inside our <Span>loop</Span> and <Span>is effected by the frequency</Span>, as the <Span>increment number</Span> is 
<Span>increasing</Span> the <span>wave's y</span> seems to <Span>be going up and down</Span>, in reality, 
our <Span>pencil</Span> will <Span>always start from y</Span>, what changes is 
that <Span>y coordinate</Span> that the <Span>first line is drawn to</Span>, it's because, 
the <Span>y</Span> has <Span>changed</Span> from the <Span>previous animation frame</Span> just a little, 
either has <span>increased</span> or <Span>decreased</span>, depened on <Span>Math.sin()</Span>, 
since it gives a <Span>number between our aplutide and -aplitude</Span>. The 
<Span>increment number</Span> has been added to <Span>all of the lineTo() methods</Span>
that are <Span>called throughout the loop</Span>, and since the <Span>Math.sin()</Span>
method gives us a <Span>value between aplitude and -aplitude</Span> if the <Span>first y</Span> is 
<Span>increased</Span> that means the <Span>max/min aplitude</Span> will be <Span>reached faster</Span>, meaning 
that since <Span>the first wave will end faster</Span> the <Span>rest of the waves</Span> 
will <Span>also seem to have moved a little to the left</Span>, since they will <Span>start faster their circle</Span>
than they <Span>did in the previous animation frame</Span>, let's try this out: 
</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><Span class="code10">import * as dat from 'dat.gui' 

let canvas = document.getElementById('canvas-0008');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.05,
<Span class="orange">    frequency: 0.01,</span>
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
<span class="orange">        wave_folder.add(wave, 'frequency', -1, 1);</span>
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

<Span class="orange">let increment = wave.frequency;</span>
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
        c.lineTo(i, wave.y + Math.sin(i * wave.length <Span class="orange">+ increment</span>) * wave.aplitude);
        }
        c.stroke();
<Span class="orange">        increment += wave.frequency;</span>
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0008"></canvas>

<p>To make it a little better lets make the <Span>aplitude</Span> go <Span>up and down</Span>, to do this 
we simple can <Span>multiple aplitude</Span> with <Span>Math.sin(increment)</Span>, it doesn't have 
to be <span>increment</span>, any <Span>increasing number would do</Span>, but since 
we have it ready we will use this one. Also, I want to <Span>change the starting length</Span> a little
to make it look better, you can always just eidt it back by opening the <Span>variable changer</Span>, which 
you can do by <Span>clicking the canvas</Span>.</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui' 

let canvas = document.getElementById('canvas-0009');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
<span class="orange">   length: 0.010,</span>
    frequency: 0.01,
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude <Span class="orange">* Math.sin(increment)</span>);
        }
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-0009"></canvas>

<p>Let's now <Span>add stroke color</span> to our 
<span>>wave</span> and make it <Span>editable</span> 
from our <span>variable changer</san>:<p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><Span class="code10">let canvas = document.getElementById('canvas-00010');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.01,
<Span class="orange">    frequency: 0.03,</span>
}

<span class="orange">let stroke = {
    h: 0,
    s: 50, 
    l: 50
}</span>

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
<Span class="orange">        wave_folder.open();

        let stroke_folder = gui.addFolder('stroke');
        stroke_folder.add(stroke, 'h', 0, 360);
        stroke_folder.add(stroke, 's', 0, 100);
        stroke_folder.add(stroke, 'l', 0, 100);
        stroke_folder.open();</span>
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.9;
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
        c.moveTo(0, wave.y);
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude * Math.sin(increment));
        }
<Span class="orange">        c.strokeStyle = `hsl(${stroke.h}, ${stroke.s}%, ${stroke.l}%)`;</span>
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-00010"></canvas>

<p>I also made some other changes, like, I made the <span>frequency faster</span> and I also 
made it so the <Span>folders automatically open</span> after you <Span>click the canvas</span></p>

<p>Alright, last thing I'm gonna do is make it <Span>change color continuously</span>, 
for example, if the <Span>h is 360</span> I want it to change the <span>h value</span> 
<Span>from 360 to 0</span>, then <Span>from 0 to 360</span> and so on, to do that 
I can simple write <Span>strokeStyle = `hsl(${stroke.h * Math.sin(increment)}, ...`</span> 
however, that would mean <Span>negative numbers would also be looped through</span>, 
to fix that, I would use the <Span>Math.abs()</span> method, like this: <span>strokeStyle = `hsl(${Math.abs(stroke.h * Math.sin(increment)), ...`</span></p>

<p>Also, there is a problem I would like to fix, if you look closely you will notice 
that at the <Span>left edge</span> there is a <Span>visible line</Span> which before 
wasn't very visible but now with color it is. As I said before, the <Span>moveTo()</span>
method is not inside the <Span>for loop</span>, meaning that the <Span>waves</Span> will always 
start from <span>y</span>, its the <Span>lineTo()</span> values that change. To fix that 
I will simple make the <Span>moveTo()</Span> method go <Span>up and down</Span> as well, 
by writing <Span>moveTo(0, wave.y + Math.sin(wave.length + increment) * wave.aplitude * Math.sin(increment));</Span>.
This will <Span>change the y for every animation frame</span>, just like 
it does for the <Span>lineTo()</Span> methods inside the <Span>for loop</Span>.
</p>

<p class="left">[canvas.js] JavaScript Code:</p>

<p class="left"><span class="code10">import * as dat from 'dat.gui' 
let canvas = document.getElementById('canvas-00011');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

<span class="orange">canvas.style.backgroundColor = 'black';</span>

let gui;

let wave = {
    y: canvas.height / 2,
    aplitude: 50,
    length: 0.01,
<Span class="orange">    frequency: 0.02,</span>
}

let stroke = {
<span class="orange">    h: 360,</span>
    s: 50, 
    l: 50
}

canvas.addEventListener('click', (e) =>{
    let div = document.querySelector('.close-button');
    if(div == null){
        gui = new dat.GUI();
        let wave_folder = gui.addFolder('wave');
        wave_folder.add(wave, 'y', 0, canvas.height);
        wave_folder.add(wave, 'aplitude', -100, 100);
        wave_folder.add(wave, 'length', -0.05, 0.05);
        wave_folder.add(wave, 'frequency', -1, 1);
        wave_folder.open();

        let stroke_folder = gui.addFolder('stroke');
        stroke_folder.add(stroke, 'h', 0, 360);
        stroke_folder.add(stroke, 's', 0, 100);
        stroke_folder.add(stroke, 'l', 0, 100);
        stroke_folder.open();
    } else {
        div.remove();
        let folders = document.querySelector('.dg ul');
        if(folders != null){
        folders.remove();
        }
    }
});

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = wave.frequency;
function animate(){
    if(isScrolledIntoView(canvas)){

        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
<span class="orange">            data[i] = data[i] * 0.95;</span>
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        c.beginPath();
<Span class="orange">        c.moveTo(0, wave.y + Math.sin(wave.length + increment) * wave.aplitude * Math.sin(increment));</span>
        for(let i = 0; i <= canvas.width; i++){
            c.lineTo(i, wave.y + Math.sin(i * wave.length + increment) * wave.aplitude * Math.sin(increment));
        }
<Span class="orange">        c.strokeStyle = `hsl(${Math.abs(stroke.h * Math.sin(increment))}, ${stroke.s}%, ${stroke.l}%)`;</span>
        c.stroke();
        increment += wave.frequency;
    }
    requestAnimationFrame(animate);
}

animate();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="cvas" id="canvas-00011"></canvas>

<p>As you can see I made some changes, I made the <Span>background black</span>, 
made the <Span>trail bigger</span> and the <Span>frequency slower</span>, I also 
made the <Span>changes mentioned before</span>.</p>

<p>Here is a video that helped me a lot, I think the final project I made 
is a little better because of some fixes I made and improvements, but the video 
definetely explains stuff better than I do:
</p>

<iframe src="https://www.youtube.com/embed/VNmTubIDZOY?list=PLYxnDvM22X3NBARfD2aZcyUoKvfdHfygn" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</article>

<hr>

<article id="nineteen">
    <header>
        <h1>Controlled Randomness with Perlin Noise</h1>
    </header>

<p>In this section I'm going to create a 
<Span>moving snake</Span> that <Span>moves randomly</Span> 
on the <Span>canvas</Span>, it however will <Span>not move completely randomly</Span>, 
since if it did then it would <Span>teleport around the screen</span>, 
the <Span>randomness</span> is going to be kind of <Span>controlled</Span>, 
meaning the <Span>values will be related to each other</span> and I will use 
a <Span>package</span> made by <Span>Chris</span> called <Span>Perlin Noise</Span>.
</p>

<p>So, what exactly is <Span>Perlin Noise</Span>? Just like 
<Span>Math.random()</Span> it is a <Span>function</span> that <span>returns</span> a <span>number between 0 and 1</span>, however, 
the difference is that it <Span>returns those numbers</Span> in a 
<Span>specific sequence</Span>. This <Span>is not a built in function</Span>, 
you have to write it on your own, however, it is fairly complex to make 
it, since it needs a lot of math, and for that reason we 
are going to <span>use a package</span>.</p>

<p>This <Span>package</Span> I'm gonna use is fairly simple, 
you just <Span>call the function</Span> with a <Span>number as a parameter</Span> 
and it <span>returns a number between 0 and 1</span>, for example, 
I could write <Span>noise(1)</Span> or <Span>noise(2)</Span>, however, 
the <Span>number</Span> that you pass does matter, if you want to 
<Span>continiously get random values</Span> that <Span>are relative to one another</Span>
so that <Span>the randomness is controlled</Span> and the <Span>ball is not teleporting around the screen</Span>
then the <Span>values you put inside the function</Span> should be <Span>near one another</Span>, 
for example, if <Span>noise(3)</Span> returned <Span>0.3</Span> then 
<Span>noise(3.2)</Span> could return <Span>0.35</Span> or <Span>0.25</span>, 
if you put a <Span>number of a bigger distance from the previous one used</Span>
then the <Span>number that would be returned would probably have a bigger distance</Span> 
from the <Span>previous number returned</span>, which could 
make the ball teleport around. </p>

<p>Alright, so, first of all, let's <Span>install it</span> 
using <Span>NPM</span>:</p>

<img src="./../images/noise.png">    

<p>Like in the previous section I will also need to 
<Span>use an external bundled JavaScript file</span>, 
to <Span>bundle the JavaScript file</span> I will use 
<Span>parcel</span>.</p>

<img src="./../images/noise2.png">

<p>From now on I will be writing my code in 
<Span>canvas2.js</span> and <Span>parcel</span> will <Span>automatically update bundled canvas2.js</span>
for me, let's create a simple code now:
</p>

<style>
.canvvaas{
    margin: auto;
    border: 3px solid black;
    display: block;
}
</style>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas1');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
    }
    
    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }

    update(){
        this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
        this.draw();
    }
}

let particle1 = new ball(canvas.width / 2, canvas.height / 2, 20, 'red');

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
        particle1.update();
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</span></p>

<p class="left">Outcome:</p>

<canvas id="canvvaas1" class="canvvaas"></canvas>

<p>So, in <Span>every animation loop</Span> I 
<Span>increase increment variable</Span> by <Span>0.01</span>, 
which then is used to set the <Span>new y coordinates</Span>
to this: <span>noise(increment) * (canvas.height - 2 * this.r) + this.r</span>, 
so, <span>noise(increment)</span> will return a <Span>number between 0 and 1</Span> 
that is <Span>relative to the previous number it returned</span>, and then 
it is <Span>multipled by (canvas.height - 2 * this.r) + this.r</span>, 
I have actually used the exact same line of code before, with <Span>Math.random()</Span>, 
it basically sets the <Span>range of numbers it can return</Span> to <Span>not be less than 0 or more 
than the canvas's width</Span>. Lets now try to 
do the same for the <Span>x coordinates</span>:</p>

<p class="left">JavaScript Code:</p>

<p class="left"><span class="code10">update(){
    this.x = noise(increment) * (canvas.width - 2 * this.r) + this.r;
    this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
    this.draw();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas2"></canvas>

<p>As you can see, it does work, however, the 
<Span>ball</span> moves from <Span>the top left corner</span> 
towards the <Span>bottom right corner</span> which isn't what we want, 
the reason this happens is because we use the <Span>same increment number</span> 
in <Span>noise() function</span>, to fix that, we can simple <Span>add an offset</span>, 
we could for example write <Span>x = noise(increment - 20)</span> and
that would fix the problem.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">update(){
    this.x = noise(increment - 20) * (canvas.width - 2 * this.r) + this.r;
    this.y = noise(increment) * (canvas.height - 2 * this.r) + this.r;
    this.draw();
}</span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas3"></canvas>

<p>Now, I want to create <Span>more balls</span>, 
and <span>each ball</span> should have 
<Span>a slightly different offset for y and x</span> so that 
<Span>one is behind each other</span> like a <Span>snake</span>. 
To do that, we are gonna <Span>add an offset property to the ball object</span> 
and to give a <Span>different offset</span> to <Span>each ball</span> 
we will simple use a <Span>for loop</span> to <Span>create the balls</span> 
as we usually do and we will <Span>pass i as the parameter of the offset</span>, 
since <Span>i however will be increased by 1 for each ball</span>, which 
<Span>is a big offset</span> and <Span>would create a big space between the balls</Span>, 
we are gonna <Span>multiply i with 0.02</span> 
to give the balls <Span>smaller offsets</span>. 
Those <Span>offsets</span> will be used inside the <span>noise() function</span>, 
like this: <Span>noise(increment - offset)</Span>, for <Span>x property</Span> however 
we are <Span>also gonna keep the -20 offset</Span> so that the <Span>balls</Span>
aren't moving from the top left corner towards the bottom right corner like before.</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas4');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl, <Span class="orange">offset</span>){
        this.x = x;
        this.y = y;
        this.r = r;
        this.cl = cl;
<span class="orange">        this.offset = offset;</span>
    }
    
    draw(){
        c.fillStyle = this.cl;
        c.beginPath();
        c.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        c.stroke();
        c.fill();
    }

    update(){
<Span class="orange">        this.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
        this.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;</span>
        this.draw();
    }
}

<Span class="orange">let particles = new Array();

let int = function(){
    particles = [];
    for(let i = 0; i < 50; i++){
        let r = 10;
        let x = -999;
        let y = -999;
        let cl = 'red';
        particles.push(new ball(x, y, r, cl, i * 0.02));
    }
}

int();</span>

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        c.clearRect(0, 0, canvas.width, canvas.height);
<Span class="orange">        particles.forEach((particle) =>{
            particle.update();
        });</span>
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</Span></p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas4"></canvas>

<p>This works really nice, all that's left now is to 
add some cool <Span>effects</Span>, you can play around with 
it to see what you can create, I will use some 
simple <span>effects</span> that I have used in previous projects 
just to make it a little more interesting.
</p>

<p class="left">JavaScript Code:</p>

<p class="left"><Span class="code10">const { noise } = require('@chriscourses/perlin-noise')

let canvas = document.querySelector('#canvvaas5');
let c = canvas.getContext('2d');

canvas.width = 500;
canvas.height = 300;

let ball = class{
    constructor(x, y, r, cl, cl2, offset){
        this.x = x;
        this.y = y;
        this.r = r;
        this.innerColor = cl;
        this.outerColor = cl2;
        this.offset = offset;
        this.previousCoords = {x: this.x, y: this.y};
    }
    
    draw(){
        c.lineCap = 'round';
        c.lineJoin = 'round';
        c.strokeStyle = this.outerColor;
        c.lineWidth = this.r;
        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.stroke();
        c.fill();

        c.lineWidth = this.r - 5;
        c.strokeStyle = this.innerColor;
        c.beginPath();
        c.moveTo(this.previousCoords.x, this.previousCoords.y);
        c.lineTo(this.x, this.y);
        c.fill();
        c.stroke();
    }

    update(){
        if(this.x == undefined){
            this.previousCoords.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
            this.previousCoords.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;
        }
        this.x = noise(increment - this.offset - 20) * (canvas.width - 2 * this.r) + this.r;
        this.y = noise(increment - this.offset) * (canvas.height - 2 * this.r) + this.r;
        this.draw();
        this.previousCoords.x = this.x;
        this.previousCoords.y = this.y;
    }
}

let particles = new Array();
let particles2 = new Array();

let colors = ["#F2EBEC", "#C8C1D9", "#5D84A6", "#485159", "#F2D4AE"];

let int = function(){
    particles = [];
    particles2 = [];
    for(let i = 0; i < 30; i++){
        let r = 23;
        let x = undefined;
        let y = undefined;
        let innerColor = colors[Math.floor(Math.random() * colors.length)];
        particles.push(new ball(x, y, r, innerColor, 'red', i * 0.03));
        particles2.push(new ball(x, y, r, innerColor, 'blue', i * 0.03 + 300));
    }
}
int();

function isScrolledIntoView(el) {
    var rect = el.getBoundingClientRect();
    var elemTop = rect.top;
    var elemBottom = rect.bottom;
    var isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);
    return isVisible;
} 

let increment = 0;

let animate = function(){
    if(isScrolledIntoView(canvas)){
        let imageData = c.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        for(let i = 3; i < data.length; i += 4){
            data[i] = data[i] * 0.7;
            if(data[i] / 255 < 0.1){
                data[i] = data[i] * 0;
            }
        }
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.putImageData(imageData, 0, 0);

        particles.forEach((particle) =>{
            particle.update();
        });
        particles2.forEach((particle) =>{
            particle.update();
        });
        increment += 0.01;
    }
    requestAnimationFrame(animate);
}

animate();</Span>
</p>

<p class="left">Outcome:</p>

<canvas class="canvvaas" id="canvvaas5" style="background-color: black;"></canvas>

<p>This tutorial helped me make this section, I recommend you watch it 
if you need extra help:</p>

<iframe  src="https://www.youtube.com/embed/M4WzhdQPyH0?list=PLpPnRKq7eNW3We9VdCfx9fprhqXHwTPXL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<script src="./../CSS-JavaScript-External-Files/dat/canvas/canvas2.js"></script>

</article>
 <hr>
</body>
</html>